<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/SOHU-Co/kafka-node#readme">kafka-node (v1.6.0)</a>
</h1>
<h4>Client for Apache Kafka v0.8+</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node">module kafka-node</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client">
            function <span class="apidocSignatureSpan">kafka-node.</span>Client
            <span class="apidocSignatureSpan">(connectionString, clientId, zkOptions, noAckBatchOptions, sslOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.addTopics">
            function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.addTopics
            <span class="apidocSignatureSpan">(topics, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.brokerForLeader">
            function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.brokerForLeader
            <span class="apidocSignatureSpan">(leader, longpolling)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.checkMetadatas">
            function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.checkMetadatas
            <span class="apidocSignatureSpan">(payloads)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.clearCallbackQueue">
            function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.clearCallbackQueue
            <span class="apidocSignatureSpan">(socket, error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.close">
            function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.close
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.closeBrokers">
            function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.closeBrokers
            <span class="apidocSignatureSpan">(brokers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.connect">
            function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.connect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.createBroker">
            function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.createBroker
            <span class="apidocSignatureSpan">(host, port, longpolling)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.createTopics">
            function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.createTopics
            <span class="apidocSignatureSpan">(topics, isAsync, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.getBrokers">
            function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.getBrokers
            <span class="apidocSignatureSpan">(longpolling)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.handleReceivedData">
            function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.handleReceivedData
            <span class="apidocSignatureSpan">(socket)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.hasMetadata">
            function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.hasMetadata
            <span class="apidocSignatureSpan">(topic, partition)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.leaderByPartition">
            function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.leaderByPartition
            <span class="apidocSignatureSpan">(topic, partition)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.loadMetadataForTopics">
            function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.loadMetadataForTopics
            <span class="apidocSignatureSpan">(topics, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.nextId">
            function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.nextId
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.nextSocketId">
            function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.nextSocketId
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.payloadsByLeader">
            function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.payloadsByLeader
            <span class="apidocSignatureSpan">(payloads)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.queueCallback">
            function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.queueCallback
            <span class="apidocSignatureSpan">(socket, id, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.reconnectBroker">
            function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.reconnectBroker
            <span class="apidocSignatureSpan">(oldSocket)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.refreshBrokers">
            function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.refreshBrokers
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.refreshMetadata">
            function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.refreshMetadata
            <span class="apidocSignatureSpan">(topicNames, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.removeTopicMetadata">
            function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.removeTopicMetadata
            <span class="apidocSignatureSpan">(topics, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.send">
            function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.send
            <span class="apidocSignatureSpan">(payloads, encoder, decoder, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendFetchRequest">
            function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.sendFetchRequest
            <span class="apidocSignatureSpan">(consumer, payloads, fetchMaxWaitMs, fetchMinBytes, maxTickMessages)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendGroupCoordinatorRequest">
            function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.sendGroupCoordinatorRequest
            <span class="apidocSignatureSpan">(groupId, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendGroupRequest">
            function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.sendGroupRequest
            <span class="apidocSignatureSpan">(encode, decode, requestArgs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendHeartbeatRequest">
            function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.sendHeartbeatRequest
            <span class="apidocSignatureSpan">(groupId, generationId, memberId, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendJoinGroupRequest">
            function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.sendJoinGroupRequest
            <span class="apidocSignatureSpan">(groupId, memberId, sessionTimeout, groupProtocol, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendLeaveGroupRequest">
            function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.sendLeaveGroupRequest
            <span class="apidocSignatureSpan">(groupId, memberId, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendOffsetCommitRequest">
            function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.sendOffsetCommitRequest
            <span class="apidocSignatureSpan">(group, payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendOffsetCommitV2Request">
            function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.sendOffsetCommitV2Request
            <span class="apidocSignatureSpan">(group, generationId, memberId, payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendOffsetFetchRequest">
            function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.sendOffsetFetchRequest
            <span class="apidocSignatureSpan">(group, payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendOffsetFetchV1Request">
            function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.sendOffsetFetchV1Request
            <span class="apidocSignatureSpan">(group, payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendOffsetRequest">
            function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.sendOffsetRequest
            <span class="apidocSignatureSpan">(payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendProduceRequest">
            function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.sendProduceRequest
            <span class="apidocSignatureSpan">(payloads, requireAcks, ackTimeoutMs, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendSyncGroupRequest">
            function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.sendSyncGroupRequest
            <span class="apidocSignatureSpan">(groupId, generationId, memberId, groupAssignment, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendToBroker">
            function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.sendToBroker
            <span class="apidocSignatureSpan">(payloads, encoder, decoder, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.setupBroker">
            function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.setupBroker
            <span class="apidocSignatureSpan">(host, port, longpolling, brokers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.setupBrokerProfiles">
            function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.setupBrokerProfiles
            <span class="apidocSignatureSpan">(brokers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.topicExists">
            function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.topicExists
            <span class="apidocSignatureSpan">(topics, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.unqueueCallback">
            function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.unqueueCallback
            <span class="apidocSignatureSpan">(socket, id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.updateMetadatas">
            function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.updateMetadatas
            <span class="apidocSignatureSpan">(metadatas)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer">
            function <span class="apidocSignatureSpan">kafka-node.</span>Consumer
            <span class="apidocSignatureSpan">(client, topics, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.addTopics">
            function <span class="apidocSignatureSpan">kafka-node.</span>Consumer.prototype.addTopics
            <span class="apidocSignatureSpan">(topics, cb, fromOffset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.autoCommit">
            function <span class="apidocSignatureSpan">kafka-node.</span>Consumer.prototype.autoCommit
            <span class="apidocSignatureSpan">(force, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.buildPayloads">
            function <span class="apidocSignatureSpan">kafka-node.</span>Consumer.prototype.buildPayloads
            <span class="apidocSignatureSpan">(payloads)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.close">
            function <span class="apidocSignatureSpan">kafka-node.</span>Consumer.prototype.close
            <span class="apidocSignatureSpan">(force, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.connect">
            function <span class="apidocSignatureSpan">kafka-node.</span>Consumer.prototype.connect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.fetch">
            function <span class="apidocSignatureSpan">kafka-node.</span>Consumer.prototype.fetch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.fetchOffset">
            function <span class="apidocSignatureSpan">kafka-node.</span>Consumer.prototype.fetchOffset
            <span class="apidocSignatureSpan">(payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.init">
            function <span class="apidocSignatureSpan">kafka-node.</span>Consumer.prototype.init
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.pause">
            function <span class="apidocSignatureSpan">kafka-node.</span>Consumer.prototype.pause
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.pauseTopics">
            function <span class="apidocSignatureSpan">kafka-node.</span>Consumer.prototype.pauseTopics
            <span class="apidocSignatureSpan">(topics)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.removeTopics">
            function <span class="apidocSignatureSpan">kafka-node.</span>Consumer.prototype.removeTopics
            <span class="apidocSignatureSpan">(topics, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.resume">
            function <span class="apidocSignatureSpan">kafka-node.</span>Consumer.prototype.resume
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.resumeTopics">
            function <span class="apidocSignatureSpan">kafka-node.</span>Consumer.prototype.resumeTopics
            <span class="apidocSignatureSpan">(topics)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.setOffset">
            function <span class="apidocSignatureSpan">kafka-node.</span>Consumer.prototype.setOffset
            <span class="apidocSignatureSpan">(topic, partition, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.updateOffsets">
            function <span class="apidocSignatureSpan">kafka-node.</span>Consumer.prototype.updateOffsets
            <span class="apidocSignatureSpan">(topics, initing)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup">
            function <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup
            <span class="apidocSignatureSpan">(memberOptions, topics)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.assignPartitions">
            function <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup.prototype.assignPartitions
            <span class="apidocSignatureSpan">(protocol, groupMembers, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.close">
            function <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup.prototype.close
            <span class="apidocSignatureSpan">(force, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.connect">
            function <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup.prototype.connect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.fetchOffset">
            function <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup.prototype.fetchOffset
            <span class="apidocSignatureSpan">(payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.getDefaultOffset">
            function <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup.prototype.getDefaultOffset
            <span class="apidocSignatureSpan">(tp, defaultOffset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.getOffset">
            function <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup.prototype.getOffset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.handleJoinGroup">
            function <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup.prototype.handleJoinGroup
            <span class="apidocSignatureSpan">(joinGroupResponse, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.handleSyncGroup">
            function <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup.prototype.handleSyncGroup
            <span class="apidocSignatureSpan">(syncGroupResponse, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.leaveGroup">
            function <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup.prototype.leaveGroup
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.saveDefaultOffsets">
            function <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup.prototype.saveDefaultOffsets
            <span class="apidocSignatureSpan">(topicPartitionList, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.scheduleReconnect">
            function <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup.prototype.scheduleReconnect
            <span class="apidocSignatureSpan">(timeout)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.sendHeartbeat">
            function <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup.prototype.sendHeartbeat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.sendOffsetCommitRequest">
            function <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup.prototype.sendOffsetCommitRequest
            <span class="apidocSignatureSpan">(commits, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.setCoordinatorId">
            function <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup.prototype.setCoordinatorId
            <span class="apidocSignatureSpan">(coordinatorId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.setupProtocols">
            function <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup.prototype.setupProtocols
            <span class="apidocSignatureSpan">(protocols)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.startHeartbeats">
            function <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup.prototype.startHeartbeats
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.stopHeartbeats">
            function <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup.prototype.stopHeartbeats
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.CustomPartitioner">
            function <span class="apidocSignatureSpan">kafka-node.</span>CustomPartitioner
            <span class="apidocSignatureSpan">(partitioner)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.CustomPartitioner.super_">
            function <span class="apidocSignatureSpan">kafka-node.</span>CustomPartitioner.super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.CyclicPartitioner">
            function <span class="apidocSignatureSpan">kafka-node.</span>CyclicPartitioner
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.CyclicPartitioner.prototype.getPartition">
            function <span class="apidocSignatureSpan">kafka-node.</span>CyclicPartitioner.prototype.getPartition
            <span class="apidocSignatureSpan">(partitions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.DefaultPartitioner">
            function <span class="apidocSignatureSpan">kafka-node.</span>DefaultPartitioner
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.DefaultPartitioner.prototype.getPartition">
            function <span class="apidocSignatureSpan">kafka-node.</span>DefaultPartitioner.prototype.getPartition
            <span class="apidocSignatureSpan">(partitions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer">
            function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer
            <span class="apidocSignatureSpan">(client, topics, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype._releasePartitions">
            function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer.prototype._releasePartitions
            <span class="apidocSignatureSpan">(topicPayloads, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.addTopics">
            function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer.prototype.addTopics
            <span class="apidocSignatureSpan">(topics, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.autoCommit">
            function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer.prototype.autoCommit
            <span class="apidocSignatureSpan">(force, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.buildPayloads">
            function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer.prototype.buildPayloads
            <span class="apidocSignatureSpan">(payloads)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.buildTopicPayloads">
            function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer.prototype.buildTopicPayloads
            <span class="apidocSignatureSpan">(topics)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.close">
            function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer.prototype.close
            <span class="apidocSignatureSpan">(force, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.connect">
            function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer.prototype.connect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.fetch">
            function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer.prototype.fetch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.fetchOffset">
            function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer.prototype.fetchOffset
            <span class="apidocSignatureSpan">(payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.getTopicPayloads">
            function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer.prototype.getTopicPayloads
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.init">
            function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer.prototype.init
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.leaveGroup">
            function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer.prototype.leaveGroup
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.offsetRequest">
            function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer.prototype.offsetRequest
            <span class="apidocSignatureSpan">(payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.pause">
            function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer.prototype.pause
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.rebalanceAttempt">
            function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer.prototype.rebalanceAttempt
            <span class="apidocSignatureSpan">(oldTopicPayloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.registerConsumer">
            function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer.prototype.registerConsumer
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.removeTopics">
            function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer.prototype.removeTopics
            <span class="apidocSignatureSpan">(topics, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.resume">
            function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer.prototype.resume
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.sendOffsetCommitRequest">
            function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer.prototype.sendOffsetCommitRequest
            <span class="apidocSignatureSpan">(commits, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.setOffset">
            function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer.prototype.setOffset
            <span class="apidocSignatureSpan">(topic, partition, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.stop">
            function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer.prototype.stop
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.updateOffsets">
            function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer.prototype.updateOffsets
            <span class="apidocSignatureSpan">(topics, initing)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelProducer">
            function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelProducer
            <span class="apidocSignatureSpan">(client, options, customPartitioner)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelProducer.super_">
            function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelProducer.super_
            <span class="apidocSignatureSpan">(client, options, defaultPartitionerType, customPartitioner)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.buildPayloads">
            function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelProducer.super_.prototype.buildPayloads
            <span class="apidocSignatureSpan">(payloads, topicMetadata)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.close">
            function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelProducer.super_.prototype.close
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.connect">
            function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelProducer.super_.prototype.connect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.createTopics">
            function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelProducer.super_.prototype.createTopics
            <span class="apidocSignatureSpan">(topics, async, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.send">
            function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelProducer.super_.prototype.send
            <span class="apidocSignatureSpan">(payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.KeyedMessage">
            function <span class="apidocSignatureSpan">kafka-node.</span>KeyedMessage
            <span class="apidocSignatureSpan">(key, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.KeyedPartitioner">
            function <span class="apidocSignatureSpan">kafka-node.</span>KeyedPartitioner
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.KeyedPartitioner.prototype.getPartition">
            function <span class="apidocSignatureSpan">kafka-node.</span>KeyedPartitioner.prototype.getPartition
            <span class="apidocSignatureSpan">(partitions, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.KeyedPartitioner.prototype.hashCode">
            function <span class="apidocSignatureSpan">kafka-node.</span>KeyedPartitioner.prototype.hashCode
            <span class="apidocSignatureSpan">(string)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Offset">
            function <span class="apidocSignatureSpan">kafka-node.</span>Offset
            <span class="apidocSignatureSpan">(client)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Offset.prototype.buildPayloads">
            function <span class="apidocSignatureSpan">kafka-node.</span>Offset.prototype.buildPayloads
            <span class="apidocSignatureSpan">(payloads)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Offset.prototype.commit">
            function <span class="apidocSignatureSpan">kafka-node.</span>Offset.prototype.commit
            <span class="apidocSignatureSpan">(groupId, payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Offset.prototype.fetch">
            function <span class="apidocSignatureSpan">kafka-node.</span>Offset.prototype.fetch
            <span class="apidocSignatureSpan">(payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Offset.prototype.fetchCommits">
            function <span class="apidocSignatureSpan">kafka-node.</span>Offset.prototype.fetchCommits
            <span class="apidocSignatureSpan">(groupId, payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Offset.prototype.fetchEarliestOffsets">
            function <span class="apidocSignatureSpan">kafka-node.</span>Offset.prototype.fetchEarliestOffsets
            <span class="apidocSignatureSpan">(topics, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Offset.prototype.fetchLatestOffsets">
            function <span class="apidocSignatureSpan">kafka-node.</span>Offset.prototype.fetchLatestOffsets
            <span class="apidocSignatureSpan">(topics, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Producer">
            function <span class="apidocSignatureSpan">kafka-node.</span>Producer
            <span class="apidocSignatureSpan">(client, options, customPartitioner)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.RandomPartitioner">
            function <span class="apidocSignatureSpan">kafka-node.</span>RandomPartitioner
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.RandomPartitioner.prototype.getPartition">
            function <span class="apidocSignatureSpan">kafka-node.</span>RandomPartitioner.prototype.getPartition
            <span class="apidocSignatureSpan">(partitions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.consumerGroupHeartbeat">
            function <span class="apidocSignatureSpan">kafka-node.</span>consumerGroupHeartbeat
            <span class="apidocSignatureSpan">(client, handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.consumerGroupMigrator">
            function <span class="apidocSignatureSpan">kafka-node.</span>consumerGroupMigrator
            <span class="apidocSignatureSpan">(consumerGroup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.consumerGroupRecovery">
            function <span class="apidocSignatureSpan">kafka-node.</span>consumerGroupRecovery
            <span class="apidocSignatureSpan">(consumerGroup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.logging">
            function <span class="apidocSignatureSpan">kafka-node.</span>logging
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>Consumer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>CyclicPartitioner.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>DefaultPartitioner.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>HighLevelProducer.super_.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>KeyedPartitioner.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>Offset.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>RandomPartitioner.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>consumerGroupMigrator.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>consumerGroupRecovery.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>partitioner</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>utils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>zookeeper</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Client">module kafka-node.Client</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.Client">
            function <span class="apidocSignatureSpan">kafka-node.</span>Client
            <span class="apidocSignatureSpan">(connectionString, clientId, zkOptions, noAckBatchOptions, sslOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.super_">
            function <span class="apidocSignatureSpan">kafka-node.Client.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Client.prototype">module kafka-node.Client.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.addTopics">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>addTopics
            <span class="apidocSignatureSpan">(topics, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.brokerForLeader">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>brokerForLeader
            <span class="apidocSignatureSpan">(leader, longpolling)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.checkMetadatas">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>checkMetadatas
            <span class="apidocSignatureSpan">(payloads)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.clearCallbackQueue">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>clearCallbackQueue
            <span class="apidocSignatureSpan">(socket, error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.close">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>close
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.closeBrokers">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>closeBrokers
            <span class="apidocSignatureSpan">(brokers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.connect">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>connect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.createBroker">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>createBroker
            <span class="apidocSignatureSpan">(host, port, longpolling)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.createTopics">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>createTopics
            <span class="apidocSignatureSpan">(topics, isAsync, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.getBrokers">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>getBrokers
            <span class="apidocSignatureSpan">(longpolling)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.handleReceivedData">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>handleReceivedData
            <span class="apidocSignatureSpan">(socket)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.hasMetadata">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>hasMetadata
            <span class="apidocSignatureSpan">(topic, partition)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.leaderByPartition">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>leaderByPartition
            <span class="apidocSignatureSpan">(topic, partition)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.loadMetadataForTopics">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>loadMetadataForTopics
            <span class="apidocSignatureSpan">(topics, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.nextId">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>nextId
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.nextSocketId">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>nextSocketId
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.payloadsByLeader">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>payloadsByLeader
            <span class="apidocSignatureSpan">(payloads)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.queueCallback">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>queueCallback
            <span class="apidocSignatureSpan">(socket, id, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.reconnectBroker">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>reconnectBroker
            <span class="apidocSignatureSpan">(oldSocket)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.refreshBrokers">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>refreshBrokers
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.refreshMetadata">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>refreshMetadata
            <span class="apidocSignatureSpan">(topicNames, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.removeTopicMetadata">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>removeTopicMetadata
            <span class="apidocSignatureSpan">(topics, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.send">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>send
            <span class="apidocSignatureSpan">(payloads, encoder, decoder, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendFetchRequest">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendFetchRequest
            <span class="apidocSignatureSpan">(consumer, payloads, fetchMaxWaitMs, fetchMinBytes, maxTickMessages)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendGroupCoordinatorRequest">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendGroupCoordinatorRequest
            <span class="apidocSignatureSpan">(groupId, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendGroupRequest">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendGroupRequest
            <span class="apidocSignatureSpan">(encode, decode, requestArgs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendHeartbeatRequest">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendHeartbeatRequest
            <span class="apidocSignatureSpan">(groupId, generationId, memberId, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendJoinGroupRequest">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendJoinGroupRequest
            <span class="apidocSignatureSpan">(groupId, memberId, sessionTimeout, groupProtocol, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendLeaveGroupRequest">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendLeaveGroupRequest
            <span class="apidocSignatureSpan">(groupId, memberId, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendOffsetCommitRequest">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendOffsetCommitRequest
            <span class="apidocSignatureSpan">(group, payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendOffsetCommitV2Request">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendOffsetCommitV2Request
            <span class="apidocSignatureSpan">(group, generationId, memberId, payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendOffsetFetchRequest">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendOffsetFetchRequest
            <span class="apidocSignatureSpan">(group, payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendOffsetFetchV1Request">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendOffsetFetchV1Request
            <span class="apidocSignatureSpan">(group, payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendOffsetRequest">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendOffsetRequest
            <span class="apidocSignatureSpan">(payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendProduceRequest">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendProduceRequest
            <span class="apidocSignatureSpan">(payloads, requireAcks, ackTimeoutMs, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendSyncGroupRequest">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendSyncGroupRequest
            <span class="apidocSignatureSpan">(groupId, generationId, memberId, groupAssignment, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendToBroker">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendToBroker
            <span class="apidocSignatureSpan">(payloads, encoder, decoder, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.setupBroker">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>setupBroker
            <span class="apidocSignatureSpan">(host, port, longpolling, brokers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.setupBrokerProfiles">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>setupBrokerProfiles
            <span class="apidocSignatureSpan">(brokers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.topicExists">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>topicExists
            <span class="apidocSignatureSpan">(topics, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.unqueueCallback">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>unqueueCallback
            <span class="apidocSignatureSpan">(socket, id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.updateMetadatas">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>updateMetadatas
            <span class="apidocSignatureSpan">(metadatas)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Client.prototype.addTopics">module kafka-node.Client.prototype.addTopics</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.addTopics.addTopics">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>addTopics
            <span class="apidocSignatureSpan">(topics, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Client.prototype.brokerForLeader">module kafka-node.Client.prototype.brokerForLeader</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.brokerForLeader.brokerForLeader">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>brokerForLeader
            <span class="apidocSignatureSpan">(leader, longpolling)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Client.prototype.checkMetadatas">module kafka-node.Client.prototype.checkMetadatas</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.checkMetadatas.checkMetadatas">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>checkMetadatas
            <span class="apidocSignatureSpan">(payloads)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Client.prototype.clearCallbackQueue">module kafka-node.Client.prototype.clearCallbackQueue</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.clearCallbackQueue.clearCallbackQueue">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>clearCallbackQueue
            <span class="apidocSignatureSpan">(socket, error)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Client.prototype.close">module kafka-node.Client.prototype.close</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.close.close">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>close
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Client.prototype.closeBrokers">module kafka-node.Client.prototype.closeBrokers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.closeBrokers.closeBrokers">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>closeBrokers
            <span class="apidocSignatureSpan">(brokers)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Client.prototype.connect">module kafka-node.Client.prototype.connect</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.connect.connect">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>connect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Client.prototype.createBroker">module kafka-node.Client.prototype.createBroker</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.createBroker.createBroker">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>createBroker
            <span class="apidocSignatureSpan">(host, port, longpolling)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Client.prototype.createTopics">module kafka-node.Client.prototype.createTopics</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.createTopics.createTopics">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>createTopics
            <span class="apidocSignatureSpan">(topics, isAsync, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Client.prototype.getBrokers">module kafka-node.Client.prototype.getBrokers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.getBrokers.getBrokers">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>getBrokers
            <span class="apidocSignatureSpan">(longpolling)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Client.prototype.handleReceivedData">module kafka-node.Client.prototype.handleReceivedData</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.handleReceivedData.handleReceivedData">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>handleReceivedData
            <span class="apidocSignatureSpan">(socket)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Client.prototype.hasMetadata">module kafka-node.Client.prototype.hasMetadata</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.hasMetadata.hasMetadata">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>hasMetadata
            <span class="apidocSignatureSpan">(topic, partition)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Client.prototype.leaderByPartition">module kafka-node.Client.prototype.leaderByPartition</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.leaderByPartition.leaderByPartition">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>leaderByPartition
            <span class="apidocSignatureSpan">(topic, partition)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Client.prototype.loadMetadataForTopics">module kafka-node.Client.prototype.loadMetadataForTopics</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.loadMetadataForTopics.loadMetadataForTopics">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>loadMetadataForTopics
            <span class="apidocSignatureSpan">(topics, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Client.prototype.nextId">module kafka-node.Client.prototype.nextId</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.nextId.nextId">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>nextId
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Client.prototype.nextSocketId">module kafka-node.Client.prototype.nextSocketId</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.nextSocketId.nextSocketId">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>nextSocketId
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Client.prototype.payloadsByLeader">module kafka-node.Client.prototype.payloadsByLeader</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.payloadsByLeader.payloadsByLeader">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>payloadsByLeader
            <span class="apidocSignatureSpan">(payloads)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Client.prototype.queueCallback">module kafka-node.Client.prototype.queueCallback</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.queueCallback.queueCallback">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>queueCallback
            <span class="apidocSignatureSpan">(socket, id, data)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Client.prototype.reconnectBroker">module kafka-node.Client.prototype.reconnectBroker</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.reconnectBroker.reconnectBroker">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>reconnectBroker
            <span class="apidocSignatureSpan">(oldSocket)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Client.prototype.refreshBrokers">module kafka-node.Client.prototype.refreshBrokers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.refreshBrokers.refreshBrokers">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>refreshBrokers
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Client.prototype.refreshMetadata">module kafka-node.Client.prototype.refreshMetadata</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.refreshMetadata.refreshMetadata">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>refreshMetadata
            <span class="apidocSignatureSpan">(topicNames, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Client.prototype.removeTopicMetadata">module kafka-node.Client.prototype.removeTopicMetadata</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.removeTopicMetadata.removeTopicMetadata">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>removeTopicMetadata
            <span class="apidocSignatureSpan">(topics, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Client.prototype.send">module kafka-node.Client.prototype.send</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.send.send">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>send
            <span class="apidocSignatureSpan">(payloads, encoder, decoder, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Client.prototype.sendFetchRequest">module kafka-node.Client.prototype.sendFetchRequest</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendFetchRequest.sendFetchRequest">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendFetchRequest
            <span class="apidocSignatureSpan">(consumer, payloads, fetchMaxWaitMs, fetchMinBytes, maxTickMessages)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Client.prototype.sendGroupCoordinatorRequest">module kafka-node.Client.prototype.sendGroupCoordinatorRequest</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendGroupCoordinatorRequest.sendGroupCoordinatorRequest">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendGroupCoordinatorRequest
            <span class="apidocSignatureSpan">(groupId, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Client.prototype.sendGroupRequest">module kafka-node.Client.prototype.sendGroupRequest</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendGroupRequest.sendGroupRequest">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendGroupRequest
            <span class="apidocSignatureSpan">(encode, decode, requestArgs)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Client.prototype.sendHeartbeatRequest">module kafka-node.Client.prototype.sendHeartbeatRequest</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendHeartbeatRequest.sendHeartbeatRequest">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendHeartbeatRequest
            <span class="apidocSignatureSpan">(groupId, generationId, memberId, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Client.prototype.sendJoinGroupRequest">module kafka-node.Client.prototype.sendJoinGroupRequest</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendJoinGroupRequest.sendJoinGroupRequest">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendJoinGroupRequest
            <span class="apidocSignatureSpan">(groupId, memberId, sessionTimeout, groupProtocol, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Client.prototype.sendLeaveGroupRequest">module kafka-node.Client.prototype.sendLeaveGroupRequest</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendLeaveGroupRequest.sendLeaveGroupRequest">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendLeaveGroupRequest
            <span class="apidocSignatureSpan">(groupId, memberId, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Client.prototype.sendOffsetCommitRequest">module kafka-node.Client.prototype.sendOffsetCommitRequest</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendOffsetCommitRequest.sendOffsetCommitRequest">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendOffsetCommitRequest
            <span class="apidocSignatureSpan">(group, payloads, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Client.prototype.sendOffsetCommitV2Request">module kafka-node.Client.prototype.sendOffsetCommitV2Request</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendOffsetCommitV2Request.sendOffsetCommitV2Request">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendOffsetCommitV2Request
            <span class="apidocSignatureSpan">(group, generationId, memberId, payloads, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Client.prototype.sendOffsetFetchRequest">module kafka-node.Client.prototype.sendOffsetFetchRequest</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendOffsetFetchRequest.sendOffsetFetchRequest">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendOffsetFetchRequest
            <span class="apidocSignatureSpan">(group, payloads, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Client.prototype.sendOffsetFetchV1Request">module kafka-node.Client.prototype.sendOffsetFetchV1Request</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendOffsetFetchV1Request.sendOffsetFetchV1Request">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendOffsetFetchV1Request
            <span class="apidocSignatureSpan">(group, payloads, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Client.prototype.sendOffsetRequest">module kafka-node.Client.prototype.sendOffsetRequest</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendOffsetRequest.sendOffsetRequest">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendOffsetRequest
            <span class="apidocSignatureSpan">(payloads, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Client.prototype.sendProduceRequest">module kafka-node.Client.prototype.sendProduceRequest</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendProduceRequest.sendProduceRequest">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendProduceRequest
            <span class="apidocSignatureSpan">(payloads, requireAcks, ackTimeoutMs, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Client.prototype.sendSyncGroupRequest">module kafka-node.Client.prototype.sendSyncGroupRequest</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendSyncGroupRequest.sendSyncGroupRequest">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendSyncGroupRequest
            <span class="apidocSignatureSpan">(groupId, generationId, memberId, groupAssignment, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Client.prototype.sendToBroker">module kafka-node.Client.prototype.sendToBroker</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendToBroker.sendToBroker">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendToBroker
            <span class="apidocSignatureSpan">(payloads, encoder, decoder, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Client.prototype.setupBroker">module kafka-node.Client.prototype.setupBroker</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.setupBroker.setupBroker">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>setupBroker
            <span class="apidocSignatureSpan">(host, port, longpolling, brokers)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Client.prototype.setupBrokerProfiles">module kafka-node.Client.prototype.setupBrokerProfiles</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.setupBrokerProfiles.setupBrokerProfiles">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>setupBrokerProfiles
            <span class="apidocSignatureSpan">(brokers)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Client.prototype.topicExists">module kafka-node.Client.prototype.topicExists</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.topicExists.topicExists">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>topicExists
            <span class="apidocSignatureSpan">(topics, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Client.prototype.unqueueCallback">module kafka-node.Client.prototype.unqueueCallback</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.unqueueCallback.unqueueCallback">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>unqueueCallback
            <span class="apidocSignatureSpan">(socket, id)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Client.prototype.updateMetadatas">module kafka-node.Client.prototype.updateMetadatas</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.updateMetadatas.updateMetadatas">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>updateMetadatas
            <span class="apidocSignatureSpan">(metadatas)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Consumer">module kafka-node.Consumer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.Consumer">
            function <span class="apidocSignatureSpan">kafka-node.</span>Consumer
            <span class="apidocSignatureSpan">(client, topics, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.super_">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Consumer.prototype">module kafka-node.Consumer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.addTopics">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>addTopics
            <span class="apidocSignatureSpan">(topics, cb, fromOffset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.autoCommit">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>autoCommit
            <span class="apidocSignatureSpan">(force, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.buildPayloads">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>buildPayloads
            <span class="apidocSignatureSpan">(payloads)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.close">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>close
            <span class="apidocSignatureSpan">(force, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.commit">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>commit
            <span class="apidocSignatureSpan">(force, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.connect">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>connect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.fetch">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>fetch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.fetchOffset">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>fetchOffset
            <span class="apidocSignatureSpan">(payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.init">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>init
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.pause">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>pause
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.pauseTopics">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>pauseTopics
            <span class="apidocSignatureSpan">(topics)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.removeTopics">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>removeTopics
            <span class="apidocSignatureSpan">(topics, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.resume">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>resume
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.resumeTopics">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>resumeTopics
            <span class="apidocSignatureSpan">(topics)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.setOffset">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>setOffset
            <span class="apidocSignatureSpan">(topic, partition, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.updateOffsets">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>updateOffsets
            <span class="apidocSignatureSpan">(topics, initing)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Consumer.prototype.addTopics">module kafka-node.Consumer.prototype.addTopics</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.addTopics.addTopics">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>addTopics
            <span class="apidocSignatureSpan">(topics, cb, fromOffset)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Consumer.prototype.autoCommit">module kafka-node.Consumer.prototype.autoCommit</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.autoCommit.autoCommit">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>autoCommit
            <span class="apidocSignatureSpan">(force, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Consumer.prototype.buildPayloads">module kafka-node.Consumer.prototype.buildPayloads</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.buildPayloads.buildPayloads">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>buildPayloads
            <span class="apidocSignatureSpan">(payloads)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Consumer.prototype.close">module kafka-node.Consumer.prototype.close</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.close.close">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>close
            <span class="apidocSignatureSpan">(force, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Consumer.prototype.connect">module kafka-node.Consumer.prototype.connect</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.connect.connect">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>connect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Consumer.prototype.fetch">module kafka-node.Consumer.prototype.fetch</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.fetch.fetch">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>fetch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Consumer.prototype.fetchOffset">module kafka-node.Consumer.prototype.fetchOffset</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.fetchOffset.fetchOffset">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>fetchOffset
            <span class="apidocSignatureSpan">(payloads, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Consumer.prototype.init">module kafka-node.Consumer.prototype.init</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.init.init">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>init
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Consumer.prototype.pause">module kafka-node.Consumer.prototype.pause</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.pause.pause">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>pause
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Consumer.prototype.pauseTopics">module kafka-node.Consumer.prototype.pauseTopics</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.pauseTopics.pauseTopics">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>pauseTopics
            <span class="apidocSignatureSpan">(topics)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Consumer.prototype.removeTopics">module kafka-node.Consumer.prototype.removeTopics</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.removeTopics.removeTopics">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>removeTopics
            <span class="apidocSignatureSpan">(topics, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Consumer.prototype.resume">module kafka-node.Consumer.prototype.resume</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.resume.resume">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>resume
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Consumer.prototype.resumeTopics">module kafka-node.Consumer.prototype.resumeTopics</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.resumeTopics.resumeTopics">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>resumeTopics
            <span class="apidocSignatureSpan">(topics)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Consumer.prototype.setOffset">module kafka-node.Consumer.prototype.setOffset</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.setOffset.setOffset">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>setOffset
            <span class="apidocSignatureSpan">(topic, partition, offset)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Consumer.prototype.updateOffsets">module kafka-node.Consumer.prototype.updateOffsets</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.updateOffsets.updateOffsets">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>updateOffsets
            <span class="apidocSignatureSpan">(topics, initing)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.ConsumerGroup">module kafka-node.ConsumerGroup</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.ConsumerGroup">
            function <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup
            <span class="apidocSignatureSpan">(memberOptions, topics)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.super_">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.</span>super_
            <span class="apidocSignatureSpan">(client, topics, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.ConsumerGroup.prototype">module kafka-node.ConsumerGroup.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.assignPartitions">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>assignPartitions
            <span class="apidocSignatureSpan">(protocol, groupMembers, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.close">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>close
            <span class="apidocSignatureSpan">(force, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.connect">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>connect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.fetchOffset">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>fetchOffset
            <span class="apidocSignatureSpan">(payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.getDefaultOffset">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>getDefaultOffset
            <span class="apidocSignatureSpan">(tp, defaultOffset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.getOffset">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>getOffset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.handleJoinGroup">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>handleJoinGroup
            <span class="apidocSignatureSpan">(joinGroupResponse, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.handleSyncGroup">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>handleSyncGroup
            <span class="apidocSignatureSpan">(syncGroupResponse, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.leaveGroup">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>leaveGroup
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.saveDefaultOffsets">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>saveDefaultOffsets
            <span class="apidocSignatureSpan">(topicPartitionList, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.scheduleReconnect">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>scheduleReconnect
            <span class="apidocSignatureSpan">(timeout)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.sendHeartbeat">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>sendHeartbeat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.sendOffsetCommitRequest">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>sendOffsetCommitRequest
            <span class="apidocSignatureSpan">(commits, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.setCoordinatorId">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>setCoordinatorId
            <span class="apidocSignatureSpan">(coordinatorId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.setupProtocols">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>setupProtocols
            <span class="apidocSignatureSpan">(protocols)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.startHeartbeats">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>startHeartbeats
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.stopHeartbeats">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>stopHeartbeats
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.ConsumerGroup.prototype.assignPartitions">module kafka-node.ConsumerGroup.prototype.assignPartitions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.assignPartitions.assignPartitions">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>assignPartitions
            <span class="apidocSignatureSpan">(protocol, groupMembers, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.ConsumerGroup.prototype.close">module kafka-node.ConsumerGroup.prototype.close</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.close.close">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>close
            <span class="apidocSignatureSpan">(force, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.ConsumerGroup.prototype.connect">module kafka-node.ConsumerGroup.prototype.connect</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.connect.connect">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>connect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.ConsumerGroup.prototype.fetchOffset">module kafka-node.ConsumerGroup.prototype.fetchOffset</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.fetchOffset.fetchOffset">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>fetchOffset
            <span class="apidocSignatureSpan">(payloads, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.ConsumerGroup.prototype.getDefaultOffset">module kafka-node.ConsumerGroup.prototype.getDefaultOffset</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.getDefaultOffset.getDefaultOffset">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>getDefaultOffset
            <span class="apidocSignatureSpan">(tp, defaultOffset)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.ConsumerGroup.prototype.getOffset">module kafka-node.ConsumerGroup.prototype.getOffset</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.getOffset.getOffset">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>getOffset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.ConsumerGroup.prototype.handleJoinGroup">module kafka-node.ConsumerGroup.prototype.handleJoinGroup</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.handleJoinGroup.handleJoinGroup">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>handleJoinGroup
            <span class="apidocSignatureSpan">(joinGroupResponse, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.ConsumerGroup.prototype.handleSyncGroup">module kafka-node.ConsumerGroup.prototype.handleSyncGroup</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.handleSyncGroup.handleSyncGroup">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>handleSyncGroup
            <span class="apidocSignatureSpan">(syncGroupResponse, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.ConsumerGroup.prototype.leaveGroup">module kafka-node.ConsumerGroup.prototype.leaveGroup</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.leaveGroup.leaveGroup">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>leaveGroup
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.ConsumerGroup.prototype.saveDefaultOffsets">module kafka-node.ConsumerGroup.prototype.saveDefaultOffsets</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.saveDefaultOffsets.saveDefaultOffsets">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>saveDefaultOffsets
            <span class="apidocSignatureSpan">(topicPartitionList, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.ConsumerGroup.prototype.scheduleReconnect">module kafka-node.ConsumerGroup.prototype.scheduleReconnect</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.scheduleReconnect.scheduleReconnect">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>scheduleReconnect
            <span class="apidocSignatureSpan">(timeout)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.ConsumerGroup.prototype.sendHeartbeat">module kafka-node.ConsumerGroup.prototype.sendHeartbeat</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.sendHeartbeat.sendHeartbeat">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>sendHeartbeat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.ConsumerGroup.prototype.sendOffsetCommitRequest">module kafka-node.ConsumerGroup.prototype.sendOffsetCommitRequest</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.sendOffsetCommitRequest.sendOffsetCommitRequest">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>sendOffsetCommitRequest
            <span class="apidocSignatureSpan">(commits, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.ConsumerGroup.prototype.setCoordinatorId">module kafka-node.ConsumerGroup.prototype.setCoordinatorId</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.setCoordinatorId.setCoordinatorId">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>setCoordinatorId
            <span class="apidocSignatureSpan">(coordinatorId)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.ConsumerGroup.prototype.setupProtocols">module kafka-node.ConsumerGroup.prototype.setupProtocols</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.setupProtocols.setupProtocols">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>setupProtocols
            <span class="apidocSignatureSpan">(protocols)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.ConsumerGroup.prototype.startHeartbeats">module kafka-node.ConsumerGroup.prototype.startHeartbeats</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.startHeartbeats.startHeartbeats">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>startHeartbeats
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.ConsumerGroup.prototype.stopHeartbeats">module kafka-node.ConsumerGroup.prototype.stopHeartbeats</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.stopHeartbeats.stopHeartbeats">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>stopHeartbeats
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.CustomPartitioner">module kafka-node.CustomPartitioner</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.CustomPartitioner.CustomPartitioner">
            function <span class="apidocSignatureSpan">kafka-node.</span>CustomPartitioner
            <span class="apidocSignatureSpan">(partitioner)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.CustomPartitioner.super_">
            function <span class="apidocSignatureSpan">kafka-node.CustomPartitioner.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.CustomPartitioner.super_">module kafka-node.CustomPartitioner.super_</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.CustomPartitioner.super_.super_">
            function <span class="apidocSignatureSpan">kafka-node.CustomPartitioner.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.CyclicPartitioner">module kafka-node.CyclicPartitioner</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.CyclicPartitioner.CyclicPartitioner">
            function <span class="apidocSignatureSpan">kafka-node.</span>CyclicPartitioner
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.CyclicPartitioner.super_">
            function <span class="apidocSignatureSpan">kafka-node.CyclicPartitioner.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.CyclicPartitioner.prototype">module kafka-node.CyclicPartitioner.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.CyclicPartitioner.prototype.getPartition">
            function <span class="apidocSignatureSpan">kafka-node.CyclicPartitioner.prototype.</span>getPartition
            <span class="apidocSignatureSpan">(partitions)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.CyclicPartitioner.prototype.getPartition">module kafka-node.CyclicPartitioner.prototype.getPartition</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.CyclicPartitioner.prototype.getPartition.getPartition">
            function <span class="apidocSignatureSpan">kafka-node.CyclicPartitioner.prototype.</span>getPartition
            <span class="apidocSignatureSpan">(partitions)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.DefaultPartitioner">module kafka-node.DefaultPartitioner</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.DefaultPartitioner.DefaultPartitioner">
            function <span class="apidocSignatureSpan">kafka-node.</span>DefaultPartitioner
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.DefaultPartitioner.super_">
            function <span class="apidocSignatureSpan">kafka-node.DefaultPartitioner.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.DefaultPartitioner.prototype">module kafka-node.DefaultPartitioner.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.DefaultPartitioner.prototype.getPartition">
            function <span class="apidocSignatureSpan">kafka-node.DefaultPartitioner.prototype.</span>getPartition
            <span class="apidocSignatureSpan">(partitions)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.DefaultPartitioner.prototype.getPartition">module kafka-node.DefaultPartitioner.prototype.getPartition</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.DefaultPartitioner.prototype.getPartition.getPartition">
            function <span class="apidocSignatureSpan">kafka-node.DefaultPartitioner.prototype.</span>getPartition
            <span class="apidocSignatureSpan">(partitions)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.HighLevelConsumer">module kafka-node.HighLevelConsumer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.HighLevelConsumer">
            function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer
            <span class="apidocSignatureSpan">(client, topics, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.super_">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype">module kafka-node.HighLevelConsumer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype._releasePartitions">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>_releasePartitions
            <span class="apidocSignatureSpan">(topicPayloads, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.addTopics">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>addTopics
            <span class="apidocSignatureSpan">(topics, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.autoCommit">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>autoCommit
            <span class="apidocSignatureSpan">(force, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.buildPayloads">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>buildPayloads
            <span class="apidocSignatureSpan">(payloads)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.buildTopicPayloads">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>buildTopicPayloads
            <span class="apidocSignatureSpan">(topics)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.close">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>close
            <span class="apidocSignatureSpan">(force, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.commit">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>commit
            <span class="apidocSignatureSpan">(force, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.connect">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>connect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.fetch">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>fetch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.fetchOffset">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>fetchOffset
            <span class="apidocSignatureSpan">(payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.getTopicPayloads">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>getTopicPayloads
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.init">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>init
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.leaveGroup">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>leaveGroup
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.offsetRequest">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>offsetRequest
            <span class="apidocSignatureSpan">(payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.pause">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>pause
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.rebalanceAttempt">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>rebalanceAttempt
            <span class="apidocSignatureSpan">(oldTopicPayloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.registerConsumer">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>registerConsumer
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.removeTopics">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>removeTopics
            <span class="apidocSignatureSpan">(topics, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.resume">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>resume
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.sendOffsetCommitRequest">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>sendOffsetCommitRequest
            <span class="apidocSignatureSpan">(commits, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.setOffset">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>setOffset
            <span class="apidocSignatureSpan">(topic, partition, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.stop">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>stop
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.updateOffsets">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>updateOffsets
            <span class="apidocSignatureSpan">(topics, initing)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype._releasePartitions">module kafka-node.HighLevelConsumer.prototype._releasePartitions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype._releasePartitions._releasePartitions">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>_releasePartitions
            <span class="apidocSignatureSpan">(topicPayloads, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype.addTopics">module kafka-node.HighLevelConsumer.prototype.addTopics</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.addTopics.addTopics">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>addTopics
            <span class="apidocSignatureSpan">(topics, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype.autoCommit">module kafka-node.HighLevelConsumer.prototype.autoCommit</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.autoCommit.autoCommit">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>autoCommit
            <span class="apidocSignatureSpan">(force, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype.buildPayloads">module kafka-node.HighLevelConsumer.prototype.buildPayloads</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.buildPayloads.buildPayloads">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>buildPayloads
            <span class="apidocSignatureSpan">(payloads)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype.buildTopicPayloads">module kafka-node.HighLevelConsumer.prototype.buildTopicPayloads</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.buildTopicPayloads.buildTopicPayloads">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>buildTopicPayloads
            <span class="apidocSignatureSpan">(topics)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype.close">module kafka-node.HighLevelConsumer.prototype.close</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.close.close">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>close
            <span class="apidocSignatureSpan">(force, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype.connect">module kafka-node.HighLevelConsumer.prototype.connect</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.connect.connect">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>connect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype.fetch">module kafka-node.HighLevelConsumer.prototype.fetch</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.fetch.fetch">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>fetch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype.fetchOffset">module kafka-node.HighLevelConsumer.prototype.fetchOffset</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.fetchOffset.fetchOffset">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>fetchOffset
            <span class="apidocSignatureSpan">(payloads, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype.getTopicPayloads">module kafka-node.HighLevelConsumer.prototype.getTopicPayloads</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.getTopicPayloads.getTopicPayloads">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>getTopicPayloads
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype.init">module kafka-node.HighLevelConsumer.prototype.init</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.init.init">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>init
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype.leaveGroup">module kafka-node.HighLevelConsumer.prototype.leaveGroup</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.leaveGroup.leaveGroup">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>leaveGroup
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype.offsetRequest">module kafka-node.HighLevelConsumer.prototype.offsetRequest</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.offsetRequest.offsetRequest">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>offsetRequest
            <span class="apidocSignatureSpan">(payloads, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype.pause">module kafka-node.HighLevelConsumer.prototype.pause</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.pause.pause">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>pause
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype.rebalanceAttempt">module kafka-node.HighLevelConsumer.prototype.rebalanceAttempt</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.rebalanceAttempt.rebalanceAttempt">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>rebalanceAttempt
            <span class="apidocSignatureSpan">(oldTopicPayloads, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype.registerConsumer">module kafka-node.HighLevelConsumer.prototype.registerConsumer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.registerConsumer.registerConsumer">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>registerConsumer
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype.removeTopics">module kafka-node.HighLevelConsumer.prototype.removeTopics</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.removeTopics.removeTopics">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>removeTopics
            <span class="apidocSignatureSpan">(topics, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype.resume">module kafka-node.HighLevelConsumer.prototype.resume</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.resume.resume">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>resume
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype.sendOffsetCommitRequest">module kafka-node.HighLevelConsumer.prototype.sendOffsetCommitRequest</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.sendOffsetCommitRequest.sendOffsetCommitRequest">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>sendOffsetCommitRequest
            <span class="apidocSignatureSpan">(commits, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype.setOffset">module kafka-node.HighLevelConsumer.prototype.setOffset</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.setOffset.setOffset">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>setOffset
            <span class="apidocSignatureSpan">(topic, partition, offset)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype.stop">module kafka-node.HighLevelConsumer.prototype.stop</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.stop.stop">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>stop
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype.updateOffsets">module kafka-node.HighLevelConsumer.prototype.updateOffsets</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.updateOffsets.updateOffsets">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>updateOffsets
            <span class="apidocSignatureSpan">(topics, initing)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.HighLevelProducer">module kafka-node.HighLevelProducer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelProducer.HighLevelProducer">
            function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelProducer
            <span class="apidocSignatureSpan">(client, options, customPartitioner)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelProducer.super_">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.</span>super_
            <span class="apidocSignatureSpan">(client, options, defaultPartitionerType, customPartitioner)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.</span>PARTITIONER_TYPES</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.HighLevelProducer.super_">module kafka-node.HighLevelProducer.super_</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelProducer.super_.super_">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.super_.</span>PARTITIONER_TYPES</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.HighLevelProducer.super_.prototype">module kafka-node.HighLevelProducer.super_.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.buildPayloads">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.super_.prototype.</span>buildPayloads
            <span class="apidocSignatureSpan">(payloads, topicMetadata)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.close">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.super_.prototype.</span>close
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.connect">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.super_.prototype.</span>connect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.createTopics">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.super_.prototype.</span>createTopics
            <span class="apidocSignatureSpan">(topics, async, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.send">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.super_.prototype.</span>send
            <span class="apidocSignatureSpan">(payloads, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.HighLevelProducer.super_.prototype.buildPayloads">module kafka-node.HighLevelProducer.super_.prototype.buildPayloads</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.buildPayloads.buildPayloads">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.super_.prototype.</span>buildPayloads
            <span class="apidocSignatureSpan">(payloads, topicMetadata)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.HighLevelProducer.super_.prototype.close">module kafka-node.HighLevelProducer.super_.prototype.close</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.close.close">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.super_.prototype.</span>close
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.HighLevelProducer.super_.prototype.connect">module kafka-node.HighLevelProducer.super_.prototype.connect</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.connect.connect">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.super_.prototype.</span>connect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.HighLevelProducer.super_.prototype.createTopics">module kafka-node.HighLevelProducer.super_.prototype.createTopics</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.createTopics.createTopics">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.super_.prototype.</span>createTopics
            <span class="apidocSignatureSpan">(topics, async, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.HighLevelProducer.super_.prototype.send">module kafka-node.HighLevelProducer.super_.prototype.send</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.send.send">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.super_.prototype.</span>send
            <span class="apidocSignatureSpan">(payloads, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.KeyedMessage">module kafka-node.KeyedMessage</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.KeyedMessage.KeyedMessage">
            function <span class="apidocSignatureSpan">kafka-node.</span>KeyedMessage
            <span class="apidocSignatureSpan">(key, value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.KeyedPartitioner">module kafka-node.KeyedPartitioner</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.KeyedPartitioner.KeyedPartitioner">
            function <span class="apidocSignatureSpan">kafka-node.</span>KeyedPartitioner
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.KeyedPartitioner.super_">
            function <span class="apidocSignatureSpan">kafka-node.KeyedPartitioner.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.KeyedPartitioner.prototype">module kafka-node.KeyedPartitioner.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.KeyedPartitioner.prototype.getPartition">
            function <span class="apidocSignatureSpan">kafka-node.KeyedPartitioner.prototype.</span>getPartition
            <span class="apidocSignatureSpan">(partitions, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.KeyedPartitioner.prototype.hashCode">
            function <span class="apidocSignatureSpan">kafka-node.KeyedPartitioner.prototype.</span>hashCode
            <span class="apidocSignatureSpan">(string)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.KeyedPartitioner.prototype.getPartition">module kafka-node.KeyedPartitioner.prototype.getPartition</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.KeyedPartitioner.prototype.getPartition.getPartition">
            function <span class="apidocSignatureSpan">kafka-node.KeyedPartitioner.prototype.</span>getPartition
            <span class="apidocSignatureSpan">(partitions, key)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.KeyedPartitioner.prototype.hashCode">module kafka-node.KeyedPartitioner.prototype.hashCode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.KeyedPartitioner.prototype.hashCode.hashCode">
            function <span class="apidocSignatureSpan">kafka-node.KeyedPartitioner.prototype.</span>hashCode
            <span class="apidocSignatureSpan">(string)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Offset">module kafka-node.Offset</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Offset.Offset">
            function <span class="apidocSignatureSpan">kafka-node.</span>Offset
            <span class="apidocSignatureSpan">(client)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Offset.super_">
            function <span class="apidocSignatureSpan">kafka-node.Offset.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Offset.prototype">module kafka-node.Offset.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Offset.prototype.buildPayloads">
            function <span class="apidocSignatureSpan">kafka-node.Offset.prototype.</span>buildPayloads
            <span class="apidocSignatureSpan">(payloads)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Offset.prototype.commit">
            function <span class="apidocSignatureSpan">kafka-node.Offset.prototype.</span>commit
            <span class="apidocSignatureSpan">(groupId, payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Offset.prototype.fetch">
            function <span class="apidocSignatureSpan">kafka-node.Offset.prototype.</span>fetch
            <span class="apidocSignatureSpan">(payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Offset.prototype.fetchCommits">
            function <span class="apidocSignatureSpan">kafka-node.Offset.prototype.</span>fetchCommits
            <span class="apidocSignatureSpan">(groupId, payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Offset.prototype.fetchEarliestOffsets">
            function <span class="apidocSignatureSpan">kafka-node.Offset.prototype.</span>fetchEarliestOffsets
            <span class="apidocSignatureSpan">(topics, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Offset.prototype.fetchLatestOffsets">
            function <span class="apidocSignatureSpan">kafka-node.Offset.prototype.</span>fetchLatestOffsets
            <span class="apidocSignatureSpan">(topics, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Offset.prototype.buildPayloads">module kafka-node.Offset.prototype.buildPayloads</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Offset.prototype.buildPayloads.buildPayloads">
            function <span class="apidocSignatureSpan">kafka-node.Offset.prototype.</span>buildPayloads
            <span class="apidocSignatureSpan">(payloads)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Offset.prototype.commit">module kafka-node.Offset.prototype.commit</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Offset.prototype.commit.commit">
            function <span class="apidocSignatureSpan">kafka-node.Offset.prototype.</span>commit
            <span class="apidocSignatureSpan">(groupId, payloads, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Offset.prototype.fetch">module kafka-node.Offset.prototype.fetch</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Offset.prototype.fetch.fetch">
            function <span class="apidocSignatureSpan">kafka-node.Offset.prototype.</span>fetch
            <span class="apidocSignatureSpan">(payloads, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Offset.prototype.fetchCommits">module kafka-node.Offset.prototype.fetchCommits</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Offset.prototype.fetchCommits.fetchCommits">
            function <span class="apidocSignatureSpan">kafka-node.Offset.prototype.</span>fetchCommits
            <span class="apidocSignatureSpan">(groupId, payloads, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Offset.prototype.fetchEarliestOffsets">module kafka-node.Offset.prototype.fetchEarliestOffsets</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Offset.prototype.fetchEarliestOffsets.fetchEarliestOffsets">
            function <span class="apidocSignatureSpan">kafka-node.Offset.prototype.</span>fetchEarliestOffsets
            <span class="apidocSignatureSpan">(topics, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Offset.prototype.fetchLatestOffsets">module kafka-node.Offset.prototype.fetchLatestOffsets</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Offset.prototype.fetchLatestOffsets.fetchLatestOffsets">
            function <span class="apidocSignatureSpan">kafka-node.Offset.prototype.</span>fetchLatestOffsets
            <span class="apidocSignatureSpan">(topics, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Producer">module kafka-node.Producer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Producer.Producer">
            function <span class="apidocSignatureSpan">kafka-node.</span>Producer
            <span class="apidocSignatureSpan">(client, options, customPartitioner)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Producer.super_">
            function <span class="apidocSignatureSpan">kafka-node.Producer.</span>super_
            <span class="apidocSignatureSpan">(client, options, defaultPartitionerType, customPartitioner)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.Producer.</span>PARTITIONER_TYPES</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.RandomPartitioner">module kafka-node.RandomPartitioner</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.RandomPartitioner.RandomPartitioner">
            function <span class="apidocSignatureSpan">kafka-node.</span>RandomPartitioner
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.RandomPartitioner.super_">
            function <span class="apidocSignatureSpan">kafka-node.RandomPartitioner.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.RandomPartitioner.prototype">module kafka-node.RandomPartitioner.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.RandomPartitioner.prototype.getPartition">
            function <span class="apidocSignatureSpan">kafka-node.RandomPartitioner.prototype.</span>getPartition
            <span class="apidocSignatureSpan">(partitions)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.RandomPartitioner.prototype.getPartition">module kafka-node.RandomPartitioner.prototype.getPartition</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.RandomPartitioner.prototype.getPartition.getPartition">
            function <span class="apidocSignatureSpan">kafka-node.RandomPartitioner.prototype.</span>getPartition
            <span class="apidocSignatureSpan">(partitions)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.consumerGroupHeartbeat">module kafka-node.consumerGroupHeartbeat</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.consumerGroupHeartbeat.consumerGroupHeartbeat">
            function <span class="apidocSignatureSpan">kafka-node.</span>consumerGroupHeartbeat
            <span class="apidocSignatureSpan">(client, handler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.consumerGroupMigrator">module kafka-node.consumerGroupMigrator</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.consumerGroupMigrator.consumerGroupMigrator">
            function <span class="apidocSignatureSpan">kafka-node.</span>consumerGroupMigrator
            <span class="apidocSignatureSpan">(consumerGroup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.consumerGroupMigrator.super_">
            function <span class="apidocSignatureSpan">kafka-node.consumerGroupMigrator.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.consumerGroupMigrator.prototype">module kafka-node.consumerGroupMigrator.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.consumerGroupMigrator.prototype.checkForOwners">
            function <span class="apidocSignatureSpan">kafka-node.consumerGroupMigrator.prototype.</span>checkForOwners
            <span class="apidocSignatureSpan">(topics, listenForChange)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.consumerGroupMigrator.prototype.checkForOwnersAndListenForChange">
            function <span class="apidocSignatureSpan">kafka-node.consumerGroupMigrator.prototype.</span>checkForOwnersAndListenForChange
            <span class="apidocSignatureSpan">(topics)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.consumerGroupMigrator.prototype.connectConsumerGroup">
            function <span class="apidocSignatureSpan">kafka-node.consumerGroupMigrator.prototype.</span>connectConsumerGroup
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.consumerGroupMigrator.prototype.filterByExistingZkTopics">
            function <span class="apidocSignatureSpan">kafka-node.consumerGroupMigrator.prototype.</span>filterByExistingZkTopics
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.consumerGroupMigrator.prototype.getOffset">
            function <span class="apidocSignatureSpan">kafka-node.consumerGroupMigrator.prototype.</span>getOffset
            <span class="apidocSignatureSpan">(tp, defaultOffset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.consumerGroupMigrator.prototype.saveHighLevelConsumerOffsets">
            function <span class="apidocSignatureSpan">kafka-node.consumerGroupMigrator.prototype.</span>saveHighLevelConsumerOffsets
            <span class="apidocSignatureSpan">(topicPartitionList, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.consumerGroupRecovery">module kafka-node.consumerGroupRecovery</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.consumerGroupRecovery.consumerGroupRecovery">
            function <span class="apidocSignatureSpan">kafka-node.</span>consumerGroupRecovery
            <span class="apidocSignatureSpan">(consumerGroup)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.consumerGroupRecovery.prototype">module kafka-node.consumerGroupRecovery.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.consumerGroupRecovery.prototype.clearError">
            function <span class="apidocSignatureSpan">kafka-node.consumerGroupRecovery.prototype.</span>clearError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.consumerGroupRecovery.prototype.getRetryTimeout">
            function <span class="apidocSignatureSpan">kafka-node.consumerGroupRecovery.prototype.</span>getRetryTimeout
            <span class="apidocSignatureSpan">(error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.consumerGroupRecovery.prototype.tryToRecoverFrom">
            function <span class="apidocSignatureSpan">kafka-node.consumerGroupRecovery.prototype.</span>tryToRecoverFrom
            <span class="apidocSignatureSpan">(error, source)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.logging">module kafka-node.logging</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.logging.logging">
            function <span class="apidocSignatureSpan">kafka-node.</span>logging
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.logging.setLoggerProvider">
            function <span class="apidocSignatureSpan">kafka-node.logging.</span>setLoggerProvider
            <span class="apidocSignatureSpan">(provider)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.partitioner">module kafka-node.partitioner</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.partitioner.CustomPartitioner">
            function <span class="apidocSignatureSpan">kafka-node.partitioner.</span>CustomPartitioner
            <span class="apidocSignatureSpan">(partitioner)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.partitioner.CyclicPartitioner">
            function <span class="apidocSignatureSpan">kafka-node.partitioner.</span>CyclicPartitioner
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.partitioner.DefaultPartitioner">
            function <span class="apidocSignatureSpan">kafka-node.partitioner.</span>DefaultPartitioner
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.partitioner.KeyedPartitioner">
            function <span class="apidocSignatureSpan">kafka-node.partitioner.</span>KeyedPartitioner
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.partitioner.RandomPartitioner">
            function <span class="apidocSignatureSpan">kafka-node.partitioner.</span>RandomPartitioner
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.utils">module kafka-node.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.utils.createTopicPartitionList">
            function <span class="apidocSignatureSpan">kafka-node.utils.</span>createTopicPartitionList
            <span class="apidocSignatureSpan">(topicPartitions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.utils.groupPartitionsByTopic">
            function <span class="apidocSignatureSpan">kafka-node.utils.</span>groupPartitionsByTopic
            <span class="apidocSignatureSpan">(topicPartitions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.utils.validateConfig">
            function <span class="apidocSignatureSpan">kafka-node.utils.</span>validateConfig
            <span class="apidocSignatureSpan">(property, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.utils.validateTopicNames">
            function <span class="apidocSignatureSpan">kafka-node.utils.</span>validateTopicNames
            <span class="apidocSignatureSpan">(topics)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.utils.validateTopics">
            function <span class="apidocSignatureSpan">kafka-node.utils.</span>validateTopics
            <span class="apidocSignatureSpan">(topics)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.zookeeper">module kafka-node.zookeeper</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.zookeeper.Zookeeper">
            function <span class="apidocSignatureSpan">kafka-node.zookeeper.</span>Zookeeper
            <span class="apidocSignatureSpan">(connectionString, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.zookeeper.ZookeeperConsumerMappings">
            function <span class="apidocSignatureSpan">kafka-node.zookeeper.</span>ZookeeperConsumerMappings
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node" id="apidoc.module.kafka-node">module kafka-node</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client" id="apidoc.element.kafka-node.Client">
        function <span class="apidocSignatureSpan">kafka-node.</span>Client
        <span class="apidocSignatureSpan">(connectionString, clientId, zkOptions, noAckBatchOptions, sslOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client = function (connectionString, clientId, zkOptions, noAckBatchOptions, sslOptions) {
  if (this instanceof Client === false) {
    return new Client(connectionString, clientId, zkOptions, noAckBatchOptions, sslOptions);
  }

  this.sslOptions = sslOptions;
  this.ssl = !!sslOptions;

  if (clientId) {
    validateConfig('clientId', clientId);
  }

  this.connectionString = connectionString || 'localhost:2181/';
  this.clientId = clientId || 'kafka-node-client';
  this.zkOptions = zkOptions;
  this.noAckBatchOptions = noAckBatchOptions;
  this.brokers = {};
  this.longpollingBrokers = {};
  this.topicMetadata = {};
  this.topicPartitions = {};
  this.correlationId = 0;
  this._socketId = 0;
  this.cbqueue = {};
  this.brokerMetadata = {};
  this.ready = false;
  this.connect();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    partitionerType: 2
}
```

``` js
var kafka = require('kafka-node'),
    Producer = kafka.Producer,
    client = new kafka.<span class="apidocCodeKeywordSpan">Client</span>(),
    producer = new Producer(client);
```

### Events

- `ready`: this event is emitted when producer is ready to send messages.
- `error`: this is the error event propagates from internal client, producer should always listen it.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.addTopics" id="apidoc.element.kafka-node.Client.prototype.addTopics">
        function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.addTopics
        <span class="apidocSignatureSpan">(topics, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client.prototype.addTopics = function (topics, cb) {
  var self = this;
  this.topicExists(topics, function (err) {
    if (err) return cb(err);
    self.loadMetadataForTopics(topics, function (err, resp) {
      if (err) return cb(err);
      self.updateMetadatas(resp);
      cb(null, topics);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.brokerForLeader" id="apidoc.element.kafka-node.Client.prototype.brokerForLeader">
        function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.brokerForLeader
        <span class="apidocSignatureSpan">(leader, longpolling)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client.prototype.brokerForLeader = function (leader, longpolling) {
  var addr;
  var brokers = this.getBrokers(longpolling);
  // If leader is not give, choose the first broker as leader
  if (typeof leader === 'undefined') {
    if (!_.isEmpty(brokers)) {
      addr = Object.keys(brokers)[0];
      return brokers[addr];
    } else if (!_.isEmpty(this.brokerMetadata)) {
      leader = Object.keys(this.brokerMetadata)[0];
    } else {
      return;
    }
  }

  var broker = _.find(this.brokerProfiles, {id: leader});

  if (!broker) {
    return;
  }

  addr = broker.host + ':' + broker.port;

  return brokers[addr] || this.setupBroker(broker.host, broker.port, longpolling, brokers);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.checkMetadatas" id="apidoc.element.kafka-node.Client.prototype.checkMetadatas">
        function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.checkMetadatas
        <span class="apidocSignatureSpan">(payloads)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client.prototype.checkMetadatas = function (payloads) {
  if (_.isEmpty(this.topicMetadata)) return [ [], payloads ];
  // out: [ [metadata exists], [metadata not exists] ]
  var out = [ [], [] ];
  payloads.forEach(function (p) {
    if (this.hasMetadata(p.topic, p.partition)) out[0].push(p);
    else out[1].push(p);
  }.bind(this));
  return out;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.clearCallbackQueue" id="apidoc.element.kafka-node.Client.prototype.clearCallbackQueue">
        function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.clearCallbackQueue
        <span class="apidocSignatureSpan">(socket, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client.prototype.clearCallbackQueue = function (socket, error) {
  var socketId = socket.socketId;
  var longpolling = socket.longpolling;

  if (!this.cbqueue.hasOwnProperty(socketId)) {
    return;
  }

  var queue = this.cbqueue[socketId];

  if (!longpolling) {
    Object.keys(queue).forEach(function (key) {
      var handlers = queue[key];
      var cb = handlers[1];
      cb(error);
    });
  }
  delete this.cbqueue[socketId];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.close" id="apidoc.element.kafka-node.Client.prototype.close">
        function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.close
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client.prototype.close = function (cb) {
  this.closeBrokers(this.brokers);
  this.closeBrokers(this.longpollingBrokers);
  this.zk.close();
  cb &amp;&amp; cb();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.closeBrokers" id="apidoc.element.kafka-node.Client.prototype.closeBrokers">
        function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.closeBrokers
        <span class="apidocSignatureSpan">(brokers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client.prototype.closeBrokers = function (brokers) {
  _.each(brokers, function (broker) {
    broker.socket.closing = true;
    broker.socket.end();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.connect" id="apidoc.element.kafka-node.Client.prototype.connect">
        function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.connect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client.prototype.connect = function () {
  var zk = this.zk = new Zookeeper(this.connectionString, this.zkOptions);
  var self = this;
  zk.once('init', function (brokers) {
    try {
      self.ready = true;
      self.brokerMetadata = brokers;
      self.setupBrokerProfiles(brokers);
      Object
          .keys(self.brokerProfiles)
          .some(function (key, index) {
            var broker = self.brokerProfiles[key];
            self.setupBroker(broker.host, broker.port, false, self.brokers);
            // Only connect one broker
            return !index;
          });
      self.emit('ready');
    } catch (error) {
      self.ready = false;
      self.emit('error', error);
    }
  });
  zk.on('brokersChanged', function (brokerMetadata) {
    try {
      self.brokerMetadata = brokerMetadata;
      logger.debug('brokersChanged', brokerMetadata);
      self.setupBrokerProfiles(brokerMetadata);
      self.refreshBrokers();
      // Emit after a 3 seconds
      setTimeout(function () {
        self.emit('brokersChanged');
      }, 3000);
    } catch (error) {
      self.emit('error', error);
    }
  });
  zk.once('disconnected', function () {
    if (!zk.closed) {
      zk.close();
      self.connect();
      self.emit('zkReconnect');
    }
  });
  zk.on('error', function (err) {
    self.emit('error', err);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.createBroker" id="apidoc.element.kafka-node.Client.prototype.createBroker">
        function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.createBroker
        <span class="apidocSignatureSpan">(host, port, longpolling)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client.prototype.createBroker = function (host, port, longpolling) {
  var self = this;
  var socket;
  if (self.ssl) {
    socket = tls.connect(port, host, self.sslOptions);
  } else {
    socket = net.createConnection(port, host);
  }
  socket.addr = host + ':' + port;
  socket.host = host;
  socket.port = port;
  socket.socketId = this.nextSocketId();
  if (longpolling) socket.longpolling = true;

  socket.on('connect', function () {
    var lastError = this.error;
    this.error = null;
    if (lastError) {
      this.waiting = false;
      self.emit('reconnect');
    } else {
      self.emit('connect');
    }
  });
  socket.on('error', function (err) {
    this.error = err;
    self.emit('error', err);
  });
  socket.on('close', function (hadError) {
    self.emit('close', this);
    if (hadError &amp;&amp; this.error) {
      self.clearCallbackQueue(this, this.error);
    } else {
      self.clearCallbackQueue(this, new errors.BrokerNotAvailableError('Broker not available'));
    }
    retry(this);
  });
  socket.on('end', function () {
    retry(this);
  });
  socket.buffer = new Buffer([]);
  socket.on('data', function (data) {
    this.buffer = Buffer.concat([this.buffer, data]);
    self.handleReceivedData(this);
  });
  socket.setKeepAlive(true, 60000);

  function retry (s) {
    if (s.retrying || s.closing) return;
    s.retrying = true;
    s.retryTimer = setTimeout(function () {
      if (s.closing) return;
      self.reconnectBroker(s);
    }, 1000);
  }
  return new BrokerWrapper(socket, this.noAckBatchOptions);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.createTopics" id="apidoc.element.kafka-node.Client.prototype.createTopics">
        function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.createTopics
        <span class="apidocSignatureSpan">(topics, isAsync, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client.prototype.createTopics = function (topics, isAsync, cb) {
  topics = typeof topics === 'string' ? [topics] : topics;

  if (typeof isAsync === 'function' &amp;&amp; typeof cb === 'undefined') {
    cb = isAsync;
    isAsync = true;
  }

  try {
    validateKafkaTopics(topics);
  } catch (e) {
    if (isAsync) return cb(e);
    throw e;
  }

  cb = _.once(cb);

  const getTopicsFromKafka = (topics, callback) =&gt; {
    this.loadMetadataForTopics(topics, function (error, resp) {
      if (error) {
        return callback(error);
      }
      callback(null, Object.keys(resp[1].metadata));
    });
  };

  const operation = retry.operation({ minTimeout: 200, maxTimeout: 2000 });

  operation.attempt(currentAttempt =&gt; {
    logger.debug('create topics currentAttempt', currentAttempt);
    getTopicsFromKafka(topics, function (error, kafkaTopics) {
      if (error) {
        if (operation.retry(error)) {
          return;
        }
      }

      logger.debug('kafka reported topics', kafkaTopics);
      const left = _.difference(topics, kafkaTopics);
      if (left.length === 0) {
        logger.debug(`Topics created ${kafkaTopics}`);
        return cb(null, kafkaTopics);
      }

      logger.debug(`Topics left ${left.join(', ')}`);
      if (!operation.retry(new Error(`Topics not created ${left}`))) {
        cb(operation.mainError());
      }
    });
  });

  if (!isAsync) {
    cb(null);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.getBrokers" id="apidoc.element.kafka-node.Client.prototype.getBrokers">
        function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.getBrokers
        <span class="apidocSignatureSpan">(longpolling)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client.prototype.getBrokers = function (longpolling) {
  return longpolling ? this.longpollingBrokers : this.brokers;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.handleReceivedData" id="apidoc.element.kafka-node.Client.prototype.handleReceivedData">
        function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.handleReceivedData
        <span class="apidocSignatureSpan">(socket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client.prototype.handleReceivedData = function (socket) {
  var vars = Binary.parse(socket.buffer).word32bu('size').word32bu('correlationId').vars;
  var size = vars.size + 4;
  var correlationId = vars.correlationId;

  if (socket.buffer.length &gt;= size) {
    var resp = socket.buffer.slice(0, size);
    var handlers = this.unqueueCallback(socket, correlationId);

    if (!handlers) return;
    var decoder = handlers[0];
    var cb = handlers[1];
    var result = decoder(resp);
    (result instanceof Error)
      ? cb.call(this, result)
      : cb.call(this, null, result);
    socket.buffer = socket.buffer.slice(size);
    if (socket.longpolling) socket.waiting = false;
  } else { return; }

  if (socket.buffer.length) {
    setImmediate(function () { this.handleReceivedData(socket); }.bind(this));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.hasMetadata" id="apidoc.element.kafka-node.Client.prototype.hasMetadata">
        function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.hasMetadata
        <span class="apidocSignatureSpan">(topic, partition)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client.prototype.hasMetadata = function (topic, partition) {
  var brokerMetadata = this.brokerMetadata;
  var leader = this.leaderByPartition(topic, partition);

  return (leader !== undefined) &amp;&amp; brokerMetadata[leader];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.leaderByPartition" id="apidoc.element.kafka-node.Client.prototype.leaderByPartition">
        function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.leaderByPartition
        <span class="apidocSignatureSpan">(topic, partition)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client.prototype.leaderByPartition = function (topic, partition) {
  var topicMetadata = this.topicMetadata;
  return topicMetadata[topic] &amp;&amp; topicMetadata[topic][partition] &amp;&amp; topicMetadata[topic][partition].leader;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.loadMetadataForTopics" id="apidoc.element.kafka-node.Client.prototype.loadMetadataForTopics">
        function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.loadMetadataForTopics
        <span class="apidocSignatureSpan">(topics, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client.prototype.loadMetadataForTopics = function (topics, cb) {
  var correlationId = this.nextId();
  var request = protocol.encodeMetadataRequest(this.clientId, correlationId, topics);
  var broker = this.brokerForLeader();

  if (!broker || !broker.socket || broker.socket.error || broker.socket.destroyed) {
    return cb(new errors.BrokerNotAvailableError('Broker not available'));
  }

  this.queueCallback(broker.socket, correlationId, [protocol.decodeMetadataResponse, cb]);
  broker.write(request);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.nextId" id="apidoc.element.kafka-node.Client.prototype.nextId">
        function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.nextId
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client.prototype.nextId = function () {
  if (this.correlationId &gt;= MAX_INT32) {
    this.correlationId = 0;
  }
  return this.correlationId++;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.nextSocketId" id="apidoc.element.kafka-node.Client.prototype.nextSocketId">
        function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.nextSocketId
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client.prototype.nextSocketId = function () {
  return this._socketId++;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.payloadsByLeader" id="apidoc.element.kafka-node.Client.prototype.payloadsByLeader">
        function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.payloadsByLeader
        <span class="apidocSignatureSpan">(payloads)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client.prototype.payloadsByLeader = function (payloads) {
  return payloads.reduce(function (out, p) {
    var leader = this.leaderByPartition(p.topic, p.partition);
    out[leader] = out[leader] || [];
    out[leader].push(p);
    return out;
  }.bind(this), {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.queueCallback" id="apidoc.element.kafka-node.Client.prototype.queueCallback">
        function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.queueCallback
        <span class="apidocSignatureSpan">(socket, id, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client.prototype.queueCallback = function (socket, id, data) {
  var socketId = socket.socketId;
  var queue;

  if (this.cbqueue.hasOwnProperty(socketId)) {
    queue = this.cbqueue[socketId];
  } else {
    queue = {};
    this.cbqueue[socketId] = queue;
  }

  queue[id] = data;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.reconnectBroker" id="apidoc.element.kafka-node.Client.prototype.reconnectBroker">
        function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.reconnectBroker
        <span class="apidocSignatureSpan">(oldSocket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client.prototype.reconnectBroker = function (oldSocket) {
  oldSocket.retrying = false;
  if (oldSocket.error) {
    oldSocket.destroy();
  }
  var brokers = this.getBrokers(oldSocket.longpolling);
  var newBroker = this.setupBroker(oldSocket.host, oldSocket.port, oldSocket.longpolling, brokers);
  newBroker.socket.error = oldSocket.error;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.refreshBrokers" id="apidoc.element.kafka-node.Client.prototype.refreshBrokers">
        function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.refreshBrokers
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client.prototype.refreshBrokers = function () {
  var self = this;
  var validBrokers = Object.keys(this.brokerProfiles);

  function closeDeadBrokers (brokers) {
    var deadBrokerKeys = _.difference(Object.keys(brokers), validBrokers);
    if (deadBrokerKeys.length) {
      self.closeBrokers(deadBrokerKeys.map(function (key) {
        var broker = brokers[key];
        delete brokers[key];
        return broker;
      }));
    }
  }

  closeDeadBrokers(this.brokers);
  closeDeadBrokers(this.longpollingBrokers);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.refreshMetadata" id="apidoc.element.kafka-node.Client.prototype.refreshMetadata">
        function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.refreshMetadata
        <span class="apidocSignatureSpan">(topicNames, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client.prototype.refreshMetadata = function (topicNames, cb) {
  var self = this;
  if (!topicNames.length) return cb();
  attemptRequestMetadata(topicNames, cb);

  function attemptRequestMetadata (topics, cb) {
    var operation = retry.operation({ minTimeout: 200, maxTimeout: 1000 });
    operation.attempt(function (currentAttempt) {
      logger.debug('refresh metadata currentAttempt', currentAttempt);
      self.loadMetadataForTopics(topics, function (err, resp) {
        err = err || resp[1].error;
        if (operation.retry(err)) {
          return;
        }
        if (err) {
          logger.debug('refresh metadata error', err.message);
          return cb(err);
        }
        self.updateMetadatas(resp);
        cb();
      });
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.removeTopicMetadata" id="apidoc.element.kafka-node.Client.prototype.removeTopicMetadata">
        function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.removeTopicMetadata
        <span class="apidocSignatureSpan">(topics, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client.prototype.removeTopicMetadata = function (topics, cb) {
  topics.forEach(function (t) {
    if (this.topicMetadata[t]) delete this.topicMetadata[t];
  }.bind(this));
  cb(null, topics.length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.send" id="apidoc.element.kafka-node.Client.prototype.send">
        function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.send
        <span class="apidocSignatureSpan">(payloads, encoder, decoder, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client.prototype.send = function (payloads, encoder, decoder, cb) {
  var self = this;
  var _payloads = payloads;
  // payloads: [ [metadata exists], [metadata not exists] ]
  payloads = this.checkMetadatas(payloads);
  if (payloads[0].length &amp;&amp; !payloads[1].length) {
    this.sendToBroker(_.flatten(payloads), encoder, decoder, cb);
    return;
  }
  if (payloads[1].length) {
    var topicNames = payloads[1].map(function (p) { return p.topic; });
    this.loadMetadataForTopics(topicNames, function (err, resp) {
      if (err) {
        return cb(err);
      }

      var error = resp[1].error;
      if (error) {
        return cb(error);
      }

      self.updateMetadatas(resp);
      // check payloads again
      payloads = self.checkMetadatas(_payloads);
      if (payloads[1].length) {
        return cb(new errors.BrokerNotAvailableError('Could not find the leader'));
      }

      self.sendToBroker(payloads[1].concat(payloads[0]), encoder, decoder, cb);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendFetchRequest" id="apidoc.element.kafka-node.Client.prototype.sendFetchRequest">
        function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.sendFetchRequest
        <span class="apidocSignatureSpan">(consumer, payloads, fetchMaxWaitMs, fetchMinBytes, maxTickMessages)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client.prototype.sendFetchRequest = function (consumer, payloads, fetchMaxWaitMs, fetchMinBytes, maxTickMessages) {
  var self = this;
  var encoder = protocol.encodeFetchRequest(fetchMaxWaitMs, fetchMinBytes);
  var decoder = protocol.decodeFetchResponse(function (err, type, message) {
    if (err) {
      if (err.message === 'OffsetOutOfRange') {
        return consumer.emit('offsetOutOfRange', err);
      } else if (err.message === 'NotLeaderForPartition' || err.message === 'UnknownTopicOrPartition') {
        return self.emit('brokersChanged');
      }

      return consumer.emit('error', err);
    }

    var encoding = consumer.options.encoding;

    if (type === 'message') {
      if (encoding !== 'buffer' &amp;&amp; message.value) {
        message.value = message.value.toString(encoding);
      }

      consumer.emit('message', message);
    } else {
      consumer.emit('done', message);
    }
  }, maxTickMessages);

  this.send(payloads, encoder, decoder, function (err) {
    if (err) {
      Array.prototype.unshift.call(arguments, 'error');
      consumer.emit.apply(consumer, arguments);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendGroupCoordinatorRequest" id="apidoc.element.kafka-node.Client.prototype.sendGroupCoordinatorRequest">
        function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.sendGroupCoordinatorRequest
        <span class="apidocSignatureSpan">(groupId, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client.prototype.sendGroupCoordinatorRequest = function (groupId, cb) {
  this.sendGroupRequest(protocol.encodeGroupCoordinatorRequest, protocol.decodeGroupCoordinatorResponse, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendGroupRequest" id="apidoc.element.kafka-node.Client.prototype.sendGroupRequest">
        function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.sendGroupRequest
        <span class="apidocSignatureSpan">(encode, decode, requestArgs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client.prototype.sendGroupRequest = function (encode, decode, requestArgs) {
  requestArgs = _.values(requestArgs);
  var cb = requestArgs.pop();
  var correlationId = this.nextId();

  requestArgs.unshift(this.clientId, correlationId);

  var request = encode.apply(null, requestArgs);
  var broker = this.brokerForLeader(this.coordinatorId);

  if (!broker || !broker.socket || broker.socket.error || broker.socket.destroyed) {
    return cb(new errors.BrokerNotAvailableError('Broker not available'));
  }

  this.queueCallback(broker.socket, correlationId, [decode, cb]);
  broker.write(request);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendHeartbeatRequest" id="apidoc.element.kafka-node.Client.prototype.sendHeartbeatRequest">
        function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.sendHeartbeatRequest
        <span class="apidocSignatureSpan">(groupId, generationId, memberId, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client.prototype.sendHeartbeatRequest = function (groupId, generationId, memberId, cb) {
  this.sendGroupRequest(protocol.encodeGroupHeartbeat, protocol.decodeGroupHeartbeat, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendJoinGroupRequest" id="apidoc.element.kafka-node.Client.prototype.sendJoinGroupRequest">
        function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.sendJoinGroupRequest
        <span class="apidocSignatureSpan">(groupId, memberId, sessionTimeout, groupProtocol, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client.prototype.sendJoinGroupRequest = function (groupId, memberId, sessionTimeout, groupProtocol, cb) {
  this.sendGroupRequest(protocol.encodeJoinGroupRequest, protocol.decodeJoinGroupResponse, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendLeaveGroupRequest" id="apidoc.element.kafka-node.Client.prototype.sendLeaveGroupRequest">
        function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.sendLeaveGroupRequest
        <span class="apidocSignatureSpan">(groupId, memberId, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client.prototype.sendLeaveGroupRequest = function (groupId, memberId, cb) {
  this.sendGroupRequest(protocol.encodeLeaveGroupRequest, protocol.decodeLeaveGroupResponse, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendOffsetCommitRequest" id="apidoc.element.kafka-node.Client.prototype.sendOffsetCommitRequest">
        function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.sendOffsetCommitRequest
        <span class="apidocSignatureSpan">(group, payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client.prototype.sendOffsetCommitRequest = function (group, payloads, cb) {
  var encoder = protocol.encodeOffsetCommitRequest(group);
  var decoder = protocol.decodeOffsetCommitResponse;
  this.send(payloads, encoder, decoder, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendOffsetCommitV2Request" id="apidoc.element.kafka-node.Client.prototype.sendOffsetCommitV2Request">
        function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.sendOffsetCommitV2Request
        <span class="apidocSignatureSpan">(group, generationId, memberId, payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client.prototype.sendOffsetCommitV2Request = function (group, generationId, memberId, payloads, cb) {
  var encoder = protocol.encodeOffsetCommitV2Request;
  var decoder = protocol.decodeOffsetCommitResponse;
  this.sendGroupRequest(encoder, decoder, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendOffsetFetchRequest" id="apidoc.element.kafka-node.Client.prototype.sendOffsetFetchRequest">
        function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.sendOffsetFetchRequest
        <span class="apidocSignatureSpan">(group, payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client.prototype.sendOffsetFetchRequest = function (group, payloads, cb) {
  var encoder = protocol.encodeOffsetFetchRequest(group);
  var decoder = protocol.decodeOffsetFetchResponse;
  this.send(payloads, encoder, decoder, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendOffsetFetchV1Request" id="apidoc.element.kafka-node.Client.prototype.sendOffsetFetchV1Request">
        function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.sendOffsetFetchV1Request
        <span class="apidocSignatureSpan">(group, payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client.prototype.sendOffsetFetchV1Request = function (group, payloads, cb) {
  var encoder = protocol.encodeOffsetFetchV1Request;
  var decoder = protocol.decodeOffsetFetchV1Response;
  this.sendGroupRequest(encoder, decoder, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendOffsetRequest" id="apidoc.element.kafka-node.Client.prototype.sendOffsetRequest">
        function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.sendOffsetRequest
        <span class="apidocSignatureSpan">(payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client.prototype.sendOffsetRequest = function (payloads, cb) {
  var encoder = protocol.encodeOffsetRequest;
  var decoder = protocol.decodeOffsetResponse;
  this.send(payloads, encoder, decoder, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendProduceRequest" id="apidoc.element.kafka-node.Client.prototype.sendProduceRequest">
        function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.sendProduceRequest
        <span class="apidocSignatureSpan">(payloads, requireAcks, ackTimeoutMs, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client.prototype.sendProduceRequest = function (payloads, requireAcks, ackTimeoutMs, cb) {
  var encoder = protocol.encodeProduceRequest(requireAcks, ackTimeoutMs);
  var decoder = protocol.decodeProduceResponse;
  var self = this;

  decoder.requireAcks = requireAcks;

  async.each(payloads, buildRequest, function (err) {
    if (err) return cb(err);
    self.send(payloads, encoder, decoder, function (err, result) {
      if (err) {
        if (err.message === 'NotLeaderForPartition') {
          self.emit('brokersChanged');
        }
        cb(err);
      } else {
        cb(null, result);
      }
    });
  });

  function buildRequest (payload, cb) {
    var attributes = payload.attributes;
    var codec = getCodec(attributes);

    if (!codec) return cb();

    var innerSet = encodeMessageSet(payload.messages);
    codec.encode(innerSet, function (err, message) {
      if (err) return cb(err);
      payload.messages = [ new Message(0, attributes, '', message) ];
      cb();
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendSyncGroupRequest" id="apidoc.element.kafka-node.Client.prototype.sendSyncGroupRequest">
        function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.sendSyncGroupRequest
        <span class="apidocSignatureSpan">(groupId, generationId, memberId, groupAssignment, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client.prototype.sendSyncGroupRequest = function (groupId, generationId, memberId, groupAssignment, cb) {
  this.sendGroupRequest(protocol.encodeSyncGroupRequest, protocol.decodeSyncGroupResponse, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendToBroker" id="apidoc.element.kafka-node.Client.prototype.sendToBroker">
        function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.sendToBroker
        <span class="apidocSignatureSpan">(payloads, encoder, decoder, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client.prototype.sendToBroker = function (payloads, encoder, decoder, cb) {
  var longpolling = encoder.name === 'encodeFetchRequest';
  payloads = this.payloadsByLeader(payloads);
  if (!longpolling) {
    cb = wrap(payloads, cb);
  }
  for (var leader in payloads) {
    if (!payloads.hasOwnProperty(leader)) {
      continue;
    }
    var correlationId = this.nextId();
    var request = encoder(this.clientId, correlationId, payloads[leader]);
    var broker = this.brokerForLeader(leader, longpolling);
    if (!broker || !broker.socket || broker.socket.error || broker.socket.closing || broker.socket.destroyed) {
      return cb(new errors.BrokerNotAvailableError('Could not find the leader'), payloads[leader]);
    }

    if (longpolling) {
      if (broker.socket.waiting) continue;
      broker.socket.waiting = true;
    }

    if (decoder.requireAcks === 0) {
      broker.writeAsync(request);
      cb(null, { result: 'no ack' });
    } else {
      this.queueCallback(broker.socket, correlationId, [decoder, cb]);
      broker.write(request);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.setupBroker" id="apidoc.element.kafka-node.Client.prototype.setupBroker">
        function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.setupBroker
        <span class="apidocSignatureSpan">(host, port, longpolling, brokers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client.prototype.setupBroker = function (host, port, longpolling, brokers) {
  var brokerKey = host + ':' + port;
  brokers[brokerKey] = this.createBroker(host, port, longpolling);
  return brokers[brokerKey];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.setupBrokerProfiles" id="apidoc.element.kafka-node.Client.prototype.setupBrokerProfiles">
        function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.setupBrokerProfiles
        <span class="apidocSignatureSpan">(brokers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client.prototype.setupBrokerProfiles = function (brokers) {
  this.brokerProfiles = Object.create(null);
  var self = this;
  var protocol = self.ssl ? 'ssl:' : 'plaintext:';

  Object.keys(brokers).forEach(function (key) {
    var brokerProfile = brokers[key];
    var addr;

    if (brokerProfile.endpoints &amp;&amp; brokerProfile.endpoints.length) {
      var endpoint = _.find(brokerProfile.endpoints, function (endpoint) {
        return url.parse(endpoint).protocol === protocol;
      });

      if (endpoint == null) {
        throw new Error(['No kafka endpoint found for broker: ', key, ' with protocol ', protocol].join(''));
      }

      var endpointUrl = url.parse(endpoint);

      addr = endpointUrl.hostname + ':' + endpointUrl.port;

      brokerProfile.host = endpointUrl.hostname;
      brokerProfile.port = endpointUrl.port;
    } else {
      addr = brokerProfile.host + ':' + brokerProfile.port;
    }
    assert(brokerProfile.host &amp;&amp; brokerProfile.port, 'kafka host or port is empty');

    self.brokerProfiles[addr] = brokerProfile;
    self.brokerProfiles[addr].id = key;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.topicExists" id="apidoc.element.kafka-node.Client.prototype.topicExists">
        function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.topicExists
        <span class="apidocSignatureSpan">(topics, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client.prototype.topicExists = function (topics, cb) {
  var notExistsTopics = [];
  var self = this;

  async.each(topics, checkZK, function (err) {
    if (err) return cb(err);
    if (notExistsTopics.length) return cb(new errors.TopicsNotExistError(notExistsTopics));
    cb();
  });

  function checkZK (topic, cb) {
    self.zk.topicExists(topic, function (err, existed, topic) {
      if (err) return cb(err);
      if (!existed) notExistsTopics.push(topic);
      cb();
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.unqueueCallback" id="apidoc.element.kafka-node.Client.prototype.unqueueCallback">
        function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.unqueueCallback
        <span class="apidocSignatureSpan">(socket, id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client.prototype.unqueueCallback = function (socket, id) {
  var socketId = socket.socketId;

  if (!this.cbqueue.hasOwnProperty(socketId)) {
    return null;
  }

  var queue = this.cbqueue[socketId];
  if (!queue.hasOwnProperty(id)) {
    return null;
  }

  var result = queue[id];

  // cleanup socket queue
  delete queue[id];
  if (!Object.keys(queue).length) {
    delete this.cbqueue[socketId];
  }

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.updateMetadatas" id="apidoc.element.kafka-node.Client.prototype.updateMetadatas">
        function <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype.updateMetadatas
        <span class="apidocSignatureSpan">(metadatas)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client.prototype.updateMetadatas = function (metadatas) {
  // _.extend(this.brokerMetadata, metadatas[0])
  _.extend(this.topicMetadata, metadatas[1].metadata);
  for (var topic in this.topicMetadata) {
    if (!this.topicMetadata.hasOwnProperty(topic)) {
      continue;
    }
    this.topicPartitions[topic] = Object.keys(this.topicMetadata[topic]).map(function (val) {
      return parseInt(val, 10);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer" id="apidoc.element.kafka-node.Consumer">
        function <span class="apidocSignatureSpan">kafka-node.</span>Consumer
        <span class="apidocSignatureSpan">(client, topics, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Consumer = function (client, topics, options) {
  if (!topics) {
    throw new Error('Must have payloads');
  }

  utils.validateTopics(topics);

  this.fetchCount = 0;
  this.client = client;
  this.options = _.defaults((options || {}), DEFAULTS);
  this.ready = false;
  this.paused = this.options.paused;
  this.id = nextId();
  this.payloads = this.buildPayloads(topics);
  this.connect();
  this.encoding = this.options.encoding;

  if (this.options.groupId) {
    utils.validateConfig('options.groupId', this.options.groupId);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.addTopics" id="apidoc.element.kafka-node.Consumer.prototype.addTopics">
        function <span class="apidocSignatureSpan">kafka-node.</span>Consumer.prototype.addTopics
        <span class="apidocSignatureSpan">(topics, cb, fromOffset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Consumer.prototype.addTopics = function (topics, cb, fromOffset) {
  fromOffset = !!fromOffset;
  var self = this;
  if (!this.ready) {
    setTimeout(function () {
      self.addTopics(topics, cb, fromOffset);
    }
    , 100);
    return;
  }

  // The default is that the topics is a string array of topic names
  var topicNames = topics;

  // If the topics is actually an object and not string we assume it is an array of payloads
  if (typeof topics[0] === 'object') {
    topicNames = topics.map(function (p) { return p.topic; });
  }

  this.client.addTopics(
    topicNames,
    function (err, added) {
      if (err) return cb &amp;&amp; cb(err, added);

      var payloads = self.buildPayloads(topics);
      var reFetch = !self.payloads.length;

      if (fromOffset) {
        payloads.forEach(function (p) {
          self.payloads.push(p);
        });
        if (reFetch) self.fetch();
        cb &amp;&amp; cb(null, added);
        return;
      }

      // update offset of topics that will be added
      self.fetchOffset(payloads, function (err, offsets) {
        if (err) return cb(err);
        payloads.forEach(function (p) {
          var offset = offsets[p.topic][p.partition];
          if (offset === -1) offset = 0;
          p.offset = offset;
          self.payloads.push(p);
        });
        if (reFetch) self.fetch();
        cb &amp;&amp; cb(null, added);
      });
    }
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.autoCommit" id="apidoc.element.kafka-node.Consumer.prototype.autoCommit">
        function <span class="apidocSignatureSpan">kafka-node.</span>Consumer.prototype.autoCommit
        <span class="apidocSignatureSpan">(force, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function autoCommit(force, cb) {
  if (arguments.length === 1) {
    cb = force;
    force = false;
  }

  if (this.committing &amp;&amp; !force) return cb(null, 'Offset committing');

  this.committing = true;
  setTimeout(function () {
    this.committing = false;
  }.bind(this), this.options.autoCommitIntervalMs);

  var payloads = this.payloads;
  if (this.pausedPayloads) payloads = payloads.concat(this.pausedPayloads);

  var commits = payloads.filter(function (p) { return p.offset !== 0; });
  if (commits.length) {
    this.client.sendOffsetCommitRequest(this.options.groupId, commits, cb);
  } else {
    cb(null, 'Nothing to be committed');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.buildPayloads" id="apidoc.element.kafka-node.Consumer.prototype.buildPayloads">
        function <span class="apidocSignatureSpan">kafka-node.</span>Consumer.prototype.buildPayloads
        <span class="apidocSignatureSpan">(payloads)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Consumer.prototype.buildPayloads = function (payloads) {
  var self = this;
  return payloads.map(function (p) {
    if (typeof p !== 'object') p = { topic: p };
    p.partition = p.partition || 0;
    p.offset = p.offset || 0;
    p.maxBytes = self.options.fetchMaxBytes;
    p.metadata = 'm'; // metadata can be arbitrary
    return p;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.close" id="apidoc.element.kafka-node.Consumer.prototype.close">
        function <span class="apidocSignatureSpan">kafka-node.</span>Consumer.prototype.close
        <span class="apidocSignatureSpan">(force, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Consumer.prototype.close = function (force, cb) {
  this.ready = false;
  if (typeof force === 'function') {
    cb = force;
    force = false;
  }

  if (force) {
    this.commit(force, function (err) {
      if (err) {
        return cb(err);
      }
      this.client.close(cb);
    }.bind(this));
  } else {
    this.client.close(cb);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.connect" id="apidoc.element.kafka-node.Consumer.prototype.connect">
        function <span class="apidocSignatureSpan">kafka-node.</span>Consumer.prototype.connect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Consumer.prototype.connect = function () {
  var self = this;
  // Client already exists
  this.ready = this.client.ready;
  if (this.ready) this.init();

  this.client.on('ready', function () {
    logger.debug('consumer ready');
    if (!self.ready) self.init();
    self.ready = true;
  });

  this.client.on('error', function (err) {
    logger.error('client error %s', err.message);
    self.emit('error', err);
  });

  this.client.on('close', function () {
    logger.debug('connection closed');
  });

  this.client.on('brokersChanged', function () {
    var topicNames = self.payloads.map(function (p) {
      return p.topic;
    });

    this.refreshMetadata(topicNames, function (err) {
      if (err) return self.emit('error', err);
      self.fetch();
    });
  });
  // 'done' will be emit when a message fetch request complete
  this.on('done', function (topics) {
    self.updateOffsets(topics);
    setImmediate(function () {
      self.fetch();
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.fetch" id="apidoc.element.kafka-node.Consumer.prototype.fetch">
        function <span class="apidocSignatureSpan">kafka-node.</span>Consumer.prototype.fetch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Consumer.prototype.fetch = function () {
  if (!this.ready || this.paused) return;
  this.client.sendFetchRequest(this, this.payloads, this.options.fetchMaxWaitMs, this.options.fetchMinBytes);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.fetchOffset" id="apidoc.element.kafka-node.Consumer.prototype.fetchOffset">
        function <span class="apidocSignatureSpan">kafka-node.</span>Consumer.prototype.fetchOffset
        <span class="apidocSignatureSpan">(payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Consumer.prototype.fetchOffset = function (payloads, cb) {
  this.client.sendOffsetFetchRequest(this.options.groupId, payloads, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.init" id="apidoc.element.kafka-node.Consumer.prototype.init">
        function <span class="apidocSignatureSpan">kafka-node.</span>Consumer.prototype.init
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Consumer.prototype.init = function () {
  if (!this.payloads.length) {
    return;
  }

  var self = this;
  var topics = self.payloads.map(function (p) { return p.topic; });

  self.client.topicExists(topics, function (err) {
    if (err) {
      return self.emit('error', err);
    }

    if (self.options.fromOffset) {
      return self.fetch();
    }

    self.fetchOffset(self.payloads, function (err, topics) {
      if (err) {
        return self.emit('error', err);
      }

      self.updateOffsets(topics, true);
      self.fetch();
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.pause" id="apidoc.element.kafka-node.Consumer.prototype.pause">
        function <span class="apidocSignatureSpan">kafka-node.</span>Consumer.prototype.pause
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Consumer.prototype.pause = function () {
  this.paused = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.pauseTopics" id="apidoc.element.kafka-node.Consumer.prototype.pauseTopics">
        function <span class="apidocSignatureSpan">kafka-node.</span>Consumer.prototype.pauseTopics
        <span class="apidocSignatureSpan">(topics)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Consumer.prototype.pauseTopics = function (topics) {
  if (!this.pausedPayloads) this.pausedPayloads = [];
  pauseOrResume(this.payloads, this.pausedPayloads, topics);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.removeTopics" id="apidoc.element.kafka-node.Consumer.prototype.removeTopics">
        function <span class="apidocSignatureSpan">kafka-node.</span>Consumer.prototype.removeTopics
        <span class="apidocSignatureSpan">(topics, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Consumer.prototype.removeTopics = function (topics, cb) {
  topics = typeof topics === 'string' ? [topics] : topics;
  this.payloads = this.payloads.filter(function (p) {
    return !~topics.indexOf(p.topic);
  });

  this.client.removeTopicMetadata(topics, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.resume" id="apidoc.element.kafka-node.Consumer.prototype.resume">
        function <span class="apidocSignatureSpan">kafka-node.</span>Consumer.prototype.resume
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Consumer.prototype.resume = function () {
  this.paused = false;
  this.fetch();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.resumeTopics" id="apidoc.element.kafka-node.Consumer.prototype.resumeTopics">
        function <span class="apidocSignatureSpan">kafka-node.</span>Consumer.prototype.resumeTopics
        <span class="apidocSignatureSpan">(topics)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Consumer.prototype.resumeTopics = function (topics) {
  if (!this.pausedPayloads) this.pausedPayloads = [];
  var reFetch = !this.payloads.length;
  pauseOrResume(this.pausedPayloads, this.payloads, topics);
  reFetch = reFetch &amp;&amp; this.payloads.length;
  if (reFetch) this.fetch();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.setOffset" id="apidoc.element.kafka-node.Consumer.prototype.setOffset">
        function <span class="apidocSignatureSpan">kafka-node.</span>Consumer.prototype.setOffset
        <span class="apidocSignatureSpan">(topic, partition, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Consumer.prototype.setOffset = function (topic, partition, offset) {
  this.payloads.every(function (p) {
    if (p.topic === topic &amp;&amp; p.partition == partition) { // eslint-disable-line eqeqeq
      p.offset = offset;
      return false;
    }
    return true;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.updateOffsets" id="apidoc.element.kafka-node.Consumer.prototype.updateOffsets">
        function <span class="apidocSignatureSpan">kafka-node.</span>Consumer.prototype.updateOffsets
        <span class="apidocSignatureSpan">(topics, initing)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Consumer.prototype.updateOffsets = function (topics, initing) {
  this.payloads.forEach(function (p) {
    if (!_.isEmpty(topics[p.topic]) &amp;&amp; topics[p.topic][p.partition] !== undefined) {
      var offset = topics[p.topic][p.partition];
      if (offset === -1) offset = 0;
      if (!initing) p.offset = offset + 1;
      else p.offset = offset;
    }
  });

  if (this.options.autoCommit &amp;&amp; !initing) {
    this.autoCommit(false, function (err) {
      err &amp;&amp; logger.debug('auto commit offset', err);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup" id="apidoc.element.kafka-node.ConsumerGroup">
        function <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup
        <span class="apidocSignatureSpan">(memberOptions, topics)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ConsumerGroup(memberOptions, topics) {
  EventEmitter.call(this);
  const self = this;
  this.options = _.defaults((memberOptions || {}), DEFAULTS);

  if (!this.options.heartbeatInterval) {
    this.options.heartbeatInterval = Math.floor(this.options.sessionTimeout / 3);
  }

  if (memberOptions.ssl === true) {
    memberOptions.ssl = {};
  }

  if (!(this.options.fromOffset in ACCEPTED_FROM_OFFSET)) {
    throw new Error(`fromOffset ${this.options.fromOffset} should be either: ${Object.keys(ACCEPTED_FROM_OFFSET).join(', ')}`);
  }

  if (!(this.options.outOfRangeOffset in ACCEPTED_FROM_OFFSET)) {
    throw new Error(`outOfRangeOffset ${this.options.outOfRangeOffset} should be either: ${Object.keys(ACCEPTED_FROM_OFFSET).join
(', ')}`);
  }

  this.client = new Client(memberOptions.host, memberOptions.id, memberOptions.zk,
    memberOptions.batch, memberOptions.ssl);

  if (_.isString(topics)) {
    topics = [topics];
  }

  assert(Array.isArray(topics), 'Array of topics is required');

  this.topics = topics;

  this.recovery = new ConsumerGroupRecovery(this);

  this.setupProtocols(this.options.protocol);

  if (this.options.connectOnReady &amp;&amp; !this.options.migrateHLC) {
    this.client.once('ready', this.connect.bind(this));
  }

  if (this.options.migrateHLC) {
    const ConsumerGroupMigrator = require('./consumerGroupMigrator');
    this.migrator = new ConsumerGroupMigrator(this);
    this.migrator.on('error', function (error) {
      self.emit('error', error);
    });
  }

  this.client.on('error', function (err) {
    logger.error('Error from %s', self.client.clientId, err);
    self.emit('error', err);
  });

  const recoverFromBrokerChange = _.debounce(function () {
    logger.debug('brokersChanged refreshing metadata');
    self.client.refreshMetadata(self.topics, function (error) {
      if (error) {
        self.emit(error);
        return;
      }
      self.paused = false;
      if (!self.ready &amp;&amp; !self.connecting) {
        if (self.reconnectTimer) {
          // brokers changed so bypass backoff retry and reconnect now
          clearTimeout(self.reconnectTimer);
          self.reconnectTimer = null;
        }
        self.connect();
      } else if (!self.connecting) {
        self.fetch();
      }
    });
  }, 200);

  this.client.on('brokersChanged', function () {
    self.pause();
    recoverFromBrokerChange();
  });

  this.client.on('reconnect', function (lastError) {
    self.fetch();
  });

  this.on('offsetOutOfRange', topic =&gt; {
    this.pause();
    if (this.options.outOfRangeOffset === 'none') {
      this.emit('error', new errors.InvalidConsumerOffsetError(`Offset out of range for topic "${topic.topic}" partition ${topic
.partition}`));
      return;
    }

    topic.time = ACCEPTED_FROM_OFFSET[this.options.outOfRangeOffset];

    this.getOffset().fetch([topic], (error, result) =&gt; {
      if (error) {
        this.emit('error', new errors.InvalidConsumerOffsetError(`Fetching ${this.options.outOfRangeOffset} offset failed`, error
));
        return;
      }
      const offset = _.head(result[topic.topic][topic.partition]);
      const oldOffset = _.find(this.topicPayloads, {topic: topic.topic, partition: topic.partition}).offset;

      logger.debug('replacing %s-%s stale offset of %d with %d', topic.topic, topic.partition, oldOffset, offset);

      this.setOffset(topic.topic, topic.partition, offset);
      this.resume();
    });
  });

  // 'done' will be emit when a message fetch request complete
  this.on('done', function (topics) {
    self.updateOffsets(topics);
    if (!self.paused) {
      setImmediate(function () {
        self.fetch();
      });
    }
  });

  if (this.options.groupId) {
    validateConfig('options.groupId', this.options.groupId);
  }

  this.isLeader = false;
  this.coordinatorId = null;
  this.generationId = null;
  this.ready = false;
  this.topicPayloads = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.assignPartitions" id="apidoc.element.kafka-node.ConsumerGroup.prototype.assignPartitions">
        function <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup.prototype.assignPartitions
        <span class="apidocSignatureSpan">(protocol, groupMembers, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ConsumerGroup.prototype.assignPartitions = function (protocol, groupMembers, callback) {
  logger.debug('Assigning Partitions to members', groupMembers);
  logger.debug('Using group protocol', protocol);

  protocol = _.find(this.protocols, {name: protocol});

  var self = this;
  var topics = _(groupMembers).map('subscription').flatten().uniq().value();

  async.waterfall([
    function (callback) {
      logger.debug('loadingMetadata for topics:', topics);
      self.client.loadMetadataForTopics(topics, callback);
    },

    function (metadataResponse, callback) {
      var metadata = mapTopicToPartitions(metadataResponse[1].metadata);
      logger.debug('mapTopicToPartitions', metadata);
      protocol.assign(metadata, groupMembers, callback);
    }
  ], callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.close" id="apidoc.element.kafka-node.ConsumerGroup.prototype.close">
        function <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup.prototype.close
        <span class="apidocSignatureSpan">(force, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ConsumerGroup.prototype.close = function (force, cb) {
  var self = this;
  this.ready = false;

  this.stopHeartbeats();

  if (typeof force === 'function') {
    cb = force;
    force = false;
  }

  async.series([
    function (callback) {
      if (force) {
        self.commit(true, callback);
        return;
      }
      callback(null);
    },
    function (callback) {
      self.leaveGroup(function (error) {
        if (error) {
          logger.error('Leave group failed with', error);
        }
        callback(null);
      });
    },
    function (callback) {
      self.client.close(callback);
    }
  ], cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.connect" id="apidoc.element.kafka-node.ConsumerGroup.prototype.connect">
        function <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup.prototype.connect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ConsumerGroup.prototype.connect = function () {
  if (this.connecting) {
    logger.warn('Connect ignored. Currently connecting.');
    return;
  }

  logger.debug('Connecting %s', this.client.clientId);
  var self = this;

  this.connecting = true;
  this.emit('rebalancing');

  async.waterfall([
    function (callback) {
      if (self.client.coordinatorId) {
        return callback(null, null);
      }
      self.client.sendGroupCoordinatorRequest(self.options.groupId, callback);
    },

    function (coordinatorInfo, callback) {
      logger.debug('GroupCoordinator Response:', coordinatorInfo);
      if (coordinatorInfo) {
        self.setCoordinatorId(coordinatorInfo.coordinatorId);
      }
      self.client.sendJoinGroupRequest(self.options.groupId, emptyStrIfNull(self.memberId), self.options.sessionTimeout, self.protocols
, callback);
    },

    function (joinGroupResponse, callback) {
      self.handleJoinGroup(joinGroupResponse, callback);
    },

    function (groupAssignment, callback) {
      logger.debug('SyncGroup Request from %s', self.memberId);
      self.client.sendSyncGroupRequest(self.options.groupId, self.generationId, self.memberId, groupAssignment, callback);
    },

    function (syncGroupResponse, callback) {
      self.handleSyncGroup(syncGroupResponse, callback);
    }
  ], function (error, startFetch) {
    self.connecting = false;
    self.rebalancing = false;
    if (error) {
      return self.recovery.tryToRecoverFrom(error, 'connect');
    }

    self.ready = true;
    self.recovery.clearError();

    logger.debug('generationId', self.generationId);

    if (startFetch) {
      self.fetch();
    }
    self.startHeartbeats();
    self.emit('connect');
    self.emit('rebalanced');
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.fetchOffset" id="apidoc.element.kafka-node.ConsumerGroup.prototype.fetchOffset">
        function <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup.prototype.fetchOffset
        <span class="apidocSignatureSpan">(payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ConsumerGroup.prototype.fetchOffset = function (payloads, cb) {
  this.client.sendOffsetFetchV1Request(this.options.groupId, payloads, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.getDefaultOffset" id="apidoc.element.kafka-node.ConsumerGroup.prototype.getDefaultOffset">
        function <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup.prototype.getDefaultOffset
        <span class="apidocSignatureSpan">(tp, defaultOffset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ConsumerGroup.prototype.getDefaultOffset = function (tp, defaultOffset) {
  return _.get(this.defaultOffsets, [tp.topic, tp.partition], defaultOffset);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.getOffset" id="apidoc.element.kafka-node.ConsumerGroup.prototype.getOffset">
        function <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup.prototype.getOffset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ConsumerGroup.prototype.getOffset = function () {
  if (this.offset) {
    return this.offset;
  }
  this.offset = new Offset(this.client);
  // we can ignore this since we are already forwarding error event emitted from client
  this.offset.on('error', _.noop);
  return this.offset;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.handleJoinGroup" id="apidoc.element.kafka-node.ConsumerGroup.prototype.handleJoinGroup">
        function <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup.prototype.handleJoinGroup
        <span class="apidocSignatureSpan">(joinGroupResponse, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ConsumerGroup.prototype.handleJoinGroup = function (joinGroupResponse, callback) {
  logger.debug('joinGroupResponse %j from %s', joinGroupResponse, this.client.clientId);

  this.isLeader = (joinGroupResponse.leaderId === joinGroupResponse.memberId);
  this.generationId = joinGroupResponse.generationId;
  this.memberId = joinGroupResponse.memberId;

  var groupAssignment;
  if (this.isLeader) {
    // assign partitions
    return this.assignPartitions(joinGroupResponse.groupProtocol, joinGroupResponse.members, callback);
  }
  callback(null, groupAssignment);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.handleSyncGroup" id="apidoc.element.kafka-node.ConsumerGroup.prototype.handleSyncGroup">
        function <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup.prototype.handleSyncGroup
        <span class="apidocSignatureSpan">(syncGroupResponse, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ConsumerGroup.prototype.handleSyncGroup = function (syncGroupResponse, callback) {
  logger.debug('SyncGroup Response');
  var self = this;
  var ownedTopics = Object.keys(syncGroupResponse.partitions);
  if (ownedTopics.length) {
    logger.debug('%s owns topics: ', self.client.clientId, syncGroupResponse.partitions);

    const topicPartitionList = createTopicPartitionList(syncGroupResponse.partitions);
    const useDefaultOffsets = self.options.fromOffset in ACCEPTED_FROM_OFFSET;

    async.waterfall([
      function (callback) {
        self.fetchOffset(syncGroupResponse.partitions, callback);
      },
      function (offsets, callback) {
        logger.debug('%s fetchOffset Response: %j', self.client.clientId, offsets);

        var noOffset = topicPartitionList.some(function (tp) {
          return offsets[tp.topic][tp.partition] === -1;
        });

        if (noOffset) {
          logger.debug('No saved offsets');

          if (self.options.fromOffset === 'none') {
            return callback(new Error(`${self.client.clientId} owns topics and partitions which contains no saved offsets for group
 '${self.options.groupId}'`));
          }

          async.parallel([
            function (callback) {
              if (self.migrator) {
                return self.migrator.saveHighLevelConsumerOffsets(topicPartitionList, callback);
              }
              callback(null);
            },
            function (callback) {
              if (useDefaultOffsets) {
                return self.saveDefaultOffsets(topicPartitionList, callback);
              }
              callback(null);
            }
          ], function (error) {
            if (error) {
              return callback(error);
            }
            logger.debug('%s defaultOffset Response for %s: %j', self.client.clientId, self.options.fromOffset, self.defaultOffsets
);
            callback(null, offsets);
          });
        } else {
          logger.debug('Has saved offsets');
          callback(null, offsets);
        }
      },
      function (offsets, callback) {
        self.topicPayloads = self.buildPayloads(topicPartitionList).map(function (p) {
          var offset = offsets[p.topic][p.partition];
          if (offset === -1) { // -1 means no offset was saved for this topic/partition combo
            offset = useDefaultOffsets ? self.getDefaultOffset(p, 0) : 0;
            if (self.migrator) {
              offset = self.migrator.getOffset(p, offset);
            }
          }
          p.offset = offset;
          return p;
        });
        callback(null, true);
      }
    ], callback);
  } else { // no partitions assigned
    callback(null, false);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.leaveGroup" id="apidoc.element.kafka-node.ConsumerGroup.prototype.leaveGroup">
        function <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup.prototype.leaveGroup
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ConsumerGroup.prototype.leaveGroup = function (callback) {
  logger.debug('%s leaving group', this.client.clientId);
  var self = this;
  this.stopHeartbeats();
  if (self.generationId != null &amp;&amp; self.memberId) {
    this.client.sendLeaveGroupRequest(this.options.groupId, this.memberId, function (error) {
      self.generationId = null;
      callback(error);
    });
  } else {
    callback(null);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.saveDefaultOffsets" id="apidoc.element.kafka-node.ConsumerGroup.prototype.saveDefaultOffsets">
        function <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup.prototype.saveDefaultOffsets
        <span class="apidocSignatureSpan">(topicPartitionList, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ConsumerGroup.prototype.saveDefaultOffsets = function (topicPartitionList, callback) {
  var self = this;
  const offsetPayload = _(topicPartitionList).cloneDeep().map(tp =&gt; {
    tp.time = ACCEPTED_FROM_OFFSET[this.options.fromOffset];
    return tp;
  });

  self.getOffset().fetch(offsetPayload, function (error, result) {
    if (error) {
      return callback(error);
    }
    self.defaultOffsets = _.mapValues(result, function (partitionOffsets) {
      return _.mapValues(partitionOffsets, _.head);
    });
    callback(null);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.scheduleReconnect" id="apidoc.element.kafka-node.ConsumerGroup.prototype.scheduleReconnect">
        function <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup.prototype.scheduleReconnect
        <span class="apidocSignatureSpan">(timeout)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ConsumerGroup.prototype.scheduleReconnect = function (timeout) {
  assert(timeout);
  this.rebalancing = true;

  if (this.reconnectTimer) {
    clearTimeout(this.reconnectTimer);
  }

  var self = this;
  this.reconnectTimer = setTimeout(function () {
    self.reconnectTimer = null;
    self.connect();
  }, timeout);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.sendHeartbeat" id="apidoc.element.kafka-node.ConsumerGroup.prototype.sendHeartbeat">
        function <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup.prototype.sendHeartbeat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ConsumerGroup.prototype.sendHeartbeat = function () {
  assert(this.memberId, 'invalid memberId');
  assert(this.generationId &gt;= 0, 'invalid generationId');
  // logger.debug('%s â¤ï¸  -&gt;', this.client.clientId);
  var self = this;

  function heartbeatCallback (error) {
    if (error) {
      logger.warn('%s Heartbeat error:', self.client.clientId, error);
      self.recovery.tryToRecoverFrom(error, 'heartbeat');
    }
    // logger.debug('%s ðŸ’š &lt;-', self.client.clientId, error);
  }

  const heartbeat = new Heartbeat(this.client, heartbeatCallback);
  heartbeat.send(this.options.groupId, this.generationId, this.memberId);

  return heartbeat;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.sendOffsetCommitRequest" id="apidoc.element.kafka-node.ConsumerGroup.prototype.sendOffsetCommitRequest">
        function <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup.prototype.sendOffsetCommitRequest
        <span class="apidocSignatureSpan">(commits, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ConsumerGroup.prototype.sendOffsetCommitRequest = function (commits, cb) {
  if (this.generationId &amp;&amp; this.memberId) {
    this.client.sendOffsetCommitV2Request(this.options.groupId, this.generationId, this.memberId, commits, cb);
  } else {
    cb(null, 'Nothing to be committed');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.setCoordinatorId" id="apidoc.element.kafka-node.ConsumerGroup.prototype.setCoordinatorId">
        function <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup.prototype.setCoordinatorId
        <span class="apidocSignatureSpan">(coordinatorId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ConsumerGroup.prototype.setCoordinatorId = function (coordinatorId) {
  this.client.coordinatorId = String(coordinatorId);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.setupProtocols" id="apidoc.element.kafka-node.ConsumerGroup.prototype.setupProtocols">
        function <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup.prototype.setupProtocols
        <span class="apidocSignatureSpan">(protocols)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ConsumerGroup.prototype.setupProtocols = function (protocols) {
  if (!Array.isArray(protocols)) {
    protocols = [protocols];
  }

  this.protocols = protocols.map(function (protocol) {
    if (typeof protocol === 'string') {
      if (!(protocol in builtInProtocols)) {
        throw new Error('Unknown built in assignment protocol ' + protocol);
      }
      protocol = _.assign({}, builtInProtocols[protocol]);
    } else {
      checkProtocol(protocol);
    }

    protocol.subscription = this.topics;
    return protocol;
  }, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.startHeartbeats" id="apidoc.element.kafka-node.ConsumerGroup.prototype.startHeartbeats">
        function <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup.prototype.startHeartbeats
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ConsumerGroup.prototype.startHeartbeats = function () {
  assert(this.options.sessionTimeout &gt; 0);
  assert(this.ready, 'consumerGroup is not ready');

  const heartbeatIntervalMs = this.options.heartbeatInterval || (Math.floor(this.options.sessionTimeout / 3));

  logger.debug('%s started heartbeats at every %d ms', this.client.clientId, heartbeatIntervalMs);
  this.stopHeartbeats();

  let heartbeat = this.sendHeartbeat();

  this.heartbeatInterval = setInterval(() =&gt; {
    // only send another heartbeat if we got a response from the last one
    if (heartbeat.verifyResolved()) {
      heartbeat = this.sendHeartbeat();
    }
  }, heartbeatIntervalMs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.stopHeartbeats" id="apidoc.element.kafka-node.ConsumerGroup.prototype.stopHeartbeats">
        function <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup.prototype.stopHeartbeats
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ConsumerGroup.prototype.stopHeartbeats = function () {
  this.heartbeatInterval &amp;&amp; clearInterval(this.heartbeatInterval);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.CustomPartitioner" id="apidoc.element.kafka-node.CustomPartitioner">
        function <span class="apidocSignatureSpan">kafka-node.</span>CustomPartitioner
        <span class="apidocSignatureSpan">(partitioner)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CustomPartitioner = function (partitioner) {
  this.getPartition = partitioner;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.CustomPartitioner.super_" id="apidoc.element.kafka-node.CustomPartitioner.super_">
        function <span class="apidocSignatureSpan">kafka-node.</span>CustomPartitioner.super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CustomPartitioner.super_ = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.CyclicPartitioner" id="apidoc.element.kafka-node.CyclicPartitioner">
        function <span class="apidocSignatureSpan">kafka-node.</span>CyclicPartitioner
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CyclicPartitioner = function () {
  this.c = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.CyclicPartitioner.prototype.getPartition" id="apidoc.element.kafka-node.CyclicPartitioner.prototype.getPartition">
        function <span class="apidocSignatureSpan">kafka-node.</span>CyclicPartitioner.prototype.getPartition
        <span class="apidocSignatureSpan">(partitions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CyclicPartitioner.prototype.getPartition = function (partitions) {
  if (_.isEmpty(partitions)) return 0;
  return partitions[ this.c++ % partitions.length ];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.DefaultPartitioner" id="apidoc.element.kafka-node.DefaultPartitioner">
        function <span class="apidocSignatureSpan">kafka-node.</span>DefaultPartitioner
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">DefaultPartitioner = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.DefaultPartitioner.prototype.getPartition" id="apidoc.element.kafka-node.DefaultPartitioner.prototype.getPartition">
        function <span class="apidocSignatureSpan">kafka-node.</span>DefaultPartitioner.prototype.getPartition
        <span class="apidocSignatureSpan">(partitions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">DefaultPartitioner.prototype.getPartition = function (partitions) {
  if (partitions &amp;&amp; _.isArray(partitions) &amp;&amp; partitions.length &gt; 0) {
    return partitions[0];
  } else {
    return 0;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer" id="apidoc.element.kafka-node.HighLevelConsumer">
        function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer
        <span class="apidocSignatureSpan">(client, topics, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">HighLevelConsumer = function (client, topics, options) {
  if (!topics) {
    throw new Error('Must have payloads');
  }
  this.fetchCount = 0;
  this.client = client;
  this.options = _.defaults((options || {}), DEFAULTS);
  this.initialised = false;
  this.ready = false;
  this.closing = false;
  this.paused = this.options.paused;
  this.rebalancing = false;
  this.pendingRebalances = 0;
  this.committing = false;
  this.needToCommit = false;
  this.id = this.options.id || this.options.groupId + '_' + uuid.v4();
  this.payloads = this.buildPayloads(topics);
  this.topicPayloads = this.buildTopicPayloads(topics);
  this.connect();

  if (this.options.groupId) {
    validateConfig('options.groupId', this.options.groupId);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype._releasePartitions" id="apidoc.element.kafka-node.HighLevelConsumer.prototype._releasePartitions">
        function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer.prototype._releasePartitions
        <span class="apidocSignatureSpan">(topicPayloads, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">HighLevelConsumer.prototype._releasePartitions = function (topicPayloads, callback) {
  var self = this;
  async.each(topicPayloads, function (tp, cbb) {
    if (tp.partition !== undefined) {
      async.series([
        function (delcbb) {
          self.client.zk.checkPartitionOwnership(self.id, self.options.groupId, tp.topic, tp.partition, function (err) {
            if (err) {
              // Partition doesn't exist simply carry on
              cbb();
            } else delcbb();
          });
        },
        function (delcbb) {
          self.client.zk.deletePartitionOwnership(self.options.groupId, tp.topic, tp.partition, delcbb);
        },
        function (delcbb) {
          self.client.zk.checkPartitionOwnership(self.id, self.options.groupId, tp.topic, tp.partition, function (err) {
            if (err) {
              delcbb();
            } else {
              delcbb('Partition should not exist');
            }
          });
        }],
      cbb);
    } else {
      cbb();
    }
  }, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.addTopics" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.addTopics">
        function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer.prototype.addTopics
        <span class="apidocSignatureSpan">(topics, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">HighLevelConsumer.prototype.addTopics = function (topics, cb) {
  var self = this;
  if (!this.ready) {
    setTimeout(function () {
      self.addTopics(topics, cb);
    }, 100);
    return;
  }
  this.client.addTopics(
    topics,
    function (err, added) {
      if (err) return cb &amp;&amp; cb(err, added);

      var payloads = self.buildPayloads(topics);
      // update offset of topics that will be added
      self.fetchOffset(payloads, function (err, offsets) {
        if (err) return cb(err);
        payloads.forEach(function (p) {
          var offset = offsets[p.topic][p.partition];
          if (offset === -1) offset = 0;
          p.offset = offset;
          self.topicPayloads.push(p);
        });
        // TODO: rebalance consumer
        cb &amp;&amp; cb(null, added);
      });
    }
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.autoCommit" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.autoCommit">
        function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer.prototype.autoCommit
        <span class="apidocSignatureSpan">(force, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function autoCommit(force, cb) {
  if (arguments.length === 1) {
    cb = force;
    force = false;
  }

  if (!force) {
    if (this.committing) return cb(null, 'Offset committing');
    if (!this.needToCommit) return cb(null, 'Commit not needed');
  }

  this.needToCommit = false;
  this.committing = true;
  setTimeout(function () {
    this.committing = false;
  }.bind(this), this.options.autoCommitIntervalMs);

  var commits = this.topicPayloads.filter(function (p) { return p.offset !== -1; });

  if (commits.length) {
    this.sendOffsetCommitRequest(commits, cb);
  } else {
    cb(null, 'Nothing to be committed');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.buildPayloads" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.buildPayloads">
        function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer.prototype.buildPayloads
        <span class="apidocSignatureSpan">(payloads)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">HighLevelConsumer.prototype.buildPayloads = function (payloads) {
  var self = this;
  return payloads.map(function (p) {
    if (typeof p !== 'object') p = { topic: p };
    p.partition = p.partition || 0;
    p.offset = p.offset || 0;
    p.maxBytes = self.options.fetchMaxBytes;
    p.metadata = 'm'; // metadata can be arbitrary
    return p;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.buildTopicPayloads" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.buildTopicPayloads">
        function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer.prototype.buildTopicPayloads
        <span class="apidocSignatureSpan">(topics)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">HighLevelConsumer.prototype.buildTopicPayloads = function (topics) {
  return topics.map(function (j) {
    var k = { topic: j.topic };
    return k;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.close" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.close">
        function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer.prototype.close
        <span class="apidocSignatureSpan">(force, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">HighLevelConsumer.prototype.close = function (force, cb) {
  var self = this;
  this.ready = false;
  this.closing = true;
  clearInterval(this.checkPartitionOwnershipInterval);

  if (typeof force === 'function') {
    cb = force;
    force = false;
  }

  async.series([
    function (callback) {
      self.leaveGroup(callback);
    },
    function (callback) {
      if (force) {
        async.series([
          function (callback) {
            self.commit(true, callback);
          },
          function (callback) {
            self.client.close(callback);
          }
        ], callback);
        return;
      }
      self.client.close(callback);
    }
  ], cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.connect" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.connect">
        function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer.prototype.connect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">HighLevelConsumer.prototype.connect = function () {
  var self = this;
  // Client alreadyexists
  if (this.client.ready) {
    this.init();
  }

  this.client.on('ready', function () {
    if (!self.initialised) self.init();

    // Check the topics exist and create a watcher on them
    var topics = self.payloads.map(function (p) {
      return p.topic;
    });

    self.client.topicExists(topics, function (err) {
      if (err) {
        return self.emit('error', err);
      }
      self.initialised = true;
    });
  });

  function checkPartitionOwnership (callback) {
    async.each(self.topicPayloads, function (tp, cbb) {
      if (tp.partition !== undefined) {
        self.client.zk.checkPartitionOwnership(self.id, self.options.groupId, tp.topic, tp.partition, function (err) {
          if (err) {
            cbb(err);
          } else {
            cbb();
          }
        });
      } else {
        cbb();
      }
    }, callback);
  }

  // Check partition ownership and registration
  this.checkPartitionOwnershipInterval = setInterval(function () {
    if (!self.rebalancing) {
      async.parallel([
        checkPartitionOwnership,
        function (callback) {
          self.client.zk.isConsumerRegistered(self.options.groupId, self.id, function (error, registered) {
            if (error) {
              return callback(error);
            }
            if (registered) {
              callback();
            } else {
              callback(new Error(util.format('Consumer %s is not registered in group %s', self.id, self.options.groupId)));
            }
          });
        }
      ], function (error) {
        if (error) {
          self.emit('error', new errors.FailedToRegisterConsumerError(error.toString(), error));
        }
      });
    }
  }, 20000);

  function fetchAndUpdateOffsets (cb) {
    self.fetchOffset(self.topicPayloads, function (err, topics) {
      if (err) {
        return cb(err);
      }

      self.ready = true;
      self.updateOffsets(topics, true);

      return cb();
    });
  }

  function rebalance () {
    logger.debug('rebalance() %s is rebalancing: %s ready: %s', self.id, self.rebalancing, self.ready);
    if (!self.rebalancing &amp;&amp; !self.closing) {
      deregister();

      self.emit('rebalancing');

      self.rebalancing = true;
      logger.debug('HighLevelConsumer rebalance retry config: %s', JSON.stringify(self.options.rebalanceRetry));
      var oldTopicPayloads = self.topicPayloads;
      var operation = retry.operation(self.options.rebalanceRetry);

      operation.attempt(function (currentAttempt) {
        self.rebalanceAttempt(oldTopicPayloads, function (err) {
          if (operation.retry(err)) {
            return;
          }
          if (err) {
            self.rebalancing = false;
            return self.emit('error', new errors.FailedToRebalanceConsumerError(operation.mainError().toString()));
          } else {
            var topicNames = self.topicPayloads.map(function (p) {
              return p.topic;
            });
            self.client.refreshMetadata(topicNames, function (err) {
              register();
              if (err) {
                self.rebalancing = false;
                self.emit('error', err);
                return;
              }

              if (self.topicPayloads.length) {
                fetchAndUpdateOffsets(function (err) {
                  self.rebalancing = false;
                  if (err) {
                    self.emit('error', new errors.FailedToRebalanceConsumerError(err.message));
                    return;
                  }
                  self.fetch();
                  self.emit('rebalanced');
                });
              } else { // was not assigned any partitions during rebalance
                self.rebalancing = false;
                self.emit('rebalanced');
              }
            });
          }
        });
      });
    }
  }

  // Wait for the consumer to be ready
  this.on('registered', rebalance);

  function register (fn) {
    logger.debug('Registered listeners %s', self.id);
    self.client.zk.on('consumersChanged', fn ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.fetch" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.fetch">
        function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer.prototype.fetch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">HighLevelConsumer.prototype.fetch = function () {
  if (!this.ready || this.rebalancing || this.paused) {
    return;
  }

  this.client.sendFetchRequest(this, this.topicPayloads, this.options.fetchMaxWaitMs, this.options.fetchMinBytes, this.options.maxTickMessages
);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.fetchOffset" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.fetchOffset">
        function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer.prototype.fetchOffset
        <span class="apidocSignatureSpan">(payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">HighLevelConsumer.prototype.fetchOffset = function (payloads, cb) {
  logger.debug('in fetchOffset %s payloads: %j', this.id, payloads);
  this.client.sendOffsetFetchRequest(this.options.groupId, payloads, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.getTopicPayloads" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.getTopicPayloads">
        function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer.prototype.getTopicPayloads
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">HighLevelConsumer.prototype.getTopicPayloads = function () {
  if (!this.rebalancing) return this.topicPayloads;
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.init" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.init">
        function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer.prototype.init
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">HighLevelConsumer.prototype.init = function () {
  var self = this;

  if (!self.topicPayloads.length) {
    return;
  }

  self.registerConsumer(function (err) {
    if (err) {
      return self.emit('error', new errors.FailedToRegisterConsumerError(err.toString()));
    }

    // Close the
    return self.emit('registered');
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.leaveGroup" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.leaveGroup">
        function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer.prototype.leaveGroup
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">HighLevelConsumer.prototype.leaveGroup = function (cb) {
  var self = this;
  async.parallel([
    function (callback) {
      if (self.topicPayloads.length) {
        self._releasePartitions(self.topicPayloads, callback);
      } else {
        callback(null);
      }
    },
    function (callback) {
      self.client.zk.unregisterConsumer(self.options.groupId, self.id, callback);
    }
  ], cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.offsetRequest" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.offsetRequest">
        function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer.prototype.offsetRequest
        <span class="apidocSignatureSpan">(payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">HighLevelConsumer.prototype.offsetRequest = function (payloads, cb) {
  this.client.sendOffsetRequest(payloads, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.pause" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.pause">
        function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer.prototype.pause
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">HighLevelConsumer.prototype.pause = function () {
  this.paused = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.rebalanceAttempt" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.rebalanceAttempt">
        function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer.prototype.rebalanceAttempt
        <span class="apidocSignatureSpan">(oldTopicPayloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">HighLevelConsumer.prototype.rebalanceAttempt = function (oldTopicPayloads, cb) {
  var self = this;
  // Do the rebalance.....
  var consumerPerTopicMap;
  var newTopicPayloads = [];
  logger.debug('HighLevelConsumer %s is attempting to rebalance', self.id);
  async.series([

    // Stop fetching data and commit offsets
    function (callback) {
      logger.debug('HighLevelConsumer %s stopping data read during rebalance', self.id);
      self.stop(function () {
        callback();
      });
    },

    // Assemble the data
    function (callback) {
      logger.debug('HighLevelConsumer %s assembling data for rebalance', self.id);
      self.client.zk.getConsumersPerTopic(self.options.groupId, function (err, obj) {
        if (err) {
          callback(err);
        } else {
          consumerPerTopicMap = obj;
          callback();
        }
      });
    },

    // Release current partitions
    function (callback) {
      logger.debug('HighLevelConsumer %s releasing current partitions during rebalance', self.id);
      self._releasePartitions(oldTopicPayloads, callback);
    },

    // Rebalance
    function (callback) {
      logger.debug('HighLevelConsumer %s determining the partitions to own during rebalance', self.id);
      logger.debug('consumerPerTopicMap.consumerTopicMap %j', consumerPerTopicMap.consumerTopicMap);
      for (var topic in consumerPerTopicMap.consumerTopicMap[self.id]) {
        if (!consumerPerTopicMap.consumerTopicMap[self.id].hasOwnProperty(topic)) {
          continue;
        }
        var topicToAdd = consumerPerTopicMap.consumerTopicMap[self.id][topic];
        var numberOfConsumers = consumerPerTopicMap.topicConsumerMap[topicToAdd].length;
        var numberOfPartition = consumerPerTopicMap.topicPartitionMap[topicToAdd].length;
        var partitionsPerConsumer = Math.floor(numberOfPartition / numberOfConsumers);
        var extraPartitions = numberOfPartition % numberOfConsumers;
        var currentConsumerIndex;
        for (var index in consumerPerTopicMap.topicConsumerMap[topicToAdd]) {
          if (!consumerPerTopicMap.topicConsumerMap[topicToAdd].hasOwnProperty(index)) {
            continue;
          }
          if (consumerPerTopicMap.topicConsumerMap[topicToAdd][index] === self.id) {
            currentConsumerIndex = parseInt(index);
            break;
          }
        }
        var extraBit = currentConsumerIndex;
        if (currentConsumerIndex &gt; extraPartitions) extraBit = extraPartitions;
        var startPart = partitionsPerConsumer * currentConsumerIndex + extraBit;
        var extraNParts = 1;
        if (currentConsumerIndex + 1 &gt; extraPartitions) extraNParts = 0;
        var nParts = partitionsPerConsumer + extraNParts;

        for (var i = startPart; i &lt; startPart + nParts; i++) {
          newTopicPayloads.push({
            topic: topicToAdd,
            partition: consumerPerTopicMap.topicPartitionMap[topicToAdd][i],
            offset: 0,
            maxBytes: self.options.fetchMaxBytes,
            metadata: 'm'
          });
        }
      }
      logger.debug('newTopicPayloads %j', newTopicPayloads);
      callback();
    },

    // Update ZK with new ownership
    function (callback) {
      if (newTopicPayloads.length) {
        logger.debug('HighLevelConsumer %s gaining ownership of partitions during rebalance', self.id);
        async.eachSeries(newTopicPayloads, function (tp, cbb) {
          if (tp.partition !== undefined) {
            async.series([
              function (addcbb) {
                self.client.zk.checkPartitionOwnership(self.id, self.options.groupId, tp.topic, tp.partition, function (err) {
                  if (err) {
                    // Partition doesn't exist simply carry on
                    addcbb();
                  } else cbb(); // Partition exists simply carry on
                });
              },
              function (addcbb) {
                self.client.zk.addPartitionOwnership(self.id, self.options.groupId, tp.topic, tp.partition, function (err) {
                  if (err) {
                    addcbb(err);
                  } else addcbb(); ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.registerConsumer" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.registerConsumer">
        function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer.prototype.registerConsumer
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">HighLevelConsumer.prototype.registerConsumer = function (cb) {
  var self = this;
  var groupId = this.options.groupId;
  this.client.zk.registerConsumer(groupId, this.id, this.payloads, function (err) {
    if (err) return cb(err);
    self.client.zk.listConsumers(self.options.groupId);
    var topics = self.topicPayloads.reduce(function (ret, topicPayload) {
      if (ret.indexOf(topicPayload.topic) === -1) {
        ret.push(topicPayload.topic);
      }
      return ret;
    }, []);
    topics.forEach(function (topic) {
      self.client.zk.listPartitions(topic);
    });
    cb();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.removeTopics" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.removeTopics">
        function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer.prototype.removeTopics
        <span class="apidocSignatureSpan">(topics, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">HighLevelConsumer.prototype.removeTopics = function (topics, cb) {
  topics = typeof topics === 'string' ? [topics] : topics;
  this.payloads = this.payloads.filter(function (p) {
    return !~topics.indexOf(p.topic);
  });

  this.client.removeTopicMetadata(topics, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.resume" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.resume">
        function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer.prototype.resume
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">HighLevelConsumer.prototype.resume = function () {
  this.paused = false;
  this.fetch();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.sendOffsetCommitRequest" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.sendOffsetCommitRequest">
        function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer.prototype.sendOffsetCommitRequest
        <span class="apidocSignatureSpan">(commits, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">HighLevelConsumer.prototype.sendOffsetCommitRequest = function (commits, cb) {
  this.client.sendOffsetCommitRequest(this.options.groupId, commits, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.setOffset" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.setOffset">
        function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer.prototype.setOffset
        <span class="apidocSignatureSpan">(topic, partition, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">HighLevelConsumer.prototype.setOffset = function (topic, partition, offset) {
  this.topicPayloads.every(function (p) {
    if (p.topic === topic &amp;&amp; p.partition == partition) { // eslint-disable-line eqeqeq
      p.offset = offset;
      return false;
    }
    return true;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.stop" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.stop">
        function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer.prototype.stop
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">HighLevelConsumer.prototype.stop = function (cb) {
  if (!this.options.autoCommit) return cb &amp;&amp; cb();
  this.commit(true, function (err) {
    cb &amp;&amp; cb(err);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.updateOffsets" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.updateOffsets">
        function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer.prototype.updateOffsets
        <span class="apidocSignatureSpan">(topics, initing)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">HighLevelConsumer.prototype.updateOffsets = function (topics, initing) {
  this.topicPayloads.forEach(p =&gt; {
    if (!_.isEmpty(topics[p.topic]) &amp;&amp; topics[p.topic][p.partition] !== undefined) {
      var offset = topics[p.topic][p.partition];
      if (offset === -1) offset = 0;
      if (!initing) p.offset = offset + 1;
      else p.offset = offset;
      this.needToCommit = true;
    }
  });

  if (this.options.autoCommit &amp;&amp; !initing) {
    this.autoCommit(false, function (err) {
      err &amp;&amp; logger.debug('auto commit offset', err);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelProducer" id="apidoc.element.kafka-node.HighLevelProducer">
        function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelProducer
        <span class="apidocSignatureSpan">(client, options, customPartitioner)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HighLevelProducer(client, options, customPartitioner) {
  BaseProducer.call(this, client, options, BaseProducer.PARTITIONER_TYPES.cyclic, customPartitioner);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelProducer.super_" id="apidoc.element.kafka-node.HighLevelProducer.super_">
        function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelProducer.super_
        <span class="apidocSignatureSpan">(client, options, defaultPartitionerType, customPartitioner)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BaseProducer(client, options, defaultPartitionerType, customPartitioner) {
  options = options || {};

  this.ready = false;
  this.client = client;

  this.requireAcks = options.requireAcks === undefined
    ? DEFAULTS.requireAcks
    : options.requireAcks;
  this.ackTimeoutMs = options.ackTimeoutMs === undefined
    ? DEFAULTS.ackTimeoutMs
    : options.ackTimeoutMs;

  if (customPartitioner !== undefined &amp;&amp; options.partitionerType !== PARTITIONER_TYPES.custom) {
    throw new Error('Partitioner Type must be custom if providing a customPartitioner.');
  } else if (customPartitioner === undefined &amp;&amp; options.partitionerType === PARTITIONER_TYPES.custom) {
    throw new Error('No customer partitioner defined');
  }

  var partitionerType = PARTITIONER_MAP[options.partitionerType] || PARTITIONER_MAP[defaultPartitionerType];

  // eslint-disable-next-line
  this.partitioner = new partitionerType(customPartitioner);

  this.connect();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.buildPayloads" id="apidoc.element.kafka-node.HighLevelProducer.super_.prototype.buildPayloads">
        function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelProducer.super_.prototype.buildPayloads
        <span class="apidocSignatureSpan">(payloads, topicMetadata)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">HighLevelProducer.super_.prototype.buildPayloads = function (payloads, topicMetadata) {
  const topicPartitionRequests = Object.create(null);
  payloads.forEach((p) =&gt; {
    p.partition = p.hasOwnProperty('partition') ? p.partition : this.partitioner.getPartition(_.map(topicMetadata[p.topic], 'partition
'), p.key);
    p.attributes = p.hasOwnProperty('attributes') ? p.attributes : 0;
    let messages = _.isArray(p.messages) ? p.messages : [p.messages];

    messages = messages.map(function (message) {
      if (message instanceof KeyedMessage) {
        return message;
      }
      return new Message(0, 0, '', message);
    });

    let key = p.topic + p.partition;
    let request = topicPartitionRequests[key];

    if (request == null) {
      topicPartitionRequests[key] = new ProduceRequest(p.topic, p.partition, messages, p.attributes);
    } else {
      assert(request.attributes === p.attributes);
      Array.prototype.push.apply(request.messages, messages);
    }
  });
  return _.values(topicPartitionRequests);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.close" id="apidoc.element.kafka-node.HighLevelProducer.super_.prototype.close">
        function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelProducer.super_.prototype.close
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">HighLevelProducer.super_.prototype.close = function (cb) {
  this.client.close(cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.connect" id="apidoc.element.kafka-node.HighLevelProducer.super_.prototype.connect">
        function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelProducer.super_.prototype.connect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">HighLevelProducer.super_.prototype.connect = function () {
  // emiter...
  var self = this;
  this.ready = this.client.ready;
  if (this.ready) self.emit('ready');
  this.client.on('ready', function () {
    if (!self.ready) {
      self.ready = true;
      self.emit('ready');
    }
  });
  this.client.on('brokersChanged', function () {
    let topics = Object.keys(this.topicMetadata);
    this.refreshMetadata(topics, function (error) {
      if (error) {
        self.emit('error', error);
      }
    });
  });
  this.client.on('error', function (err) {
    self.emit('error', err);
  });
  this.client.on('close', function () {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.createTopics" id="apidoc.element.kafka-node.HighLevelProducer.super_.prototype.createTopics">
        function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelProducer.super_.prototype.createTopics
        <span class="apidocSignatureSpan">(topics, async, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">HighLevelProducer.super_.prototype.createTopics = function (topics, async, cb) {
  if (!this.ready) {
    return cb(new Error('Producer not ready!'));
  }

  this.client.createTopics(topics, async, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.send" id="apidoc.element.kafka-node.HighLevelProducer.super_.prototype.send">
        function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelProducer.super_.prototype.send
        <span class="apidocSignatureSpan">(payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">HighLevelProducer.super_.prototype.send = function (payloads, cb) {
  var client = this.client;
  var requireAcks = this.requireAcks;
  var ackTimeoutMs = this.ackTimeoutMs;

  client.sendProduceRequest(this.buildPayloads(payloads, client.topicMetadata), requireAcks, ackTimeoutMs, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.KeyedMessage" id="apidoc.element.kafka-node.KeyedMessage">
        function <span class="apidocSignatureSpan">kafka-node.</span>KeyedMessage
        <span class="apidocSignatureSpan">(key, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function KeyedMessage(key, value) {
  exports.Message.call(this, 0, 0, key, value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.KeyedPartitioner" id="apidoc.element.kafka-node.KeyedPartitioner">
        function <span class="apidocSignatureSpan">kafka-node.</span>KeyedPartitioner
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">KeyedPartitioner = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.KeyedPartitioner.prototype.getPartition" id="apidoc.element.kafka-node.KeyedPartitioner.prototype.getPartition">
        function <span class="apidocSignatureSpan">kafka-node.</span>KeyedPartitioner.prototype.getPartition
        <span class="apidocSignatureSpan">(partitions, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">KeyedPartitioner.prototype.getPartition = function (partitions, key) {
  key = key || '';

  var index = this.hashCode(key) % partitions.length;
  return partitions[index];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.KeyedPartitioner.prototype.hashCode" id="apidoc.element.kafka-node.KeyedPartitioner.prototype.hashCode">
        function <span class="apidocSignatureSpan">kafka-node.</span>KeyedPartitioner.prototype.hashCode
        <span class="apidocSignatureSpan">(string)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">KeyedPartitioner.prototype.hashCode = function (string) {
  var hash = 0;
  var length = string.length;

  for (var i = 0; i &lt; length; i++) {
    hash = ((hash * 31) + string.charCodeAt(i)) &amp; 0x7fffffff;
  }

  return (hash === 0) ? 1 : hash;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Offset" id="apidoc.element.kafka-node.Offset">
        function <span class="apidocSignatureSpan">kafka-node.</span>Offset
        <span class="apidocSignatureSpan">(client)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Offset = function (client) {
  var self = this;
  this.client = client;
  this.ready = this.client.ready;
  this.client.on('ready', function () {
    self.ready = true;
    self.emit('ready');
  });
  this.client.once('connect', function () {
    self.emit('connect');
  });
  this.client.on('error', function (err) {
    self.emit('error', err);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `cb`: *Function*, the callback

Example

```js
var kafka = require('kafka-node'),
    client = new kafka.Client(),
    offset = new kafka.<span class="apidocCodeKeywordSpan">Offset</span>(client);
    offset.fetch([
        { topic: 't', partition: 0, time: Date.now(), maxNum: 1 }
    ], function (err, data) {
        // data
        // { 't': { '0': [999] } }
    });
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Offset.prototype.buildPayloads" id="apidoc.element.kafka-node.Offset.prototype.buildPayloads">
        function <span class="apidocSignatureSpan">kafka-node.</span>Offset.prototype.buildPayloads
        <span class="apidocSignatureSpan">(payloads)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Offset.prototype.buildPayloads = function (payloads) {
  return payloads.map(function (p) {
    p.partition = p.partition || 0;
    p.time = p.time || Date.now();
    p.maxNum = p.maxNum || 1;
    p.metadata = 'm'; // metadata can be arbitrary
    return p;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Offset.prototype.commit" id="apidoc.element.kafka-node.Offset.prototype.commit">
        function <span class="apidocSignatureSpan">kafka-node.</span>Offset.prototype.commit
        <span class="apidocSignatureSpan">(groupId, payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Offset.prototype.commit = function (groupId, payloads, cb) {
  if (!this.ready) {
    this.once('ready', () =&gt; this.commit(groupId, payloads, cb));
    return;
  }
  this.client.sendOffsetCommitRequest(groupId, this.buildPayloads(payloads), cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Offset.prototype.fetch" id="apidoc.element.kafka-node.Offset.prototype.fetch">
        function <span class="apidocSignatureSpan">kafka-node.</span>Offset.prototype.fetch
        <span class="apidocSignatureSpan">(payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Offset.prototype.fetch = function (payloads, cb) {
  if (!this.ready) {
    this.once('ready', () =&gt; this.fetch(payloads, cb));
    return;
  }
  this.client.sendOffsetRequest(this.buildPayloads(payloads), cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Offset.prototype.fetchCommits" id="apidoc.element.kafka-node.Offset.prototype.fetchCommits">
        function <span class="apidocSignatureSpan">kafka-node.</span>Offset.prototype.fetchCommits
        <span class="apidocSignatureSpan">(groupId, payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Offset.prototype.fetchCommits = function (groupId, payloads, cb) {
  if (!this.ready) {
    this.once('ready', () =&gt; this.fetchCommits(groupId, payloads, cb));
    return;
  }
  this.client.sendOffsetFetchRequest(groupId, this.buildPayloads(payloads), cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Offset.prototype.fetchEarliestOffsets" id="apidoc.element.kafka-node.Offset.prototype.fetchEarliestOffsets">
        function <span class="apidocSignatureSpan">kafka-node.</span>Offset.prototype.fetchEarliestOffsets
        <span class="apidocSignatureSpan">(topics, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Offset.prototype.fetchEarliestOffsets = function (topics, cb) {
  fetchOffsets(this, topics, cb, -2);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Offset.prototype.fetchLatestOffsets" id="apidoc.element.kafka-node.Offset.prototype.fetchLatestOffsets">
        function <span class="apidocSignatureSpan">kafka-node.</span>Offset.prototype.fetchLatestOffsets
        <span class="apidocSignatureSpan">(topics, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Offset.prototype.fetchLatestOffsets = function (topics, cb) {
  fetchOffsets(this, topics, cb, -1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Producer" id="apidoc.element.kafka-node.Producer">
        function <span class="apidocSignatureSpan">kafka-node.</span>Producer
        <span class="apidocSignatureSpan">(client, options, customPartitioner)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Producer(client, options, customPartitioner) {
  BaseProducer.call(this, client, options, BaseProducer.PARTITIONER_TYPES.default, customPartitioner);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.RandomPartitioner" id="apidoc.element.kafka-node.RandomPartitioner">
        function <span class="apidocSignatureSpan">kafka-node.</span>RandomPartitioner
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RandomPartitioner = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.RandomPartitioner.prototype.getPartition" id="apidoc.element.kafka-node.RandomPartitioner.prototype.getPartition">
        function <span class="apidocSignatureSpan">kafka-node.</span>RandomPartitioner.prototype.getPartition
        <span class="apidocSignatureSpan">(partitions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RandomPartitioner.prototype.getPartition = function (partitions) {
  return partitions[Math.floor(Math.random() * partitions.length)];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.consumerGroupHeartbeat" id="apidoc.element.kafka-node.consumerGroupHeartbeat">
        function <span class="apidocSignatureSpan">kafka-node.</span>consumerGroupHeartbeat
        <span class="apidocSignatureSpan">(client, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Heartbeat {
  constructor (client, handler) {
    this.client = client;
    this.handler = handler;
    this.pending = true;
  }

  send (groupId, generationId, memberId) {
    this.client.sendHeartbeatRequest(groupId, generationId, memberId, (error) =&gt; {
      if (this.canceled) {
        logger.debug('heartbeat yielded after being canceled', error);
        return;
      }
      this.pending = false;
      this.handler(error);
    });
  }

  verifyResolved () {
    if (this.pending) {
      this.canceled = true;
      this.pending = false;
      this.handler(new HeartbeatTimeoutError('Heartbeat timed out'));
      return false;
    }
    return true;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.consumerGroupMigrator" id="apidoc.element.kafka-node.consumerGroupMigrator">
        function <span class="apidocSignatureSpan">kafka-node.</span>consumerGroupMigrator
        <span class="apidocSignatureSpan">(consumerGroup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ConsumerGroupMigrator(consumerGroup) {
  EventEmitter.call(this);
  assert(consumerGroup);
  const self = this;
  this.consumerGroup = consumerGroup;
  this.client = consumerGroup.client;
  var verified = 0;

  if (consumerGroup.options.migrateRolling) {
    this.zk = zookeeper.createClient(consumerGroup.client.connectionString, {retries: 10});
    this.zk.on('connected', function () {
      self.filterByExistingZkTopics(function (error, topics) {
        if (error) {
          return self.emit('error', error);
        }

        if (topics.length) {
          self.checkForOwnersAndListenForChange(topics);
        } else {
          logger.debug('No HLC topics exist in zookeeper.');
          self.connectConsumerGroup();
        }
      });
    });

    this.on('noOwnersForTopics', function (topics) {
      logger.debug('No owners for topics %s reported.', topics);
      if (++verified &lt;= NUMER_OF_TIMES_TO_VERIFY) {
        logger.debug('%s verify %d of %d HLC has given up ownership by checking again in %d', self.client.clientId, verified,
          NUMER_OF_TIMES_TO_VERIFY, VERIFY_WAIT_TIME_MS);

        setTimeout(function () {
          self.checkForOwners(topics);
        }, VERIFY_WAIT_TIME_MS);
      } else {
        self.connectConsumerGroup();
      }
    });

    this.on('topicOwnerChange', _.debounce(function (topics) {
      verified = 0;
      self.checkForOwnersAndListenForChange(topics);
    }, 250));

    this.zk.connect();
  } else {
    this.connectConsumerGroup();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.consumerGroupRecovery" id="apidoc.element.kafka-node.consumerGroupRecovery">
        function <span class="apidocSignatureSpan">kafka-node.</span>consumerGroupRecovery
        <span class="apidocSignatureSpan">(consumerGroup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ConsumerGroupRecovery(consumerGroup) {
  this.consumerGroup = consumerGroup;
  this.options = consumerGroup.options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.logging" id="apidoc.element.kafka-node.logging">
        function <span class="apidocSignatureSpan">kafka-node.</span>logging
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getLogger(name) {
  return loggerProvider(name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Client" id="apidoc.module.kafka-node.Client">module kafka-node.Client</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client.Client" id="apidoc.element.kafka-node.Client.Client">
        function <span class="apidocSignatureSpan">kafka-node.</span>Client
        <span class="apidocSignatureSpan">(connectionString, clientId, zkOptions, noAckBatchOptions, sslOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client = function (connectionString, clientId, zkOptions, noAckBatchOptions, sslOptions) {
  if (this instanceof Client === false) {
    return new Client(connectionString, clientId, zkOptions, noAckBatchOptions, sslOptions);
  }

  this.sslOptions = sslOptions;
  this.ssl = !!sslOptions;

  if (clientId) {
    validateConfig('clientId', clientId);
  }

  this.connectionString = connectionString || 'localhost:2181/';
  this.clientId = clientId || 'kafka-node-client';
  this.zkOptions = zkOptions;
  this.noAckBatchOptions = noAckBatchOptions;
  this.brokers = {};
  this.longpollingBrokers = {};
  this.topicMetadata = {};
  this.topicPartitions = {};
  this.correlationId = 0;
  this._socketId = 0;
  this.cbqueue = {};
  this.brokerMetadata = {};
  this.ready = false;
  this.connect();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    partitionerType: 2
}
```

``` js
var kafka = require('kafka-node'),
    Producer = kafka.Producer,
    client = new kafka.<span class="apidocCodeKeywordSpan">Client</span>(),
    producer = new Producer(client);
```

### Events

- `ready`: this event is emitted when producer is ready to send messages.
- `error`: this is the error event propagates from internal client, producer should always listen it.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.super_" id="apidoc.element.kafka-node.Client.super_">
        function <span class="apidocSignatureSpan">kafka-node.Client.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Client.prototype" id="apidoc.module.kafka-node.Client.prototype">module kafka-node.Client.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.addTopics" id="apidoc.element.kafka-node.Client.prototype.addTopics">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>addTopics
        <span class="apidocSignatureSpan">(topics, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addTopics = function (topics, cb) {
  var self = this;
  this.topicExists(topics, function (err) {
    if (err) return cb(err);
    self.loadMetadataForTopics(topics, function (err, resp) {
      if (err) return cb(err);
      self.updateMetadatas(resp);
      cb(null, topics);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `topics`: **Array**, array of topics to add
* `cb`: **Function**,the callback
* `fromOffset`: **Boolean**, if true, the consumer will fetch message from the specified offset, otherwise it will fetch message
 from the last commited offset of the topic.

Example:

``` js
consumer.<span class="apidocCodeKeywordSpan">addTopics</span>(['t1', 't2'], function (err, added) {
});

or

consumer.addTopics([{ topic: 't1', offset: 10 }], function (err, added) {
}, true);
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.brokerForLeader" id="apidoc.element.kafka-node.Client.prototype.brokerForLeader">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>brokerForLeader
        <span class="apidocSignatureSpan">(leader, longpolling)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">brokerForLeader = function (leader, longpolling) {
  var addr;
  var brokers = this.getBrokers(longpolling);
  // If leader is not give, choose the first broker as leader
  if (typeof leader === 'undefined') {
    if (!_.isEmpty(brokers)) {
      addr = Object.keys(brokers)[0];
      return brokers[addr];
    } else if (!_.isEmpty(this.brokerMetadata)) {
      leader = Object.keys(this.brokerMetadata)[0];
    } else {
      return;
    }
  }

  var broker = _.find(this.brokerProfiles, {id: leader});

  if (!broker) {
    return;
  }

  addr = broker.host + ':' + broker.port;

  return brokers[addr] || this.setupBroker(broker.host, broker.port, longpolling, brokers);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.checkMetadatas" id="apidoc.element.kafka-node.Client.prototype.checkMetadatas">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>checkMetadatas
        <span class="apidocSignatureSpan">(payloads)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkMetadatas = function (payloads) {
  if (_.isEmpty(this.topicMetadata)) return [ [], payloads ];
  // out: [ [metadata exists], [metadata not exists] ]
  var out = [ [], [] ];
  payloads.forEach(function (p) {
    if (this.hasMetadata(p.topic, p.partition)) out[0].push(p);
    else out[1].push(p);
  }.bind(this));
  return out;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.clearCallbackQueue" id="apidoc.element.kafka-node.Client.prototype.clearCallbackQueue">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>clearCallbackQueue
        <span class="apidocSignatureSpan">(socket, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearCallbackQueue = function (socket, error) {
  var socketId = socket.socketId;
  var longpolling = socket.longpolling;

  if (!this.cbqueue.hasOwnProperty(socketId)) {
    return;
  }

  var queue = this.cbqueue[socketId];

  if (!longpolling) {
    Object.keys(queue).forEach(function (key) {
      var handlers = queue[key];
      var cb = handlers[1];
      cb(error);
    });
  }
  delete this.cbqueue[socketId];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.close" id="apidoc.element.kafka-node.Client.prototype.close">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>close
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (cb) {
  this.closeBrokers(this.brokers);
  this.closeBrokers(this.longpollingBrokers);
  this.zk.close();
  cb &amp;&amp; cb();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### close(force, cb)
* `force`: **Boolean**, if set to true, it forces the consumer to commit the current offset before closing, default `false`

Example

```js
consumer.<span class="apidocCodeKeywordSpan">close</span>(true, cb);
consumer.close(cb); //force is disabled
```

## HighLevelConsumer
âš&nbsp;ï¸ ***This consumer has been deprecated in the latest version of Kafka (0.10.1) and is likely to be removed in the future. Please
 use the ConsumerGroup instead.***

### HighLevelConsumer(client, payloads, options)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.closeBrokers" id="apidoc.element.kafka-node.Client.prototype.closeBrokers">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>closeBrokers
        <span class="apidocSignatureSpan">(brokers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">closeBrokers = function (brokers) {
  _.each(brokers, function (broker) {
    broker.socket.closing = true;
    broker.socket.end();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.connect" id="apidoc.element.kafka-node.Client.prototype.connect">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>connect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connect = function () {
  var zk = this.zk = new Zookeeper(this.connectionString, this.zkOptions);
  var self = this;
  zk.once('init', function (brokers) {
    try {
      self.ready = true;
      self.brokerMetadata = brokers;
      self.setupBrokerProfiles(brokers);
      Object
          .keys(self.brokerProfiles)
          .some(function (key, index) {
            var broker = self.brokerProfiles[key];
            self.setupBroker(broker.host, broker.port, false, self.brokers);
            // Only connect one broker
            return !index;
          });
      self.emit('ready');
    } catch (error) {
      self.ready = false;
      self.emit('error', error);
    }
  });
  zk.on('brokersChanged', function (brokerMetadata) {
    try {
      self.brokerMetadata = brokerMetadata;
      logger.debug('brokersChanged', brokerMetadata);
      self.setupBrokerProfiles(brokerMetadata);
      self.refreshBrokers();
      // Emit after a 3 seconds
      setTimeout(function () {
        self.emit('brokersChanged');
      }, 3000);
    } catch (error) {
      self.emit('error', error);
    }
  });
  zk.once('disconnected', function () {
    if (!zk.closed) {
      zk.close();
      self.connect();
      self.emit('zkReconnect');
    }
  });
  zk.on('error', function (err) {
    self.emit('error', err);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    });

    this.on('topicOwnerChange', _.debounce(function (topics) {
      verified = 0;
      self.checkForOwnersAndListenForChange(topics);
    }, 250));

    this.zk.<span class="apidocCodeKeywordSpan">connect</span>();
  } else {
    this.connectConsumerGroup();
  }
}

util.inherits(ConsumerGroupMigrator, EventEmitter);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.createBroker" id="apidoc.element.kafka-node.Client.prototype.createBroker">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>createBroker
        <span class="apidocSignatureSpan">(host, port, longpolling)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createBroker = function (host, port, longpolling) {
  var self = this;
  var socket;
  if (self.ssl) {
    socket = tls.connect(port, host, self.sslOptions);
  } else {
    socket = net.createConnection(port, host);
  }
  socket.addr = host + ':' + port;
  socket.host = host;
  socket.port = port;
  socket.socketId = this.nextSocketId();
  if (longpolling) socket.longpolling = true;

  socket.on('connect', function () {
    var lastError = this.error;
    this.error = null;
    if (lastError) {
      this.waiting = false;
      self.emit('reconnect');
    } else {
      self.emit('connect');
    }
  });
  socket.on('error', function (err) {
    this.error = err;
    self.emit('error', err);
  });
  socket.on('close', function (hadError) {
    self.emit('close', this);
    if (hadError &amp;&amp; this.error) {
      self.clearCallbackQueue(this, this.error);
    } else {
      self.clearCallbackQueue(this, new errors.BrokerNotAvailableError('Broker not available'));
    }
    retry(this);
  });
  socket.on('end', function () {
    retry(this);
  });
  socket.buffer = new Buffer([]);
  socket.on('data', function (data) {
    this.buffer = Buffer.concat([this.buffer, data]);
    self.handleReceivedData(this);
  });
  socket.setKeepAlive(true, 60000);

  function retry (s) {
    if (s.retrying || s.closing) return;
    s.retrying = true;
    s.retryTimer = setTimeout(function () {
      if (s.closing) return;
      self.reconnectBroker(s);
    }, 1000);
  }
  return new BrokerWrapper(socket, this.noAckBatchOptions);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.createTopics" id="apidoc.element.kafka-node.Client.prototype.createTopics">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>createTopics
        <span class="apidocSignatureSpan">(topics, isAsync, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createTopics = function (topics, isAsync, cb) {
  topics = typeof topics === 'string' ? [topics] : topics;

  if (typeof isAsync === 'function' &amp;&amp; typeof cb === 'undefined') {
    cb = isAsync;
    isAsync = true;
  }

  try {
    validateKafkaTopics(topics);
  } catch (e) {
    if (isAsync) return cb(e);
    throw e;
  }

  cb = _.once(cb);

  const getTopicsFromKafka = (topics, callback) =&gt; {
    this.loadMetadataForTopics(topics, function (error, resp) {
      if (error) {
        return callback(error);
      }
      callback(null, Object.keys(resp[1].metadata));
    });
  };

  const operation = retry.operation({ minTimeout: 200, maxTimeout: 2000 });

  operation.attempt(currentAttempt =&gt; {
    logger.debug('create topics currentAttempt', currentAttempt);
    getTopicsFromKafka(topics, function (error, kafkaTopics) {
      if (error) {
        if (operation.retry(error)) {
          return;
        }
      }

      logger.debug('kafka reported topics', kafkaTopics);
      const left = _.difference(topics, kafkaTopics);
      if (left.length === 0) {
        logger.debug(`Topics created ${kafkaTopics}`);
        return cb(null, kafkaTopics);
      }

      logger.debug(`Topics left ${left.join(', ')}`);
      if (!operation.retry(new Error(`Topics not created ${left}`))) {
        cb(operation.mainError());
      }
    });
  });

  if (!isAsync) {
    cb(null);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

``` js
var kafka = require('kafka-node'),
    Producer = kafka.Producer,
    client = new kafka.Client(),
    producer = new Producer(client);
// Create topics sync
producer.<span class="apidocCodeKeywordSpan">createTopics</span>(['t','t1'], false, function (err, data) {
    console.log(data);
});
// Create topics async
producer.createTopics(['t'], true, function (err, data) {});
producer.createTopics(['t'], function (err, data) {});// Simply omit 2nd arg
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.getBrokers" id="apidoc.element.kafka-node.Client.prototype.getBrokers">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>getBrokers
        <span class="apidocSignatureSpan">(longpolling)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getBrokers = function (longpolling) {
  return longpolling ? this.longpollingBrokers : this.brokers;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.handleReceivedData" id="apidoc.element.kafka-node.Client.prototype.handleReceivedData">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>handleReceivedData
        <span class="apidocSignatureSpan">(socket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleReceivedData = function (socket) {
  var vars = Binary.parse(socket.buffer).word32bu('size').word32bu('correlationId').vars;
  var size = vars.size + 4;
  var correlationId = vars.correlationId;

  if (socket.buffer.length &gt;= size) {
    var resp = socket.buffer.slice(0, size);
    var handlers = this.unqueueCallback(socket, correlationId);

    if (!handlers) return;
    var decoder = handlers[0];
    var cb = handlers[1];
    var result = decoder(resp);
    (result instanceof Error)
      ? cb.call(this, result)
      : cb.call(this, null, result);
    socket.buffer = socket.buffer.slice(size);
    if (socket.longpolling) socket.waiting = false;
  } else { return; }

  if (socket.buffer.length) {
    setImmediate(function () { this.handleReceivedData(socket); }.bind(this));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.hasMetadata" id="apidoc.element.kafka-node.Client.prototype.hasMetadata">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>hasMetadata
        <span class="apidocSignatureSpan">(topic, partition)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasMetadata = function (topic, partition) {
  var brokerMetadata = this.brokerMetadata;
  var leader = this.leaderByPartition(topic, partition);

  return (leader !== undefined) &amp;&amp; brokerMetadata[leader];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.leaderByPartition" id="apidoc.element.kafka-node.Client.prototype.leaderByPartition">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>leaderByPartition
        <span class="apidocSignatureSpan">(topic, partition)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">leaderByPartition = function (topic, partition) {
  var topicMetadata = this.topicMetadata;
  return topicMetadata[topic] &amp;&amp; topicMetadata[topic][partition] &amp;&amp; topicMetadata[topic][partition].leader;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.loadMetadataForTopics" id="apidoc.element.kafka-node.Client.prototype.loadMetadataForTopics">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>loadMetadataForTopics
        <span class="apidocSignatureSpan">(topics, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadMetadataForTopics = function (topics, cb) {
  var correlationId = this.nextId();
  var request = protocol.encodeMetadataRequest(this.clientId, correlationId, topics);
  var broker = this.brokerForLeader();

  if (!broker || !broker.socket || broker.socket.error || broker.socket.destroyed) {
    return cb(new errors.BrokerNotAvailableError('Broker not available'));
  }

  this.queueCallback(broker.socket, correlationId, [protocol.decodeMetadataResponse, cb]);
  broker.write(request);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

## How do I get a list of all topics?

Call `client.loadMetadataForTopics` with a blank topic array to get the entire list of available topics (and available brokers).

```js
client.once('connect', function () {
	client.<span class="apidocCodeKeywordSpan">loadMetadataForTopics</span>([], function (error, results) {
	  if (error) {
	  	return console.error(error);
	  }
	  console.log('%j', _.get(results, '1.metadata'));
	});
});
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.nextId" id="apidoc.element.kafka-node.Client.prototype.nextId">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>nextId
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nextId = function () {
  if (this.correlationId &gt;= MAX_INT32) {
    this.correlationId = 0;
  }
  return this.correlationId++;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.nextSocketId" id="apidoc.element.kafka-node.Client.prototype.nextSocketId">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>nextSocketId
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nextSocketId = function () {
  return this._socketId++;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.payloadsByLeader" id="apidoc.element.kafka-node.Client.prototype.payloadsByLeader">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>payloadsByLeader
        <span class="apidocSignatureSpan">(payloads)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">payloadsByLeader = function (payloads) {
  return payloads.reduce(function (out, p) {
    var leader = this.leaderByPartition(p.topic, p.partition);
    out[leader] = out[leader] || [];
    out[leader].push(p);
    return out;
  }.bind(this), {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.queueCallback" id="apidoc.element.kafka-node.Client.prototype.queueCallback">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>queueCallback
        <span class="apidocSignatureSpan">(socket, id, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">queueCallback = function (socket, id, data) {
  var socketId = socket.socketId;
  var queue;

  if (this.cbqueue.hasOwnProperty(socketId)) {
    queue = this.cbqueue[socketId];
  } else {
    queue = {};
    this.cbqueue[socketId] = queue;
  }

  queue[id] = data;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.reconnectBroker" id="apidoc.element.kafka-node.Client.prototype.reconnectBroker">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>reconnectBroker
        <span class="apidocSignatureSpan">(oldSocket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reconnectBroker = function (oldSocket) {
  oldSocket.retrying = false;
  if (oldSocket.error) {
    oldSocket.destroy();
  }
  var brokers = this.getBrokers(oldSocket.longpolling);
  var newBroker = this.setupBroker(oldSocket.host, oldSocket.port, oldSocket.longpolling, brokers);
  newBroker.socket.error = oldSocket.error;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.refreshBrokers" id="apidoc.element.kafka-node.Client.prototype.refreshBrokers">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>refreshBrokers
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">refreshBrokers = function () {
  var self = this;
  var validBrokers = Object.keys(this.brokerProfiles);

  function closeDeadBrokers (brokers) {
    var deadBrokerKeys = _.difference(Object.keys(brokers), validBrokers);
    if (deadBrokerKeys.length) {
      self.closeBrokers(deadBrokerKeys.map(function (key) {
        var broker = brokers[key];
        delete brokers[key];
        return broker;
      }));
    }
  }

  closeDeadBrokers(this.brokers);
  closeDeadBrokers(this.longpollingBrokers);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.refreshMetadata" id="apidoc.element.kafka-node.Client.prototype.refreshMetadata">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>refreshMetadata
        <span class="apidocSignatureSpan">(topicNames, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">refreshMetadata = function (topicNames, cb) {
  var self = this;
  if (!topicNames.length) return cb();
  attemptRequestMetadata(topicNames, cb);

  function attemptRequestMetadata (topics, cb) {
    var operation = retry.operation({ minTimeout: 200, maxTimeout: 1000 });
    operation.attempt(function (currentAttempt) {
      logger.debug('refresh metadata currentAttempt', currentAttempt);
      self.loadMetadataForTopics(topics, function (err, resp) {
        err = err || resp[1].error;
        if (operation.retry(err)) {
          return;
        }
        if (err) {
          logger.debug('refresh metadata error', err.message);
          return cb(err);
        }
        self.updateMetadatas(resp);
        cb();
      });
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Error:

```
BrokerNotAvailableError: Could not find the leader
```

Call `client.<span class="apidocCodeKeywordSpan">refreshMetadata</span>()` before sending the first message. Reference issue [#354
](https://github.com/SOHU-Co/kafka-node/issues/354)



## How do I debug an issue?
This module uses the [debug module](https://github.com/visionmedia/debug) so you can just run below before starting your app.

```bash
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.removeTopicMetadata" id="apidoc.element.kafka-node.Client.prototype.removeTopicMetadata">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>removeTopicMetadata
        <span class="apidocSignatureSpan">(topics, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeTopicMetadata = function (topics, cb) {
  topics.forEach(function (t) {
    if (this.topicMetadata[t]) delete this.topicMetadata[t];
  }.bind(this));
  cb(null, topics.length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.send" id="apidoc.element.kafka-node.Client.prototype.send">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>send
        <span class="apidocSignatureSpan">(payloads, encoder, decoder, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">send = function (payloads, encoder, decoder, cb) {
  var self = this;
  var _payloads = payloads;
  // payloads: [ [metadata exists], [metadata not exists] ]
  payloads = this.checkMetadatas(payloads);
  if (payloads[0].length &amp;&amp; !payloads[1].length) {
    this.sendToBroker(_.flatten(payloads), encoder, decoder, cb);
    return;
  }
  if (payloads[1].length) {
    var topicNames = payloads[1].map(function (p) { return p.topic; });
    this.loadMetadataForTopics(topicNames, function (err, resp) {
      if (err) {
        return cb(err);
      }

      var error = resp[1].error;
      if (error) {
        return cb(error);
      }

      self.updateMetadatas(resp);
      // check payloads again
      payloads = self.checkMetadatas(_payloads);
      if (payloads[1].length) {
        return cb(new errors.BrokerNotAvailableError('Could not find the leader'));
      }

      self.sendToBroker(payloads[1].concat(payloads[0]), encoder, decoder, cb);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    producer = new Producer(client),
    km = new KeyedMessage('key', 'message'),
    payloads = [
        { topic: 'topic1', messages: 'hi', partition: 0 },
        { topic: 'topic2', messages: ['hello', 'world', km] }
    ];
producer.on('ready', function () {
    producer.<span class="apidocCodeKeywordSpan">send</span>(payloads, function (err, data) {
        console.log(data);
    });
});

producer.on('error', function (err) {})
```
&gt; âš&nbsp;ï¸**WARNING**: Batch multiple messages of the same topic/partition together as an array on the `messages` attribute otherwise
 you may lose messages!
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendFetchRequest" id="apidoc.element.kafka-node.Client.prototype.sendFetchRequest">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendFetchRequest
        <span class="apidocSignatureSpan">(consumer, payloads, fetchMaxWaitMs, fetchMinBytes, maxTickMessages)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendFetchRequest = function (consumer, payloads, fetchMaxWaitMs, fetchMinBytes, maxTickMessages) {
  var self = this;
  var encoder = protocol.encodeFetchRequest(fetchMaxWaitMs, fetchMinBytes);
  var decoder = protocol.decodeFetchResponse(function (err, type, message) {
    if (err) {
      if (err.message === 'OffsetOutOfRange') {
        return consumer.emit('offsetOutOfRange', err);
      } else if (err.message === 'NotLeaderForPartition' || err.message === 'UnknownTopicOrPartition') {
        return self.emit('brokersChanged');
      }

      return consumer.emit('error', err);
    }

    var encoding = consumer.options.encoding;

    if (type === 'message') {
      if (encoding !== 'buffer' &amp;&amp; message.value) {
        message.value = message.value.toString(encoding);
      }

      consumer.emit('message', message);
    } else {
      consumer.emit('done', message);
    }
  }, maxTickMessages);

  this.send(payloads, encoder, decoder, function (err) {
    if (err) {
      Array.prototype.unshift.call(arguments, 'error');
      consumer.emit.apply(consumer, arguments);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendGroupCoordinatorRequest" id="apidoc.element.kafka-node.Client.prototype.sendGroupCoordinatorRequest">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendGroupCoordinatorRequest
        <span class="apidocSignatureSpan">(groupId, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendGroupCoordinatorRequest = function (groupId, cb) {
  this.sendGroupRequest(protocol.encodeGroupCoordinatorRequest, protocol.decodeGroupCoordinatorResponse, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendGroupRequest" id="apidoc.element.kafka-node.Client.prototype.sendGroupRequest">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendGroupRequest
        <span class="apidocSignatureSpan">(encode, decode, requestArgs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendGroupRequest = function (encode, decode, requestArgs) {
  requestArgs = _.values(requestArgs);
  var cb = requestArgs.pop();
  var correlationId = this.nextId();

  requestArgs.unshift(this.clientId, correlationId);

  var request = encode.apply(null, requestArgs);
  var broker = this.brokerForLeader(this.coordinatorId);

  if (!broker || !broker.socket || broker.socket.error || broker.socket.destroyed) {
    return cb(new errors.BrokerNotAvailableError('Broker not available'));
  }

  this.queueCallback(broker.socket, correlationId, [decode, cb]);
  broker.write(request);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendHeartbeatRequest" id="apidoc.element.kafka-node.Client.prototype.sendHeartbeatRequest">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendHeartbeatRequest
        <span class="apidocSignatureSpan">(groupId, generationId, memberId, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendHeartbeatRequest = function (groupId, generationId, memberId, cb) {
  this.sendGroupRequest(protocol.encodeGroupHeartbeat, protocol.decodeGroupHeartbeat, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
constructor (client, handler) {
  this.client = client;
  this.handler = handler;
  this.pending = true;
}

send (groupId, generationId, memberId) {
  this.client.<span class="apidocCodeKeywordSpan">sendHeartbeatRequest</span>(groupId, generationId, memberId, (error) =&gt; {
    if (this.canceled) {
      logger.debug('heartbeat yielded after being canceled', error);
      return;
    }
    this.pending = false;
    this.handler(error);
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendJoinGroupRequest" id="apidoc.element.kafka-node.Client.prototype.sendJoinGroupRequest">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendJoinGroupRequest
        <span class="apidocSignatureSpan">(groupId, memberId, sessionTimeout, groupProtocol, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendJoinGroupRequest = function (groupId, memberId, sessionTimeout, groupProtocol, cb) {
  this.sendGroupRequest(protocol.encodeJoinGroupRequest, protocol.decodeJoinGroupResponse, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendLeaveGroupRequest" id="apidoc.element.kafka-node.Client.prototype.sendLeaveGroupRequest">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendLeaveGroupRequest
        <span class="apidocSignatureSpan">(groupId, memberId, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendLeaveGroupRequest = function (groupId, memberId, cb) {
  this.sendGroupRequest(protocol.encodeLeaveGroupRequest, protocol.decodeLeaveGroupResponse, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendOffsetCommitRequest" id="apidoc.element.kafka-node.Client.prototype.sendOffsetCommitRequest">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendOffsetCommitRequest
        <span class="apidocSignatureSpan">(group, payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendOffsetCommitRequest = function (group, payloads, cb) {
  var encoder = protocol.encodeOffsetCommitRequest(group);
  var decoder = protocol.decodeOffsetCommitResponse;
  this.send(payloads, encoder, decoder, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendOffsetCommitV2Request" id="apidoc.element.kafka-node.Client.prototype.sendOffsetCommitV2Request">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendOffsetCommitV2Request
        <span class="apidocSignatureSpan">(group, generationId, memberId, payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendOffsetCommitV2Request = function (group, generationId, memberId, payloads, cb) {
  var encoder = protocol.encodeOffsetCommitV2Request;
  var decoder = protocol.decodeOffsetCommitResponse;
  this.sendGroupRequest(encoder, decoder, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendOffsetFetchRequest" id="apidoc.element.kafka-node.Client.prototype.sendOffsetFetchRequest">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendOffsetFetchRequest
        <span class="apidocSignatureSpan">(group, payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendOffsetFetchRequest = function (group, payloads, cb) {
  var encoder = protocol.encodeOffsetFetchRequest(group);
  var decoder = protocol.decodeOffsetFetchResponse;
  this.send(payloads, encoder, decoder, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }
);
};

ConsumerGroupMigrator.prototype.saveHighLevelConsumerOffsets = function (topicPartitionList, callback) {
const self = this;
this.client.<span class="apidocCodeKeywordSpan">sendOffsetFetchRequest</span>(this.consumerGroup.options.groupId, topicPartitionList
, function (error, results) {
  logger.debug('sendOffsetFetchRequest response:', results, error);
  if (error) {
    return callback(error);
  }
  self.offsets = results;
  callback(null);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendOffsetFetchV1Request" id="apidoc.element.kafka-node.Client.prototype.sendOffsetFetchV1Request">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendOffsetFetchV1Request
        <span class="apidocSignatureSpan">(group, payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendOffsetFetchV1Request = function (group, payloads, cb) {
  var encoder = protocol.encodeOffsetFetchV1Request;
  var decoder = protocol.decodeOffsetFetchV1Response;
  this.sendGroupRequest(encoder, decoder, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendOffsetRequest" id="apidoc.element.kafka-node.Client.prototype.sendOffsetRequest">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendOffsetRequest
        <span class="apidocSignatureSpan">(payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendOffsetRequest = function (payloads, cb) {
  var encoder = protocol.encodeOffsetRequest;
  var decoder = protocol.decodeOffsetResponse;
  this.send(payloads, encoder, decoder, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendProduceRequest" id="apidoc.element.kafka-node.Client.prototype.sendProduceRequest">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendProduceRequest
        <span class="apidocSignatureSpan">(payloads, requireAcks, ackTimeoutMs, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendProduceRequest = function (payloads, requireAcks, ackTimeoutMs, cb) {
  var encoder = protocol.encodeProduceRequest(requireAcks, ackTimeoutMs);
  var decoder = protocol.decodeProduceResponse;
  var self = this;

  decoder.requireAcks = requireAcks;

  async.each(payloads, buildRequest, function (err) {
    if (err) return cb(err);
    self.send(payloads, encoder, decoder, function (err, result) {
      if (err) {
        if (err.message === 'NotLeaderForPartition') {
          self.emit('brokersChanged');
        }
        cb(err);
      } else {
        cb(null, result);
      }
    });
  });

  function buildRequest (payload, cb) {
    var attributes = payload.attributes;
    var codec = getCodec(attributes);

    if (!codec) return cb();

    var innerSet = encodeMessageSet(payload.messages);
    codec.encode(innerSet, function (err, message) {
      if (err) return cb(err);
      payload.messages = [ new Message(0, attributes, '', message) ];
      cb();
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendSyncGroupRequest" id="apidoc.element.kafka-node.Client.prototype.sendSyncGroupRequest">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendSyncGroupRequest
        <span class="apidocSignatureSpan">(groupId, generationId, memberId, groupAssignment, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendSyncGroupRequest = function (groupId, generationId, memberId, groupAssignment, cb) {
  this.sendGroupRequest(protocol.encodeSyncGroupRequest, protocol.decodeSyncGroupResponse, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendToBroker" id="apidoc.element.kafka-node.Client.prototype.sendToBroker">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendToBroker
        <span class="apidocSignatureSpan">(payloads, encoder, decoder, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendToBroker = function (payloads, encoder, decoder, cb) {
  var longpolling = encoder.name === 'encodeFetchRequest';
  payloads = this.payloadsByLeader(payloads);
  if (!longpolling) {
    cb = wrap(payloads, cb);
  }
  for (var leader in payloads) {
    if (!payloads.hasOwnProperty(leader)) {
      continue;
    }
    var correlationId = this.nextId();
    var request = encoder(this.clientId, correlationId, payloads[leader]);
    var broker = this.brokerForLeader(leader, longpolling);
    if (!broker || !broker.socket || broker.socket.error || broker.socket.closing || broker.socket.destroyed) {
      return cb(new errors.BrokerNotAvailableError('Could not find the leader'), payloads[leader]);
    }

    if (longpolling) {
      if (broker.socket.waiting) continue;
      broker.socket.waiting = true;
    }

    if (decoder.requireAcks === 0) {
      broker.writeAsync(request);
      cb(null, { result: 'no ack' });
    } else {
      this.queueCallback(broker.socket, correlationId, [decoder, cb]);
      broker.write(request);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.setupBroker" id="apidoc.element.kafka-node.Client.prototype.setupBroker">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>setupBroker
        <span class="apidocSignatureSpan">(host, port, longpolling, brokers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setupBroker = function (host, port, longpolling, brokers) {
  var brokerKey = host + ':' + port;
  brokers[brokerKey] = this.createBroker(host, port, longpolling);
  return brokers[brokerKey];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.setupBrokerProfiles" id="apidoc.element.kafka-node.Client.prototype.setupBrokerProfiles">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>setupBrokerProfiles
        <span class="apidocSignatureSpan">(brokers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setupBrokerProfiles = function (brokers) {
  this.brokerProfiles = Object.create(null);
  var self = this;
  var protocol = self.ssl ? 'ssl:' : 'plaintext:';

  Object.keys(brokers).forEach(function (key) {
    var brokerProfile = brokers[key];
    var addr;

    if (brokerProfile.endpoints &amp;&amp; brokerProfile.endpoints.length) {
      var endpoint = _.find(brokerProfile.endpoints, function (endpoint) {
        return url.parse(endpoint).protocol === protocol;
      });

      if (endpoint == null) {
        throw new Error(['No kafka endpoint found for broker: ', key, ' with protocol ', protocol].join(''));
      }

      var endpointUrl = url.parse(endpoint);

      addr = endpointUrl.hostname + ':' + endpointUrl.port;

      brokerProfile.host = endpointUrl.hostname;
      brokerProfile.port = endpointUrl.port;
    } else {
      addr = brokerProfile.host + ':' + brokerProfile.port;
    }
    assert(brokerProfile.host &amp;&amp; brokerProfile.port, 'kafka host or port is empty');

    self.brokerProfiles[addr] = brokerProfile;
    self.brokerProfiles[addr].id = key;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.topicExists" id="apidoc.element.kafka-node.Client.prototype.topicExists">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>topicExists
        <span class="apidocSignatureSpan">(topics, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">topicExists = function (topics, cb) {
  var notExistsTopics = [];
  var self = this;

  async.each(topics, checkZK, function (err) {
    if (err) return cb(err);
    if (notExistsTopics.length) return cb(new errors.TopicsNotExistError(notExistsTopics));
    cb();
  });

  function checkZK (topic, cb) {
    self.zk.topicExists(topic, function (err, existed, topic) {
      if (err) return cb(err);
      if (!existed) notExistsTopics.push(topic);
      cb();
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var path = '/brokers/topics/' + topic;
var self = this;
this.client.exists(
  path,
  function (event) {
    logger.debug('Got event: %s.', event);
    if (watch) {
      self.<span class="apidocCodeKeywordSpan">topicExists</span>(topic, cb);
    }
  },
  function (error, stat) {
    if (error) return cb(error);
    cb(null, !!stat, topic);
  }
);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.unqueueCallback" id="apidoc.element.kafka-node.Client.prototype.unqueueCallback">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>unqueueCallback
        <span class="apidocSignatureSpan">(socket, id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unqueueCallback = function (socket, id) {
  var socketId = socket.socketId;

  if (!this.cbqueue.hasOwnProperty(socketId)) {
    return null;
  }

  var queue = this.cbqueue[socketId];
  if (!queue.hasOwnProperty(id)) {
    return null;
  }

  var result = queue[id];

  // cleanup socket queue
  delete queue[id];
  if (!Object.keys(queue).length) {
    delete this.cbqueue[socketId];
  }

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.updateMetadatas" id="apidoc.element.kafka-node.Client.prototype.updateMetadatas">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>updateMetadatas
        <span class="apidocSignatureSpan">(metadatas)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateMetadatas = function (metadatas) {
  // _.extend(this.brokerMetadata, metadatas[0])
  _.extend(this.topicMetadata, metadatas[1].metadata);
  for (var topic in this.topicMetadata) {
    if (!this.topicMetadata.hasOwnProperty(topic)) {
      continue;
    }
    this.topicPartitions[topic] = Object.keys(this.topicMetadata[topic]).map(function (val) {
      return parseInt(val, 10);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Client.prototype.addTopics" id="apidoc.module.kafka-node.Client.prototype.addTopics">module kafka-node.Client.prototype.addTopics</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.addTopics.addTopics" id="apidoc.element.kafka-node.Client.prototype.addTopics.addTopics">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>addTopics
        <span class="apidocSignatureSpan">(topics, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addTopics = function (topics, cb) {
  var self = this;
  this.topicExists(topics, function (err) {
    if (err) return cb(err);
    self.loadMetadataForTopics(topics, function (err, resp) {
      if (err) return cb(err);
      self.updateMetadatas(resp);
      cb(null, topics);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `topics`: **Array**, array of topics to add
* `cb`: **Function**,the callback
* `fromOffset`: **Boolean**, if true, the consumer will fetch message from the specified offset, otherwise it will fetch message
 from the last commited offset of the topic.

Example:

``` js
consumer.<span class="apidocCodeKeywordSpan">addTopics</span>(['t1', 't2'], function (err, added) {
});

or

consumer.addTopics([{ topic: 't1', offset: 10 }], function (err, added) {
}, true);
```
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Client.prototype.brokerForLeader" id="apidoc.module.kafka-node.Client.prototype.brokerForLeader">module kafka-node.Client.prototype.brokerForLeader</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.brokerForLeader.brokerForLeader" id="apidoc.element.kafka-node.Client.prototype.brokerForLeader.brokerForLeader">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>brokerForLeader
        <span class="apidocSignatureSpan">(leader, longpolling)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">brokerForLeader = function (leader, longpolling) {
  var addr;
  var brokers = this.getBrokers(longpolling);
  // If leader is not give, choose the first broker as leader
  if (typeof leader === 'undefined') {
    if (!_.isEmpty(brokers)) {
      addr = Object.keys(brokers)[0];
      return brokers[addr];
    } else if (!_.isEmpty(this.brokerMetadata)) {
      leader = Object.keys(this.brokerMetadata)[0];
    } else {
      return;
    }
  }

  var broker = _.find(this.brokerProfiles, {id: leader});

  if (!broker) {
    return;
  }

  addr = broker.host + ':' + broker.port;

  return brokers[addr] || this.setupBroker(broker.host, broker.port, longpolling, brokers);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Client.prototype.checkMetadatas" id="apidoc.module.kafka-node.Client.prototype.checkMetadatas">module kafka-node.Client.prototype.checkMetadatas</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.checkMetadatas.checkMetadatas" id="apidoc.element.kafka-node.Client.prototype.checkMetadatas.checkMetadatas">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>checkMetadatas
        <span class="apidocSignatureSpan">(payloads)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkMetadatas = function (payloads) {
  if (_.isEmpty(this.topicMetadata)) return [ [], payloads ];
  // out: [ [metadata exists], [metadata not exists] ]
  var out = [ [], [] ];
  payloads.forEach(function (p) {
    if (this.hasMetadata(p.topic, p.partition)) out[0].push(p);
    else out[1].push(p);
  }.bind(this));
  return out;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Client.prototype.clearCallbackQueue" id="apidoc.module.kafka-node.Client.prototype.clearCallbackQueue">module kafka-node.Client.prototype.clearCallbackQueue</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.clearCallbackQueue.clearCallbackQueue" id="apidoc.element.kafka-node.Client.prototype.clearCallbackQueue.clearCallbackQueue">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>clearCallbackQueue
        <span class="apidocSignatureSpan">(socket, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearCallbackQueue = function (socket, error) {
  var socketId = socket.socketId;
  var longpolling = socket.longpolling;

  if (!this.cbqueue.hasOwnProperty(socketId)) {
    return;
  }

  var queue = this.cbqueue[socketId];

  if (!longpolling) {
    Object.keys(queue).forEach(function (key) {
      var handlers = queue[key];
      var cb = handlers[1];
      cb(error);
    });
  }
  delete this.cbqueue[socketId];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Client.prototype.close" id="apidoc.module.kafka-node.Client.prototype.close">module kafka-node.Client.prototype.close</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.close.close" id="apidoc.element.kafka-node.Client.prototype.close.close">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>close
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (cb) {
  this.closeBrokers(this.brokers);
  this.closeBrokers(this.longpollingBrokers);
  this.zk.close();
  cb &amp;&amp; cb();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### close(force, cb)
* `force`: **Boolean**, if set to true, it forces the consumer to commit the current offset before closing, default `false`

Example

```js
consumer.<span class="apidocCodeKeywordSpan">close</span>(true, cb);
consumer.close(cb); //force is disabled
```

## HighLevelConsumer
âš&nbsp;ï¸ ***This consumer has been deprecated in the latest version of Kafka (0.10.1) and is likely to be removed in the future. Please
 use the ConsumerGroup instead.***

### HighLevelConsumer(client, payloads, options)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Client.prototype.closeBrokers" id="apidoc.module.kafka-node.Client.prototype.closeBrokers">module kafka-node.Client.prototype.closeBrokers</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.closeBrokers.closeBrokers" id="apidoc.element.kafka-node.Client.prototype.closeBrokers.closeBrokers">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>closeBrokers
        <span class="apidocSignatureSpan">(brokers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">closeBrokers = function (brokers) {
  _.each(brokers, function (broker) {
    broker.socket.closing = true;
    broker.socket.end();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Client.prototype.connect" id="apidoc.module.kafka-node.Client.prototype.connect">module kafka-node.Client.prototype.connect</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.connect.connect" id="apidoc.element.kafka-node.Client.prototype.connect.connect">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>connect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connect = function () {
  var zk = this.zk = new Zookeeper(this.connectionString, this.zkOptions);
  var self = this;
  zk.once('init', function (brokers) {
    try {
      self.ready = true;
      self.brokerMetadata = brokers;
      self.setupBrokerProfiles(brokers);
      Object
          .keys(self.brokerProfiles)
          .some(function (key, index) {
            var broker = self.brokerProfiles[key];
            self.setupBroker(broker.host, broker.port, false, self.brokers);
            // Only connect one broker
            return !index;
          });
      self.emit('ready');
    } catch (error) {
      self.ready = false;
      self.emit('error', error);
    }
  });
  zk.on('brokersChanged', function (brokerMetadata) {
    try {
      self.brokerMetadata = brokerMetadata;
      logger.debug('brokersChanged', brokerMetadata);
      self.setupBrokerProfiles(brokerMetadata);
      self.refreshBrokers();
      // Emit after a 3 seconds
      setTimeout(function () {
        self.emit('brokersChanged');
      }, 3000);
    } catch (error) {
      self.emit('error', error);
    }
  });
  zk.once('disconnected', function () {
    if (!zk.closed) {
      zk.close();
      self.connect();
      self.emit('zkReconnect');
    }
  });
  zk.on('error', function (err) {
    self.emit('error', err);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    });

    this.on('topicOwnerChange', _.debounce(function (topics) {
      verified = 0;
      self.checkForOwnersAndListenForChange(topics);
    }, 250));

    this.zk.<span class="apidocCodeKeywordSpan">connect</span>();
  } else {
    this.connectConsumerGroup();
  }
}

util.inherits(ConsumerGroupMigrator, EventEmitter);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Client.prototype.createBroker" id="apidoc.module.kafka-node.Client.prototype.createBroker">module kafka-node.Client.prototype.createBroker</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.createBroker.createBroker" id="apidoc.element.kafka-node.Client.prototype.createBroker.createBroker">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>createBroker
        <span class="apidocSignatureSpan">(host, port, longpolling)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createBroker = function (host, port, longpolling) {
  var self = this;
  var socket;
  if (self.ssl) {
    socket = tls.connect(port, host, self.sslOptions);
  } else {
    socket = net.createConnection(port, host);
  }
  socket.addr = host + ':' + port;
  socket.host = host;
  socket.port = port;
  socket.socketId = this.nextSocketId();
  if (longpolling) socket.longpolling = true;

  socket.on('connect', function () {
    var lastError = this.error;
    this.error = null;
    if (lastError) {
      this.waiting = false;
      self.emit('reconnect');
    } else {
      self.emit('connect');
    }
  });
  socket.on('error', function (err) {
    this.error = err;
    self.emit('error', err);
  });
  socket.on('close', function (hadError) {
    self.emit('close', this);
    if (hadError &amp;&amp; this.error) {
      self.clearCallbackQueue(this, this.error);
    } else {
      self.clearCallbackQueue(this, new errors.BrokerNotAvailableError('Broker not available'));
    }
    retry(this);
  });
  socket.on('end', function () {
    retry(this);
  });
  socket.buffer = new Buffer([]);
  socket.on('data', function (data) {
    this.buffer = Buffer.concat([this.buffer, data]);
    self.handleReceivedData(this);
  });
  socket.setKeepAlive(true, 60000);

  function retry (s) {
    if (s.retrying || s.closing) return;
    s.retrying = true;
    s.retryTimer = setTimeout(function () {
      if (s.closing) return;
      self.reconnectBroker(s);
    }, 1000);
  }
  return new BrokerWrapper(socket, this.noAckBatchOptions);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Client.prototype.createTopics" id="apidoc.module.kafka-node.Client.prototype.createTopics">module kafka-node.Client.prototype.createTopics</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.createTopics.createTopics" id="apidoc.element.kafka-node.Client.prototype.createTopics.createTopics">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>createTopics
        <span class="apidocSignatureSpan">(topics, isAsync, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createTopics = function (topics, isAsync, cb) {
  topics = typeof topics === 'string' ? [topics] : topics;

  if (typeof isAsync === 'function' &amp;&amp; typeof cb === 'undefined') {
    cb = isAsync;
    isAsync = true;
  }

  try {
    validateKafkaTopics(topics);
  } catch (e) {
    if (isAsync) return cb(e);
    throw e;
  }

  cb = _.once(cb);

  const getTopicsFromKafka = (topics, callback) =&gt; {
    this.loadMetadataForTopics(topics, function (error, resp) {
      if (error) {
        return callback(error);
      }
      callback(null, Object.keys(resp[1].metadata));
    });
  };

  const operation = retry.operation({ minTimeout: 200, maxTimeout: 2000 });

  operation.attempt(currentAttempt =&gt; {
    logger.debug('create topics currentAttempt', currentAttempt);
    getTopicsFromKafka(topics, function (error, kafkaTopics) {
      if (error) {
        if (operation.retry(error)) {
          return;
        }
      }

      logger.debug('kafka reported topics', kafkaTopics);
      const left = _.difference(topics, kafkaTopics);
      if (left.length === 0) {
        logger.debug(`Topics created ${kafkaTopics}`);
        return cb(null, kafkaTopics);
      }

      logger.debug(`Topics left ${left.join(', ')}`);
      if (!operation.retry(new Error(`Topics not created ${left}`))) {
        cb(operation.mainError());
      }
    });
  });

  if (!isAsync) {
    cb(null);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

``` js
var kafka = require('kafka-node'),
    Producer = kafka.Producer,
    client = new kafka.Client(),
    producer = new Producer(client);
// Create topics sync
producer.<span class="apidocCodeKeywordSpan">createTopics</span>(['t','t1'], false, function (err, data) {
    console.log(data);
});
// Create topics async
producer.createTopics(['t'], true, function (err, data) {});
producer.createTopics(['t'], function (err, data) {});// Simply omit 2nd arg
```
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Client.prototype.getBrokers" id="apidoc.module.kafka-node.Client.prototype.getBrokers">module kafka-node.Client.prototype.getBrokers</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.getBrokers.getBrokers" id="apidoc.element.kafka-node.Client.prototype.getBrokers.getBrokers">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>getBrokers
        <span class="apidocSignatureSpan">(longpolling)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getBrokers = function (longpolling) {
  return longpolling ? this.longpollingBrokers : this.brokers;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Client.prototype.handleReceivedData" id="apidoc.module.kafka-node.Client.prototype.handleReceivedData">module kafka-node.Client.prototype.handleReceivedData</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.handleReceivedData.handleReceivedData" id="apidoc.element.kafka-node.Client.prototype.handleReceivedData.handleReceivedData">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>handleReceivedData
        <span class="apidocSignatureSpan">(socket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleReceivedData = function (socket) {
  var vars = Binary.parse(socket.buffer).word32bu('size').word32bu('correlationId').vars;
  var size = vars.size + 4;
  var correlationId = vars.correlationId;

  if (socket.buffer.length &gt;= size) {
    var resp = socket.buffer.slice(0, size);
    var handlers = this.unqueueCallback(socket, correlationId);

    if (!handlers) return;
    var decoder = handlers[0];
    var cb = handlers[1];
    var result = decoder(resp);
    (result instanceof Error)
      ? cb.call(this, result)
      : cb.call(this, null, result);
    socket.buffer = socket.buffer.slice(size);
    if (socket.longpolling) socket.waiting = false;
  } else { return; }

  if (socket.buffer.length) {
    setImmediate(function () { this.handleReceivedData(socket); }.bind(this));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Client.prototype.hasMetadata" id="apidoc.module.kafka-node.Client.prototype.hasMetadata">module kafka-node.Client.prototype.hasMetadata</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.hasMetadata.hasMetadata" id="apidoc.element.kafka-node.Client.prototype.hasMetadata.hasMetadata">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>hasMetadata
        <span class="apidocSignatureSpan">(topic, partition)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasMetadata = function (topic, partition) {
  var brokerMetadata = this.brokerMetadata;
  var leader = this.leaderByPartition(topic, partition);

  return (leader !== undefined) &amp;&amp; brokerMetadata[leader];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Client.prototype.leaderByPartition" id="apidoc.module.kafka-node.Client.prototype.leaderByPartition">module kafka-node.Client.prototype.leaderByPartition</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.leaderByPartition.leaderByPartition" id="apidoc.element.kafka-node.Client.prototype.leaderByPartition.leaderByPartition">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>leaderByPartition
        <span class="apidocSignatureSpan">(topic, partition)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">leaderByPartition = function (topic, partition) {
  var topicMetadata = this.topicMetadata;
  return topicMetadata[topic] &amp;&amp; topicMetadata[topic][partition] &amp;&amp; topicMetadata[topic][partition].leader;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Client.prototype.loadMetadataForTopics" id="apidoc.module.kafka-node.Client.prototype.loadMetadataForTopics">module kafka-node.Client.prototype.loadMetadataForTopics</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.loadMetadataForTopics.loadMetadataForTopics" id="apidoc.element.kafka-node.Client.prototype.loadMetadataForTopics.loadMetadataForTopics">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>loadMetadataForTopics
        <span class="apidocSignatureSpan">(topics, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadMetadataForTopics = function (topics, cb) {
  var correlationId = this.nextId();
  var request = protocol.encodeMetadataRequest(this.clientId, correlationId, topics);
  var broker = this.brokerForLeader();

  if (!broker || !broker.socket || broker.socket.error || broker.socket.destroyed) {
    return cb(new errors.BrokerNotAvailableError('Broker not available'));
  }

  this.queueCallback(broker.socket, correlationId, [protocol.decodeMetadataResponse, cb]);
  broker.write(request);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

## How do I get a list of all topics?

Call `client.loadMetadataForTopics` with a blank topic array to get the entire list of available topics (and available brokers).

```js
client.once('connect', function () {
	client.<span class="apidocCodeKeywordSpan">loadMetadataForTopics</span>([], function (error, results) {
	  if (error) {
	  	return console.error(error);
	  }
	  console.log('%j', _.get(results, '1.metadata'));
	});
});
```
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Client.prototype.nextId" id="apidoc.module.kafka-node.Client.prototype.nextId">module kafka-node.Client.prototype.nextId</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.nextId.nextId" id="apidoc.element.kafka-node.Client.prototype.nextId.nextId">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>nextId
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nextId = function () {
  if (this.correlationId &gt;= MAX_INT32) {
    this.correlationId = 0;
  }
  return this.correlationId++;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Client.prototype.nextSocketId" id="apidoc.module.kafka-node.Client.prototype.nextSocketId">module kafka-node.Client.prototype.nextSocketId</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.nextSocketId.nextSocketId" id="apidoc.element.kafka-node.Client.prototype.nextSocketId.nextSocketId">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>nextSocketId
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nextSocketId = function () {
  return this._socketId++;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Client.prototype.payloadsByLeader" id="apidoc.module.kafka-node.Client.prototype.payloadsByLeader">module kafka-node.Client.prototype.payloadsByLeader</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.payloadsByLeader.payloadsByLeader" id="apidoc.element.kafka-node.Client.prototype.payloadsByLeader.payloadsByLeader">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>payloadsByLeader
        <span class="apidocSignatureSpan">(payloads)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">payloadsByLeader = function (payloads) {
  return payloads.reduce(function (out, p) {
    var leader = this.leaderByPartition(p.topic, p.partition);
    out[leader] = out[leader] || [];
    out[leader].push(p);
    return out;
  }.bind(this), {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Client.prototype.queueCallback" id="apidoc.module.kafka-node.Client.prototype.queueCallback">module kafka-node.Client.prototype.queueCallback</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.queueCallback.queueCallback" id="apidoc.element.kafka-node.Client.prototype.queueCallback.queueCallback">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>queueCallback
        <span class="apidocSignatureSpan">(socket, id, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">queueCallback = function (socket, id, data) {
  var socketId = socket.socketId;
  var queue;

  if (this.cbqueue.hasOwnProperty(socketId)) {
    queue = this.cbqueue[socketId];
  } else {
    queue = {};
    this.cbqueue[socketId] = queue;
  }

  queue[id] = data;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Client.prototype.reconnectBroker" id="apidoc.module.kafka-node.Client.prototype.reconnectBroker">module kafka-node.Client.prototype.reconnectBroker</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.reconnectBroker.reconnectBroker" id="apidoc.element.kafka-node.Client.prototype.reconnectBroker.reconnectBroker">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>reconnectBroker
        <span class="apidocSignatureSpan">(oldSocket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reconnectBroker = function (oldSocket) {
  oldSocket.retrying = false;
  if (oldSocket.error) {
    oldSocket.destroy();
  }
  var brokers = this.getBrokers(oldSocket.longpolling);
  var newBroker = this.setupBroker(oldSocket.host, oldSocket.port, oldSocket.longpolling, brokers);
  newBroker.socket.error = oldSocket.error;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Client.prototype.refreshBrokers" id="apidoc.module.kafka-node.Client.prototype.refreshBrokers">module kafka-node.Client.prototype.refreshBrokers</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.refreshBrokers.refreshBrokers" id="apidoc.element.kafka-node.Client.prototype.refreshBrokers.refreshBrokers">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>refreshBrokers
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">refreshBrokers = function () {
  var self = this;
  var validBrokers = Object.keys(this.brokerProfiles);

  function closeDeadBrokers (brokers) {
    var deadBrokerKeys = _.difference(Object.keys(brokers), validBrokers);
    if (deadBrokerKeys.length) {
      self.closeBrokers(deadBrokerKeys.map(function (key) {
        var broker = brokers[key];
        delete brokers[key];
        return broker;
      }));
    }
  }

  closeDeadBrokers(this.brokers);
  closeDeadBrokers(this.longpollingBrokers);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Client.prototype.refreshMetadata" id="apidoc.module.kafka-node.Client.prototype.refreshMetadata">module kafka-node.Client.prototype.refreshMetadata</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.refreshMetadata.refreshMetadata" id="apidoc.element.kafka-node.Client.prototype.refreshMetadata.refreshMetadata">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>refreshMetadata
        <span class="apidocSignatureSpan">(topicNames, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">refreshMetadata = function (topicNames, cb) {
  var self = this;
  if (!topicNames.length) return cb();
  attemptRequestMetadata(topicNames, cb);

  function attemptRequestMetadata (topics, cb) {
    var operation = retry.operation({ minTimeout: 200, maxTimeout: 1000 });
    operation.attempt(function (currentAttempt) {
      logger.debug('refresh metadata currentAttempt', currentAttempt);
      self.loadMetadataForTopics(topics, function (err, resp) {
        err = err || resp[1].error;
        if (operation.retry(err)) {
          return;
        }
        if (err) {
          logger.debug('refresh metadata error', err.message);
          return cb(err);
        }
        self.updateMetadatas(resp);
        cb();
      });
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Error:

```
BrokerNotAvailableError: Could not find the leader
```

Call `client.<span class="apidocCodeKeywordSpan">refreshMetadata</span>()` before sending the first message. Reference issue [#354
](https://github.com/SOHU-Co/kafka-node/issues/354)



## How do I debug an issue?
This module uses the [debug module](https://github.com/visionmedia/debug) so you can just run below before starting your app.

```bash
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Client.prototype.removeTopicMetadata" id="apidoc.module.kafka-node.Client.prototype.removeTopicMetadata">module kafka-node.Client.prototype.removeTopicMetadata</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.removeTopicMetadata.removeTopicMetadata" id="apidoc.element.kafka-node.Client.prototype.removeTopicMetadata.removeTopicMetadata">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>removeTopicMetadata
        <span class="apidocSignatureSpan">(topics, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeTopicMetadata = function (topics, cb) {
  topics.forEach(function (t) {
    if (this.topicMetadata[t]) delete this.topicMetadata[t];
  }.bind(this));
  cb(null, topics.length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Client.prototype.send" id="apidoc.module.kafka-node.Client.prototype.send">module kafka-node.Client.prototype.send</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.send.send" id="apidoc.element.kafka-node.Client.prototype.send.send">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>send
        <span class="apidocSignatureSpan">(payloads, encoder, decoder, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">send = function (payloads, encoder, decoder, cb) {
  var self = this;
  var _payloads = payloads;
  // payloads: [ [metadata exists], [metadata not exists] ]
  payloads = this.checkMetadatas(payloads);
  if (payloads[0].length &amp;&amp; !payloads[1].length) {
    this.sendToBroker(_.flatten(payloads), encoder, decoder, cb);
    return;
  }
  if (payloads[1].length) {
    var topicNames = payloads[1].map(function (p) { return p.topic; });
    this.loadMetadataForTopics(topicNames, function (err, resp) {
      if (err) {
        return cb(err);
      }

      var error = resp[1].error;
      if (error) {
        return cb(error);
      }

      self.updateMetadatas(resp);
      // check payloads again
      payloads = self.checkMetadatas(_payloads);
      if (payloads[1].length) {
        return cb(new errors.BrokerNotAvailableError('Could not find the leader'));
      }

      self.sendToBroker(payloads[1].concat(payloads[0]), encoder, decoder, cb);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    producer = new Producer(client),
    km = new KeyedMessage('key', 'message'),
    payloads = [
        { topic: 'topic1', messages: 'hi', partition: 0 },
        { topic: 'topic2', messages: ['hello', 'world', km] }
    ];
producer.on('ready', function () {
    producer.<span class="apidocCodeKeywordSpan">send</span>(payloads, function (err, data) {
        console.log(data);
    });
});

producer.on('error', function (err) {})
```
&gt; âš&nbsp;ï¸**WARNING**: Batch multiple messages of the same topic/partition together as an array on the `messages` attribute otherwise
 you may lose messages!
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Client.prototype.sendFetchRequest" id="apidoc.module.kafka-node.Client.prototype.sendFetchRequest">module kafka-node.Client.prototype.sendFetchRequest</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendFetchRequest.sendFetchRequest" id="apidoc.element.kafka-node.Client.prototype.sendFetchRequest.sendFetchRequest">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendFetchRequest
        <span class="apidocSignatureSpan">(consumer, payloads, fetchMaxWaitMs, fetchMinBytes, maxTickMessages)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendFetchRequest = function (consumer, payloads, fetchMaxWaitMs, fetchMinBytes, maxTickMessages) {
  var self = this;
  var encoder = protocol.encodeFetchRequest(fetchMaxWaitMs, fetchMinBytes);
  var decoder = protocol.decodeFetchResponse(function (err, type, message) {
    if (err) {
      if (err.message === 'OffsetOutOfRange') {
        return consumer.emit('offsetOutOfRange', err);
      } else if (err.message === 'NotLeaderForPartition' || err.message === 'UnknownTopicOrPartition') {
        return self.emit('brokersChanged');
      }

      return consumer.emit('error', err);
    }

    var encoding = consumer.options.encoding;

    if (type === 'message') {
      if (encoding !== 'buffer' &amp;&amp; message.value) {
        message.value = message.value.toString(encoding);
      }

      consumer.emit('message', message);
    } else {
      consumer.emit('done', message);
    }
  }, maxTickMessages);

  this.send(payloads, encoder, decoder, function (err) {
    if (err) {
      Array.prototype.unshift.call(arguments, 'error');
      consumer.emit.apply(consumer, arguments);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Client.prototype.sendGroupCoordinatorRequest" id="apidoc.module.kafka-node.Client.prototype.sendGroupCoordinatorRequest">module kafka-node.Client.prototype.sendGroupCoordinatorRequest</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendGroupCoordinatorRequest.sendGroupCoordinatorRequest" id="apidoc.element.kafka-node.Client.prototype.sendGroupCoordinatorRequest.sendGroupCoordinatorRequest">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendGroupCoordinatorRequest
        <span class="apidocSignatureSpan">(groupId, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendGroupCoordinatorRequest = function (groupId, cb) {
  this.sendGroupRequest(protocol.encodeGroupCoordinatorRequest, protocol.decodeGroupCoordinatorResponse, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Client.prototype.sendGroupRequest" id="apidoc.module.kafka-node.Client.prototype.sendGroupRequest">module kafka-node.Client.prototype.sendGroupRequest</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendGroupRequest.sendGroupRequest" id="apidoc.element.kafka-node.Client.prototype.sendGroupRequest.sendGroupRequest">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendGroupRequest
        <span class="apidocSignatureSpan">(encode, decode, requestArgs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendGroupRequest = function (encode, decode, requestArgs) {
  requestArgs = _.values(requestArgs);
  var cb = requestArgs.pop();
  var correlationId = this.nextId();

  requestArgs.unshift(this.clientId, correlationId);

  var request = encode.apply(null, requestArgs);
  var broker = this.brokerForLeader(this.coordinatorId);

  if (!broker || !broker.socket || broker.socket.error || broker.socket.destroyed) {
    return cb(new errors.BrokerNotAvailableError('Broker not available'));
  }

  this.queueCallback(broker.socket, correlationId, [decode, cb]);
  broker.write(request);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Client.prototype.sendHeartbeatRequest" id="apidoc.module.kafka-node.Client.prototype.sendHeartbeatRequest">module kafka-node.Client.prototype.sendHeartbeatRequest</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendHeartbeatRequest.sendHeartbeatRequest" id="apidoc.element.kafka-node.Client.prototype.sendHeartbeatRequest.sendHeartbeatRequest">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendHeartbeatRequest
        <span class="apidocSignatureSpan">(groupId, generationId, memberId, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendHeartbeatRequest = function (groupId, generationId, memberId, cb) {
  this.sendGroupRequest(protocol.encodeGroupHeartbeat, protocol.decodeGroupHeartbeat, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
constructor (client, handler) {
  this.client = client;
  this.handler = handler;
  this.pending = true;
}

send (groupId, generationId, memberId) {
  this.client.<span class="apidocCodeKeywordSpan">sendHeartbeatRequest</span>(groupId, generationId, memberId, (error) =&gt; {
    if (this.canceled) {
      logger.debug('heartbeat yielded after being canceled', error);
      return;
    }
    this.pending = false;
    this.handler(error);
  });
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Client.prototype.sendJoinGroupRequest" id="apidoc.module.kafka-node.Client.prototype.sendJoinGroupRequest">module kafka-node.Client.prototype.sendJoinGroupRequest</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendJoinGroupRequest.sendJoinGroupRequest" id="apidoc.element.kafka-node.Client.prototype.sendJoinGroupRequest.sendJoinGroupRequest">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendJoinGroupRequest
        <span class="apidocSignatureSpan">(groupId, memberId, sessionTimeout, groupProtocol, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendJoinGroupRequest = function (groupId, memberId, sessionTimeout, groupProtocol, cb) {
  this.sendGroupRequest(protocol.encodeJoinGroupRequest, protocol.decodeJoinGroupResponse, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Client.prototype.sendLeaveGroupRequest" id="apidoc.module.kafka-node.Client.prototype.sendLeaveGroupRequest">module kafka-node.Client.prototype.sendLeaveGroupRequest</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendLeaveGroupRequest.sendLeaveGroupRequest" id="apidoc.element.kafka-node.Client.prototype.sendLeaveGroupRequest.sendLeaveGroupRequest">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendLeaveGroupRequest
        <span class="apidocSignatureSpan">(groupId, memberId, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendLeaveGroupRequest = function (groupId, memberId, cb) {
  this.sendGroupRequest(protocol.encodeLeaveGroupRequest, protocol.decodeLeaveGroupResponse, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Client.prototype.sendOffsetCommitRequest" id="apidoc.module.kafka-node.Client.prototype.sendOffsetCommitRequest">module kafka-node.Client.prototype.sendOffsetCommitRequest</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendOffsetCommitRequest.sendOffsetCommitRequest" id="apidoc.element.kafka-node.Client.prototype.sendOffsetCommitRequest.sendOffsetCommitRequest">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendOffsetCommitRequest
        <span class="apidocSignatureSpan">(group, payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendOffsetCommitRequest = function (group, payloads, cb) {
  var encoder = protocol.encodeOffsetCommitRequest(group);
  var decoder = protocol.decodeOffsetCommitResponse;
  this.send(payloads, encoder, decoder, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Client.prototype.sendOffsetCommitV2Request" id="apidoc.module.kafka-node.Client.prototype.sendOffsetCommitV2Request">module kafka-node.Client.prototype.sendOffsetCommitV2Request</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendOffsetCommitV2Request.sendOffsetCommitV2Request" id="apidoc.element.kafka-node.Client.prototype.sendOffsetCommitV2Request.sendOffsetCommitV2Request">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendOffsetCommitV2Request
        <span class="apidocSignatureSpan">(group, generationId, memberId, payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendOffsetCommitV2Request = function (group, generationId, memberId, payloads, cb) {
  var encoder = protocol.encodeOffsetCommitV2Request;
  var decoder = protocol.decodeOffsetCommitResponse;
  this.sendGroupRequest(encoder, decoder, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Client.prototype.sendOffsetFetchRequest" id="apidoc.module.kafka-node.Client.prototype.sendOffsetFetchRequest">module kafka-node.Client.prototype.sendOffsetFetchRequest</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendOffsetFetchRequest.sendOffsetFetchRequest" id="apidoc.element.kafka-node.Client.prototype.sendOffsetFetchRequest.sendOffsetFetchRequest">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendOffsetFetchRequest
        <span class="apidocSignatureSpan">(group, payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendOffsetFetchRequest = function (group, payloads, cb) {
  var encoder = protocol.encodeOffsetFetchRequest(group);
  var decoder = protocol.decodeOffsetFetchResponse;
  this.send(payloads, encoder, decoder, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }
);
};

ConsumerGroupMigrator.prototype.saveHighLevelConsumerOffsets = function (topicPartitionList, callback) {
const self = this;
this.client.<span class="apidocCodeKeywordSpan">sendOffsetFetchRequest</span>(this.consumerGroup.options.groupId, topicPartitionList
, function (error, results) {
  logger.debug('sendOffsetFetchRequest response:', results, error);
  if (error) {
    return callback(error);
  }
  self.offsets = results;
  callback(null);
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Client.prototype.sendOffsetFetchV1Request" id="apidoc.module.kafka-node.Client.prototype.sendOffsetFetchV1Request">module kafka-node.Client.prototype.sendOffsetFetchV1Request</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendOffsetFetchV1Request.sendOffsetFetchV1Request" id="apidoc.element.kafka-node.Client.prototype.sendOffsetFetchV1Request.sendOffsetFetchV1Request">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendOffsetFetchV1Request
        <span class="apidocSignatureSpan">(group, payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendOffsetFetchV1Request = function (group, payloads, cb) {
  var encoder = protocol.encodeOffsetFetchV1Request;
  var decoder = protocol.decodeOffsetFetchV1Response;
  this.sendGroupRequest(encoder, decoder, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Client.prototype.sendOffsetRequest" id="apidoc.module.kafka-node.Client.prototype.sendOffsetRequest">module kafka-node.Client.prototype.sendOffsetRequest</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendOffsetRequest.sendOffsetRequest" id="apidoc.element.kafka-node.Client.prototype.sendOffsetRequest.sendOffsetRequest">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendOffsetRequest
        <span class="apidocSignatureSpan">(payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendOffsetRequest = function (payloads, cb) {
  var encoder = protocol.encodeOffsetRequest;
  var decoder = protocol.decodeOffsetResponse;
  this.send(payloads, encoder, decoder, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Client.prototype.sendProduceRequest" id="apidoc.module.kafka-node.Client.prototype.sendProduceRequest">module kafka-node.Client.prototype.sendProduceRequest</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendProduceRequest.sendProduceRequest" id="apidoc.element.kafka-node.Client.prototype.sendProduceRequest.sendProduceRequest">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendProduceRequest
        <span class="apidocSignatureSpan">(payloads, requireAcks, ackTimeoutMs, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendProduceRequest = function (payloads, requireAcks, ackTimeoutMs, cb) {
  var encoder = protocol.encodeProduceRequest(requireAcks, ackTimeoutMs);
  var decoder = protocol.decodeProduceResponse;
  var self = this;

  decoder.requireAcks = requireAcks;

  async.each(payloads, buildRequest, function (err) {
    if (err) return cb(err);
    self.send(payloads, encoder, decoder, function (err, result) {
      if (err) {
        if (err.message === 'NotLeaderForPartition') {
          self.emit('brokersChanged');
        }
        cb(err);
      } else {
        cb(null, result);
      }
    });
  });

  function buildRequest (payload, cb) {
    var attributes = payload.attributes;
    var codec = getCodec(attributes);

    if (!codec) return cb();

    var innerSet = encodeMessageSet(payload.messages);
    codec.encode(innerSet, function (err, message) {
      if (err) return cb(err);
      payload.messages = [ new Message(0, attributes, '', message) ];
      cb();
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Client.prototype.sendSyncGroupRequest" id="apidoc.module.kafka-node.Client.prototype.sendSyncGroupRequest">module kafka-node.Client.prototype.sendSyncGroupRequest</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendSyncGroupRequest.sendSyncGroupRequest" id="apidoc.element.kafka-node.Client.prototype.sendSyncGroupRequest.sendSyncGroupRequest">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendSyncGroupRequest
        <span class="apidocSignatureSpan">(groupId, generationId, memberId, groupAssignment, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendSyncGroupRequest = function (groupId, generationId, memberId, groupAssignment, cb) {
  this.sendGroupRequest(protocol.encodeSyncGroupRequest, protocol.decodeSyncGroupResponse, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Client.prototype.sendToBroker" id="apidoc.module.kafka-node.Client.prototype.sendToBroker">module kafka-node.Client.prototype.sendToBroker</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendToBroker.sendToBroker" id="apidoc.element.kafka-node.Client.prototype.sendToBroker.sendToBroker">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendToBroker
        <span class="apidocSignatureSpan">(payloads, encoder, decoder, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendToBroker = function (payloads, encoder, decoder, cb) {
  var longpolling = encoder.name === 'encodeFetchRequest';
  payloads = this.payloadsByLeader(payloads);
  if (!longpolling) {
    cb = wrap(payloads, cb);
  }
  for (var leader in payloads) {
    if (!payloads.hasOwnProperty(leader)) {
      continue;
    }
    var correlationId = this.nextId();
    var request = encoder(this.clientId, correlationId, payloads[leader]);
    var broker = this.brokerForLeader(leader, longpolling);
    if (!broker || !broker.socket || broker.socket.error || broker.socket.closing || broker.socket.destroyed) {
      return cb(new errors.BrokerNotAvailableError('Could not find the leader'), payloads[leader]);
    }

    if (longpolling) {
      if (broker.socket.waiting) continue;
      broker.socket.waiting = true;
    }

    if (decoder.requireAcks === 0) {
      broker.writeAsync(request);
      cb(null, { result: 'no ack' });
    } else {
      this.queueCallback(broker.socket, correlationId, [decoder, cb]);
      broker.write(request);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Client.prototype.setupBroker" id="apidoc.module.kafka-node.Client.prototype.setupBroker">module kafka-node.Client.prototype.setupBroker</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.setupBroker.setupBroker" id="apidoc.element.kafka-node.Client.prototype.setupBroker.setupBroker">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>setupBroker
        <span class="apidocSignatureSpan">(host, port, longpolling, brokers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setupBroker = function (host, port, longpolling, brokers) {
  var brokerKey = host + ':' + port;
  brokers[brokerKey] = this.createBroker(host, port, longpolling);
  return brokers[brokerKey];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Client.prototype.setupBrokerProfiles" id="apidoc.module.kafka-node.Client.prototype.setupBrokerProfiles">module kafka-node.Client.prototype.setupBrokerProfiles</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.setupBrokerProfiles.setupBrokerProfiles" id="apidoc.element.kafka-node.Client.prototype.setupBrokerProfiles.setupBrokerProfiles">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>setupBrokerProfiles
        <span class="apidocSignatureSpan">(brokers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setupBrokerProfiles = function (brokers) {
  this.brokerProfiles = Object.create(null);
  var self = this;
  var protocol = self.ssl ? 'ssl:' : 'plaintext:';

  Object.keys(brokers).forEach(function (key) {
    var brokerProfile = brokers[key];
    var addr;

    if (brokerProfile.endpoints &amp;&amp; brokerProfile.endpoints.length) {
      var endpoint = _.find(brokerProfile.endpoints, function (endpoint) {
        return url.parse(endpoint).protocol === protocol;
      });

      if (endpoint == null) {
        throw new Error(['No kafka endpoint found for broker: ', key, ' with protocol ', protocol].join(''));
      }

      var endpointUrl = url.parse(endpoint);

      addr = endpointUrl.hostname + ':' + endpointUrl.port;

      brokerProfile.host = endpointUrl.hostname;
      brokerProfile.port = endpointUrl.port;
    } else {
      addr = brokerProfile.host + ':' + brokerProfile.port;
    }
    assert(brokerProfile.host &amp;&amp; brokerProfile.port, 'kafka host or port is empty');

    self.brokerProfiles[addr] = brokerProfile;
    self.brokerProfiles[addr].id = key;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Client.prototype.topicExists" id="apidoc.module.kafka-node.Client.prototype.topicExists">module kafka-node.Client.prototype.topicExists</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.topicExists.topicExists" id="apidoc.element.kafka-node.Client.prototype.topicExists.topicExists">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>topicExists
        <span class="apidocSignatureSpan">(topics, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">topicExists = function (topics, cb) {
  var notExistsTopics = [];
  var self = this;

  async.each(topics, checkZK, function (err) {
    if (err) return cb(err);
    if (notExistsTopics.length) return cb(new errors.TopicsNotExistError(notExistsTopics));
    cb();
  });

  function checkZK (topic, cb) {
    self.zk.topicExists(topic, function (err, existed, topic) {
      if (err) return cb(err);
      if (!existed) notExistsTopics.push(topic);
      cb();
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var path = '/brokers/topics/' + topic;
var self = this;
this.client.exists(
  path,
  function (event) {
    logger.debug('Got event: %s.', event);
    if (watch) {
      self.<span class="apidocCodeKeywordSpan">topicExists</span>(topic, cb);
    }
  },
  function (error, stat) {
    if (error) return cb(error);
    cb(null, !!stat, topic);
  }
);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Client.prototype.unqueueCallback" id="apidoc.module.kafka-node.Client.prototype.unqueueCallback">module kafka-node.Client.prototype.unqueueCallback</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.unqueueCallback.unqueueCallback" id="apidoc.element.kafka-node.Client.prototype.unqueueCallback.unqueueCallback">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>unqueueCallback
        <span class="apidocSignatureSpan">(socket, id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unqueueCallback = function (socket, id) {
  var socketId = socket.socketId;

  if (!this.cbqueue.hasOwnProperty(socketId)) {
    return null;
  }

  var queue = this.cbqueue[socketId];
  if (!queue.hasOwnProperty(id)) {
    return null;
  }

  var result = queue[id];

  // cleanup socket queue
  delete queue[id];
  if (!Object.keys(queue).length) {
    delete this.cbqueue[socketId];
  }

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Client.prototype.updateMetadatas" id="apidoc.module.kafka-node.Client.prototype.updateMetadatas">module kafka-node.Client.prototype.updateMetadatas</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.updateMetadatas.updateMetadatas" id="apidoc.element.kafka-node.Client.prototype.updateMetadatas.updateMetadatas">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>updateMetadatas
        <span class="apidocSignatureSpan">(metadatas)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateMetadatas = function (metadatas) {
  // _.extend(this.brokerMetadata, metadatas[0])
  _.extend(this.topicMetadata, metadatas[1].metadata);
  for (var topic in this.topicMetadata) {
    if (!this.topicMetadata.hasOwnProperty(topic)) {
      continue;
    }
    this.topicPartitions[topic] = Object.keys(this.topicMetadata[topic]).map(function (val) {
      return parseInt(val, 10);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Consumer" id="apidoc.module.kafka-node.Consumer">module kafka-node.Consumer</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.Consumer" id="apidoc.element.kafka-node.Consumer.Consumer">
        function <span class="apidocSignatureSpan">kafka-node.</span>Consumer
        <span class="apidocSignatureSpan">(client, topics, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Consumer = function (client, topics, options) {
  if (!topics) {
    throw new Error('Must have payloads');
  }

  utils.validateTopics(topics);

  this.fetchCount = 0;
  this.client = client;
  this.options = _.defaults((options || {}), DEFAULTS);
  this.ready = false;
  this.paused = this.options.paused;
  this.id = nextId();
  this.payloads = this.buildPayloads(topics);
  this.connect();
  this.encoding = this.options.encoding;

  if (this.options.groupId) {
    utils.validateConfig('options.groupId', this.options.groupId);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.super_" id="apidoc.element.kafka-node.Consumer.super_">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Consumer.prototype" id="apidoc.module.kafka-node.Consumer.prototype">module kafka-node.Consumer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.addTopics" id="apidoc.element.kafka-node.Consumer.prototype.addTopics">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>addTopics
        <span class="apidocSignatureSpan">(topics, cb, fromOffset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addTopics = function (topics, cb, fromOffset) {
  fromOffset = !!fromOffset;
  var self = this;
  if (!this.ready) {
    setTimeout(function () {
      self.addTopics(topics, cb, fromOffset);
    }
    , 100);
    return;
  }

  // The default is that the topics is a string array of topic names
  var topicNames = topics;

  // If the topics is actually an object and not string we assume it is an array of payloads
  if (typeof topics[0] === 'object') {
    topicNames = topics.map(function (p) { return p.topic; });
  }

  this.client.addTopics(
    topicNames,
    function (err, added) {
      if (err) return cb &amp;&amp; cb(err, added);

      var payloads = self.buildPayloads(topics);
      var reFetch = !self.payloads.length;

      if (fromOffset) {
        payloads.forEach(function (p) {
          self.payloads.push(p);
        });
        if (reFetch) self.fetch();
        cb &amp;&amp; cb(null, added);
        return;
      }

      // update offset of topics that will be added
      self.fetchOffset(payloads, function (err, offsets) {
        if (err) return cb(err);
        payloads.forEach(function (p) {
          var offset = offsets[p.topic][p.partition];
          if (offset === -1) offset = 0;
          p.offset = offset;
          self.payloads.push(p);
        });
        if (reFetch) self.fetch();
        cb &amp;&amp; cb(null, added);
      });
    }
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `topics`: **Array**, array of topics to add
* `cb`: **Function**,the callback
* `fromOffset`: **Boolean**, if true, the consumer will fetch message from the specified offset, otherwise it will fetch message
 from the last commited offset of the topic.

Example:

``` js
consumer.<span class="apidocCodeKeywordSpan">addTopics</span>(['t1', 't2'], function (err, added) {
});

or

consumer.addTopics([{ topic: 't1', offset: 10 }], function (err, added) {
}, true);
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.autoCommit" id="apidoc.element.kafka-node.Consumer.prototype.autoCommit">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>autoCommit
        <span class="apidocSignatureSpan">(force, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function autoCommit(force, cb) {
  if (arguments.length === 1) {
    cb = force;
    force = false;
  }

  if (this.committing &amp;&amp; !force) return cb(null, 'Offset committing');

  this.committing = true;
  setTimeout(function () {
    this.committing = false;
  }.bind(this), this.options.autoCommitIntervalMs);

  var payloads = this.payloads;
  if (this.pausedPayloads) payloads = payloads.concat(this.pausedPayloads);

  var commits = payloads.filter(function (p) { return p.offset !== 0; });
  if (commits.length) {
    this.client.sendOffsetCommitRequest(this.options.groupId, commits, cb);
  } else {
    cb(null, 'Nothing to be committed');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.buildPayloads" id="apidoc.element.kafka-node.Consumer.prototype.buildPayloads">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>buildPayloads
        <span class="apidocSignatureSpan">(payloads)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildPayloads = function (payloads) {
  var self = this;
  return payloads.map(function (p) {
    if (typeof p !== 'object') p = { topic: p };
    p.partition = p.partition || 0;
    p.offset = p.offset || 0;
    p.maxBytes = self.options.fetchMaxBytes;
    p.metadata = 'm'; // metadata can be arbitrary
    return p;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.close" id="apidoc.element.kafka-node.Consumer.prototype.close">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>close
        <span class="apidocSignatureSpan">(force, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (force, cb) {
  this.ready = false;
  if (typeof force === 'function') {
    cb = force;
    force = false;
  }

  if (force) {
    this.commit(force, function (err) {
      if (err) {
        return cb(err);
      }
      this.client.close(cb);
    }.bind(this));
  } else {
    this.client.close(cb);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### close(force, cb)
* `force`: **Boolean**, if set to true, it forces the consumer to commit the current offset before closing, default `false`

Example

```js
consumer.<span class="apidocCodeKeywordSpan">close</span>(true, cb);
consumer.close(cb); //force is disabled
```

## HighLevelConsumer
âš&nbsp;ï¸ ***This consumer has been deprecated in the latest version of Kafka (0.10.1) and is likely to be removed in the future. Please
 use the ConsumerGroup instead.***

### HighLevelConsumer(client, payloads, options)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.commit" id="apidoc.element.kafka-node.Consumer.prototype.commit">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>commit
        <span class="apidocSignatureSpan">(force, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function autoCommit(force, cb) {
  if (arguments.length === 1) {
    cb = force;
    force = false;
  }

  if (this.committing &amp;&amp; !force) return cb(null, 'Offset committing');

  this.committing = true;
  setTimeout(function () {
    this.committing = false;
  }.bind(this), this.options.autoCommitIntervalMs);

  var payloads = this.payloads;
  if (this.pausedPayloads) payloads = payloads.concat(this.pausedPayloads);

  var commits = payloads.filter(function (p) { return p.offset !== 0; });
  if (commits.length) {
    this.client.sendOffsetCommitRequest(this.options.groupId, commits, cb);
  } else {
    cb(null, 'Nothing to be committed');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Commit offset of the current topics manually, this method should be called when a consumer leaves

* `cb`: **Function**, the callback

Example:

``` js
consumer.<span class="apidocCodeKeywordSpan">commit</span>(function(err, data) {
});
```

### setOffset(topic, partition, offset)
Set offset of the given topic

* `topic`: **String**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.connect" id="apidoc.element.kafka-node.Consumer.prototype.connect">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>connect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connect = function () {
  var self = this;
  // Client already exists
  this.ready = this.client.ready;
  if (this.ready) this.init();

  this.client.on('ready', function () {
    logger.debug('consumer ready');
    if (!self.ready) self.init();
    self.ready = true;
  });

  this.client.on('error', function (err) {
    logger.error('client error %s', err.message);
    self.emit('error', err);
  });

  this.client.on('close', function () {
    logger.debug('connection closed');
  });

  this.client.on('brokersChanged', function () {
    var topicNames = self.payloads.map(function (p) {
      return p.topic;
    });

    this.refreshMetadata(topicNames, function (err) {
      if (err) return self.emit('error', err);
      self.fetch();
    });
  });
  // 'done' will be emit when a message fetch request complete
  this.on('done', function (topics) {
    self.updateOffsets(topics);
    setImmediate(function () {
      self.fetch();
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    });

    this.on('topicOwnerChange', _.debounce(function (topics) {
      verified = 0;
      self.checkForOwnersAndListenForChange(topics);
    }, 250));

    this.zk.<span class="apidocCodeKeywordSpan">connect</span>();
  } else {
    this.connectConsumerGroup();
  }
}

util.inherits(ConsumerGroupMigrator, EventEmitter);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.fetch" id="apidoc.element.kafka-node.Consumer.prototype.fetch">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>fetch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetch = function () {
  if (!this.ready || this.paused) return;
  this.client.sendFetchRequest(this, this.payloads, this.options.fetchMaxWaitMs, this.options.fetchMinBytes);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Example

```js
var kafka = require('kafka-node'),
    client = new kafka.Client(),
    offset = new kafka.Offset(client);
    offset.<span class="apidocCodeKeywordSpan">fetch</span>([
        { topic: 't', partition: 0, time: Date.now(), maxNum: 1 }
    ], function (err, data) {
        // data
        // { 't': { '0': [999] } }
    });
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.fetchOffset" id="apidoc.element.kafka-node.Consumer.prototype.fetchOffset">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>fetchOffset
        <span class="apidocSignatureSpan">(payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetchOffset = function (payloads, cb) {
  this.client.sendOffsetFetchRequest(this.options.groupId, payloads, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.init" id="apidoc.element.kafka-node.Consumer.prototype.init">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>init
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init = function () {
  if (!this.payloads.length) {
    return;
  }

  var self = this;
  var topics = self.payloads.map(function (p) { return p.topic; });

  self.client.topicExists(topics, function (err) {
    if (err) {
      return self.emit('error', err);
    }

    if (self.options.fromOffset) {
      return self.fetch();
    }

    self.fetchOffset(self.payloads, function (err, topics) {
      if (err) {
        return self.emit('error', err);
      }

      self.updateOffsets(topics, true);
      self.fetch();
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.pause" id="apidoc.element.kafka-node.Consumer.prototype.pause">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>pause
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pause = function () {
  this.paused = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.pauseTopics" id="apidoc.element.kafka-node.Consumer.prototype.pauseTopics">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>pauseTopics
        <span class="apidocSignatureSpan">(topics)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pauseTopics = function (topics) {
  if (!this.pausedPayloads) this.pausedPayloads = [];
  pauseOrResume(this.payloads, this.pausedPayloads, topics);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### resume()
Resume the consumer. Resumes the fetch loop.

### pauseTopics(topics)
Pause specify topics

```
consumer.<span class="apidocCodeKeywordSpan">pauseTopics</span>([
    'topic1',
    { topic: 'topic2', partition: 0 }
]);
```

### resumeTopics(topics)
Resume specify topics
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.removeTopics" id="apidoc.element.kafka-node.Consumer.prototype.removeTopics">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>removeTopics
        <span class="apidocSignatureSpan">(topics, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeTopics = function (topics, cb) {
  topics = typeof topics === 'string' ? [topics] : topics;
  this.payloads = this.payloads.filter(function (p) {
    return !~topics.indexOf(p.topic);
  });

  this.client.removeTopicMetadata(topics, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### removeTopics(topics, cb)
* `topics`: **Array**, array of topics to remove
* `cb`: **Function**, the callback

Example:

``` js
consumer.<span class="apidocCodeKeywordSpan">removeTopics</span>(['t1', 't2'], function (err, removed) {
});
```

### commit(cb)
Commit offset of the current topics manually, this method should be called when a consumer leaves

* `cb`: **Function**, the callback
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.resume" id="apidoc.element.kafka-node.Consumer.prototype.resume">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>resume
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resume = function () {
  this.paused = false;
  this.fetch();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.resumeTopics" id="apidoc.element.kafka-node.Consumer.prototype.resumeTopics">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>resumeTopics
        <span class="apidocSignatureSpan">(topics)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resumeTopics = function (topics) {
  if (!this.pausedPayloads) this.pausedPayloads = [];
  var reFetch = !this.payloads.length;
  pauseOrResume(this.pausedPayloads, this.payloads, topics);
  reFetch = reFetch &amp;&amp; this.payloads.length;
  if (reFetch) this.fetch();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
]);
```

### resumeTopics(topics)
Resume specify topics

```
consumer.<span class="apidocCodeKeywordSpan">resumeTopics</span>([
    'topic1',
    { topic: 'topic2', partition: 0 }
]);
```

### close(force, cb)
* `force`: **Boolean**, if set to true, it forces the consumer to commit the current offset before closing, default `false`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.setOffset" id="apidoc.element.kafka-node.Consumer.prototype.setOffset">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>setOffset
        <span class="apidocSignatureSpan">(topic, partition, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setOffset = function (topic, partition, offset) {
  this.payloads.every(function (p) {
    if (p.topic === topic &amp;&amp; p.partition == partition) { // eslint-disable-line eqeqeq
      p.offset = offset;
      return false;
    }
    return true;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `partition`: **Number**

* `offset`: **Number**

Example:

``` js
consumer.<span class="apidocCodeKeywordSpan">setOffset</span>('topic', 0, 0);
```

### pause()
Pause the consumer. ***Calling `pause` does not automatically stop messages from being emitted.*** This is because pause just stops
 the kafka consumer fetch loop. Each iteration of the fetch loop can obtain a batch of messages (limited by `fetchMaxBytes`).

### resume()
Resume the consumer. Resumes the fetch loop.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.updateOffsets" id="apidoc.element.kafka-node.Consumer.prototype.updateOffsets">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>updateOffsets
        <span class="apidocSignatureSpan">(topics, initing)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateOffsets = function (topics, initing) {
  this.payloads.forEach(function (p) {
    if (!_.isEmpty(topics[p.topic]) &amp;&amp; topics[p.topic][p.partition] !== undefined) {
      var offset = topics[p.topic][p.partition];
      if (offset === -1) offset = 0;
      if (!initing) p.offset = offset + 1;
      else p.offset = offset;
    }
  });

  if (this.options.autoCommit &amp;&amp; !initing) {
    this.autoCommit(false, function (err) {
      err &amp;&amp; logger.debug('auto commit offset', err);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Consumer.prototype.addTopics" id="apidoc.module.kafka-node.Consumer.prototype.addTopics">module kafka-node.Consumer.prototype.addTopics</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.addTopics.addTopics" id="apidoc.element.kafka-node.Consumer.prototype.addTopics.addTopics">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>addTopics
        <span class="apidocSignatureSpan">(topics, cb, fromOffset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addTopics = function (topics, cb, fromOffset) {
  fromOffset = !!fromOffset;
  var self = this;
  if (!this.ready) {
    setTimeout(function () {
      self.addTopics(topics, cb, fromOffset);
    }
    , 100);
    return;
  }

  // The default is that the topics is a string array of topic names
  var topicNames = topics;

  // If the topics is actually an object and not string we assume it is an array of payloads
  if (typeof topics[0] === 'object') {
    topicNames = topics.map(function (p) { return p.topic; });
  }

  this.client.addTopics(
    topicNames,
    function (err, added) {
      if (err) return cb &amp;&amp; cb(err, added);

      var payloads = self.buildPayloads(topics);
      var reFetch = !self.payloads.length;

      if (fromOffset) {
        payloads.forEach(function (p) {
          self.payloads.push(p);
        });
        if (reFetch) self.fetch();
        cb &amp;&amp; cb(null, added);
        return;
      }

      // update offset of topics that will be added
      self.fetchOffset(payloads, function (err, offsets) {
        if (err) return cb(err);
        payloads.forEach(function (p) {
          var offset = offsets[p.topic][p.partition];
          if (offset === -1) offset = 0;
          p.offset = offset;
          self.payloads.push(p);
        });
        if (reFetch) self.fetch();
        cb &amp;&amp; cb(null, added);
      });
    }
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `topics`: **Array**, array of topics to add
* `cb`: **Function**,the callback
* `fromOffset`: **Boolean**, if true, the consumer will fetch message from the specified offset, otherwise it will fetch message
 from the last commited offset of the topic.

Example:

``` js
consumer.<span class="apidocCodeKeywordSpan">addTopics</span>(['t1', 't2'], function (err, added) {
});

or

consumer.addTopics([{ topic: 't1', offset: 10 }], function (err, added) {
}, true);
```
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Consumer.prototype.autoCommit" id="apidoc.module.kafka-node.Consumer.prototype.autoCommit">module kafka-node.Consumer.prototype.autoCommit</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.autoCommit.autoCommit" id="apidoc.element.kafka-node.Consumer.prototype.autoCommit.autoCommit">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>autoCommit
        <span class="apidocSignatureSpan">(force, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function autoCommit(force, cb) {
  if (arguments.length === 1) {
    cb = force;
    force = false;
  }

  if (this.committing &amp;&amp; !force) return cb(null, 'Offset committing');

  this.committing = true;
  setTimeout(function () {
    this.committing = false;
  }.bind(this), this.options.autoCommitIntervalMs);

  var payloads = this.payloads;
  if (this.pausedPayloads) payloads = payloads.concat(this.pausedPayloads);

  var commits = payloads.filter(function (p) { return p.offset !== 0; });
  if (commits.length) {
    this.client.sendOffsetCommitRequest(this.options.groupId, commits, cb);
  } else {
    cb(null, 'Nothing to be committed');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Consumer.prototype.buildPayloads" id="apidoc.module.kafka-node.Consumer.prototype.buildPayloads">module kafka-node.Consumer.prototype.buildPayloads</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.buildPayloads.buildPayloads" id="apidoc.element.kafka-node.Consumer.prototype.buildPayloads.buildPayloads">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>buildPayloads
        <span class="apidocSignatureSpan">(payloads)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildPayloads = function (payloads) {
  var self = this;
  return payloads.map(function (p) {
    if (typeof p !== 'object') p = { topic: p };
    p.partition = p.partition || 0;
    p.offset = p.offset || 0;
    p.maxBytes = self.options.fetchMaxBytes;
    p.metadata = 'm'; // metadata can be arbitrary
    return p;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Consumer.prototype.close" id="apidoc.module.kafka-node.Consumer.prototype.close">module kafka-node.Consumer.prototype.close</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.close.close" id="apidoc.element.kafka-node.Consumer.prototype.close.close">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>close
        <span class="apidocSignatureSpan">(force, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (force, cb) {
  this.ready = false;
  if (typeof force === 'function') {
    cb = force;
    force = false;
  }

  if (force) {
    this.commit(force, function (err) {
      if (err) {
        return cb(err);
      }
      this.client.close(cb);
    }.bind(this));
  } else {
    this.client.close(cb);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### close(force, cb)
* `force`: **Boolean**, if set to true, it forces the consumer to commit the current offset before closing, default `false`

Example

```js
consumer.<span class="apidocCodeKeywordSpan">close</span>(true, cb);
consumer.close(cb); //force is disabled
```

## HighLevelConsumer
âš&nbsp;ï¸ ***This consumer has been deprecated in the latest version of Kafka (0.10.1) and is likely to be removed in the future. Please
 use the ConsumerGroup instead.***

### HighLevelConsumer(client, payloads, options)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Consumer.prototype.connect" id="apidoc.module.kafka-node.Consumer.prototype.connect">module kafka-node.Consumer.prototype.connect</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.connect.connect" id="apidoc.element.kafka-node.Consumer.prototype.connect.connect">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>connect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connect = function () {
  var self = this;
  // Client already exists
  this.ready = this.client.ready;
  if (this.ready) this.init();

  this.client.on('ready', function () {
    logger.debug('consumer ready');
    if (!self.ready) self.init();
    self.ready = true;
  });

  this.client.on('error', function (err) {
    logger.error('client error %s', err.message);
    self.emit('error', err);
  });

  this.client.on('close', function () {
    logger.debug('connection closed');
  });

  this.client.on('brokersChanged', function () {
    var topicNames = self.payloads.map(function (p) {
      return p.topic;
    });

    this.refreshMetadata(topicNames, function (err) {
      if (err) return self.emit('error', err);
      self.fetch();
    });
  });
  // 'done' will be emit when a message fetch request complete
  this.on('done', function (topics) {
    self.updateOffsets(topics);
    setImmediate(function () {
      self.fetch();
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    });

    this.on('topicOwnerChange', _.debounce(function (topics) {
      verified = 0;
      self.checkForOwnersAndListenForChange(topics);
    }, 250));

    this.zk.<span class="apidocCodeKeywordSpan">connect</span>();
  } else {
    this.connectConsumerGroup();
  }
}

util.inherits(ConsumerGroupMigrator, EventEmitter);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Consumer.prototype.fetch" id="apidoc.module.kafka-node.Consumer.prototype.fetch">module kafka-node.Consumer.prototype.fetch</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.fetch.fetch" id="apidoc.element.kafka-node.Consumer.prototype.fetch.fetch">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>fetch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetch = function () {
  if (!this.ready || this.paused) return;
  this.client.sendFetchRequest(this, this.payloads, this.options.fetchMaxWaitMs, this.options.fetchMinBytes);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Example

```js
var kafka = require('kafka-node'),
    client = new kafka.Client(),
    offset = new kafka.Offset(client);
    offset.<span class="apidocCodeKeywordSpan">fetch</span>([
        { topic: 't', partition: 0, time: Date.now(), maxNum: 1 }
    ], function (err, data) {
        // data
        // { 't': { '0': [999] } }
    });
```
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Consumer.prototype.fetchOffset" id="apidoc.module.kafka-node.Consumer.prototype.fetchOffset">module kafka-node.Consumer.prototype.fetchOffset</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.fetchOffset.fetchOffset" id="apidoc.element.kafka-node.Consumer.prototype.fetchOffset.fetchOffset">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>fetchOffset
        <span class="apidocSignatureSpan">(payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetchOffset = function (payloads, cb) {
  this.client.sendOffsetFetchRequest(this.options.groupId, payloads, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Consumer.prototype.init" id="apidoc.module.kafka-node.Consumer.prototype.init">module kafka-node.Consumer.prototype.init</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.init.init" id="apidoc.element.kafka-node.Consumer.prototype.init.init">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>init
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init = function () {
  if (!this.payloads.length) {
    return;
  }

  var self = this;
  var topics = self.payloads.map(function (p) { return p.topic; });

  self.client.topicExists(topics, function (err) {
    if (err) {
      return self.emit('error', err);
    }

    if (self.options.fromOffset) {
      return self.fetch();
    }

    self.fetchOffset(self.payloads, function (err, topics) {
      if (err) {
        return self.emit('error', err);
      }

      self.updateOffsets(topics, true);
      self.fetch();
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Consumer.prototype.pause" id="apidoc.module.kafka-node.Consumer.prototype.pause">module kafka-node.Consumer.prototype.pause</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.pause.pause" id="apidoc.element.kafka-node.Consumer.prototype.pause.pause">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>pause
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pause = function () {
  this.paused = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Consumer.prototype.pauseTopics" id="apidoc.module.kafka-node.Consumer.prototype.pauseTopics">module kafka-node.Consumer.prototype.pauseTopics</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.pauseTopics.pauseTopics" id="apidoc.element.kafka-node.Consumer.prototype.pauseTopics.pauseTopics">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>pauseTopics
        <span class="apidocSignatureSpan">(topics)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pauseTopics = function (topics) {
  if (!this.pausedPayloads) this.pausedPayloads = [];
  pauseOrResume(this.payloads, this.pausedPayloads, topics);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### resume()
Resume the consumer. Resumes the fetch loop.

### pauseTopics(topics)
Pause specify topics

```
consumer.<span class="apidocCodeKeywordSpan">pauseTopics</span>([
    'topic1',
    { topic: 'topic2', partition: 0 }
]);
```

### resumeTopics(topics)
Resume specify topics
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Consumer.prototype.removeTopics" id="apidoc.module.kafka-node.Consumer.prototype.removeTopics">module kafka-node.Consumer.prototype.removeTopics</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.removeTopics.removeTopics" id="apidoc.element.kafka-node.Consumer.prototype.removeTopics.removeTopics">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>removeTopics
        <span class="apidocSignatureSpan">(topics, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeTopics = function (topics, cb) {
  topics = typeof topics === 'string' ? [topics] : topics;
  this.payloads = this.payloads.filter(function (p) {
    return !~topics.indexOf(p.topic);
  });

  this.client.removeTopicMetadata(topics, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### removeTopics(topics, cb)
* `topics`: **Array**, array of topics to remove
* `cb`: **Function**, the callback

Example:

``` js
consumer.<span class="apidocCodeKeywordSpan">removeTopics</span>(['t1', 't2'], function (err, removed) {
});
```

### commit(cb)
Commit offset of the current topics manually, this method should be called when a consumer leaves

* `cb`: **Function**, the callback
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Consumer.prototype.resume" id="apidoc.module.kafka-node.Consumer.prototype.resume">module kafka-node.Consumer.prototype.resume</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.resume.resume" id="apidoc.element.kafka-node.Consumer.prototype.resume.resume">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>resume
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resume = function () {
  this.paused = false;
  this.fetch();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Consumer.prototype.resumeTopics" id="apidoc.module.kafka-node.Consumer.prototype.resumeTopics">module kafka-node.Consumer.prototype.resumeTopics</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.resumeTopics.resumeTopics" id="apidoc.element.kafka-node.Consumer.prototype.resumeTopics.resumeTopics">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>resumeTopics
        <span class="apidocSignatureSpan">(topics)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resumeTopics = function (topics) {
  if (!this.pausedPayloads) this.pausedPayloads = [];
  var reFetch = !this.payloads.length;
  pauseOrResume(this.pausedPayloads, this.payloads, topics);
  reFetch = reFetch &amp;&amp; this.payloads.length;
  if (reFetch) this.fetch();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
]);
```

### resumeTopics(topics)
Resume specify topics

```
consumer.<span class="apidocCodeKeywordSpan">resumeTopics</span>([
    'topic1',
    { topic: 'topic2', partition: 0 }
]);
```

### close(force, cb)
* `force`: **Boolean**, if set to true, it forces the consumer to commit the current offset before closing, default `false`
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Consumer.prototype.setOffset" id="apidoc.module.kafka-node.Consumer.prototype.setOffset">module kafka-node.Consumer.prototype.setOffset</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.setOffset.setOffset" id="apidoc.element.kafka-node.Consumer.prototype.setOffset.setOffset">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>setOffset
        <span class="apidocSignatureSpan">(topic, partition, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setOffset = function (topic, partition, offset) {
  this.payloads.every(function (p) {
    if (p.topic === topic &amp;&amp; p.partition == partition) { // eslint-disable-line eqeqeq
      p.offset = offset;
      return false;
    }
    return true;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `partition`: **Number**

* `offset`: **Number**

Example:

``` js
consumer.<span class="apidocCodeKeywordSpan">setOffset</span>('topic', 0, 0);
```

### pause()
Pause the consumer. ***Calling `pause` does not automatically stop messages from being emitted.*** This is because pause just stops
 the kafka consumer fetch loop. Each iteration of the fetch loop can obtain a batch of messages (limited by `fetchMaxBytes`).

### resume()
Resume the consumer. Resumes the fetch loop.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Consumer.prototype.updateOffsets" id="apidoc.module.kafka-node.Consumer.prototype.updateOffsets">module kafka-node.Consumer.prototype.updateOffsets</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.updateOffsets.updateOffsets" id="apidoc.element.kafka-node.Consumer.prototype.updateOffsets.updateOffsets">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>updateOffsets
        <span class="apidocSignatureSpan">(topics, initing)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateOffsets = function (topics, initing) {
  this.payloads.forEach(function (p) {
    if (!_.isEmpty(topics[p.topic]) &amp;&amp; topics[p.topic][p.partition] !== undefined) {
      var offset = topics[p.topic][p.partition];
      if (offset === -1) offset = 0;
      if (!initing) p.offset = offset + 1;
      else p.offset = offset;
    }
  });

  if (this.options.autoCommit &amp;&amp; !initing) {
    this.autoCommit(false, function (err) {
      err &amp;&amp; logger.debug('auto commit offset', err);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.ConsumerGroup" id="apidoc.module.kafka-node.ConsumerGroup">module kafka-node.ConsumerGroup</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.ConsumerGroup" id="apidoc.element.kafka-node.ConsumerGroup.ConsumerGroup">
        function <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup
        <span class="apidocSignatureSpan">(memberOptions, topics)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ConsumerGroup(memberOptions, topics) {
  EventEmitter.call(this);
  const self = this;
  this.options = _.defaults((memberOptions || {}), DEFAULTS);

  if (!this.options.heartbeatInterval) {
    this.options.heartbeatInterval = Math.floor(this.options.sessionTimeout / 3);
  }

  if (memberOptions.ssl === true) {
    memberOptions.ssl = {};
  }

  if (!(this.options.fromOffset in ACCEPTED_FROM_OFFSET)) {
    throw new Error(`fromOffset ${this.options.fromOffset} should be either: ${Object.keys(ACCEPTED_FROM_OFFSET).join(', ')}`);
  }

  if (!(this.options.outOfRangeOffset in ACCEPTED_FROM_OFFSET)) {
    throw new Error(`outOfRangeOffset ${this.options.outOfRangeOffset} should be either: ${Object.keys(ACCEPTED_FROM_OFFSET).join
(', ')}`);
  }

  this.client = new Client(memberOptions.host, memberOptions.id, memberOptions.zk,
    memberOptions.batch, memberOptions.ssl);

  if (_.isString(topics)) {
    topics = [topics];
  }

  assert(Array.isArray(topics), 'Array of topics is required');

  this.topics = topics;

  this.recovery = new ConsumerGroupRecovery(this);

  this.setupProtocols(this.options.protocol);

  if (this.options.connectOnReady &amp;&amp; !this.options.migrateHLC) {
    this.client.once('ready', this.connect.bind(this));
  }

  if (this.options.migrateHLC) {
    const ConsumerGroupMigrator = require('./consumerGroupMigrator');
    this.migrator = new ConsumerGroupMigrator(this);
    this.migrator.on('error', function (error) {
      self.emit('error', error);
    });
  }

  this.client.on('error', function (err) {
    logger.error('Error from %s', self.client.clientId, err);
    self.emit('error', err);
  });

  const recoverFromBrokerChange = _.debounce(function () {
    logger.debug('brokersChanged refreshing metadata');
    self.client.refreshMetadata(self.topics, function (error) {
      if (error) {
        self.emit(error);
        return;
      }
      self.paused = false;
      if (!self.ready &amp;&amp; !self.connecting) {
        if (self.reconnectTimer) {
          // brokers changed so bypass backoff retry and reconnect now
          clearTimeout(self.reconnectTimer);
          self.reconnectTimer = null;
        }
        self.connect();
      } else if (!self.connecting) {
        self.fetch();
      }
    });
  }, 200);

  this.client.on('brokersChanged', function () {
    self.pause();
    recoverFromBrokerChange();
  });

  this.client.on('reconnect', function (lastError) {
    self.fetch();
  });

  this.on('offsetOutOfRange', topic =&gt; {
    this.pause();
    if (this.options.outOfRangeOffset === 'none') {
      this.emit('error', new errors.InvalidConsumerOffsetError(`Offset out of range for topic "${topic.topic}" partition ${topic
.partition}`));
      return;
    }

    topic.time = ACCEPTED_FROM_OFFSET[this.options.outOfRangeOffset];

    this.getOffset().fetch([topic], (error, result) =&gt; {
      if (error) {
        this.emit('error', new errors.InvalidConsumerOffsetError(`Fetching ${this.options.outOfRangeOffset} offset failed`, error
));
        return;
      }
      const offset = _.head(result[topic.topic][topic.partition]);
      const oldOffset = _.find(this.topicPayloads, {topic: topic.topic, partition: topic.partition}).offset;

      logger.debug('replacing %s-%s stale offset of %d with %d', topic.topic, topic.partition, oldOffset, offset);

      this.setOffset(topic.topic, topic.partition, offset);
      this.resume();
    });
  });

  // 'done' will be emit when a message fetch request complete
  this.on('done', function (topics) {
    self.updateOffsets(topics);
    if (!self.paused) {
      setImmediate(function () {
        self.fetch();
      });
    }
  });

  if (this.options.groupId) {
    validateConfig('options.groupId', this.options.groupId);
  }

  this.isLeader = false;
  this.coordinatorId = null;
  this.generationId = null;
  this.ready = false;
  this.topicPayloads = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.super_" id="apidoc.element.kafka-node.ConsumerGroup.super_">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.</span>super_
        <span class="apidocSignatureSpan">(client, topics, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function (client, topics, options) {
  if (!topics) {
    throw new Error('Must have payloads');
  }
  this.fetchCount = 0;
  this.client = client;
  this.options = _.defaults((options || {}), DEFAULTS);
  this.initialised = false;
  this.ready = false;
  this.closing = false;
  this.paused = this.options.paused;
  this.rebalancing = false;
  this.pendingRebalances = 0;
  this.committing = false;
  this.needToCommit = false;
  this.id = this.options.id || this.options.groupId + '_' + uuid.v4();
  this.payloads = this.buildPayloads(topics);
  this.topicPayloads = this.buildTopicPayloads(topics);
  this.connect();

  if (this.options.groupId) {
    validateConfig('options.groupId', this.options.groupId);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.ConsumerGroup.prototype" id="apidoc.module.kafka-node.ConsumerGroup.prototype">module kafka-node.ConsumerGroup.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.assignPartitions" id="apidoc.element.kafka-node.ConsumerGroup.prototype.assignPartitions">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>assignPartitions
        <span class="apidocSignatureSpan">(protocol, groupMembers, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assignPartitions = function (protocol, groupMembers, callback) {
  logger.debug('Assigning Partitions to members', groupMembers);
  logger.debug('Using group protocol', protocol);

  protocol = _.find(this.protocols, {name: protocol});

  var self = this;
  var topics = _(groupMembers).map('subscription').flatten().uniq().value();

  async.waterfall([
    function (callback) {
      logger.debug('loadingMetadata for topics:', topics);
      self.client.loadMetadataForTopics(topics, callback);
    },

    function (metadataResponse, callback) {
      var metadata = mapTopicToPartitions(metadataResponse[1].metadata);
      logger.debug('mapTopicToPartitions', metadata);
      protocol.assign(metadata, groupMembers, callback);
    }
  ], callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.close" id="apidoc.element.kafka-node.ConsumerGroup.prototype.close">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>close
        <span class="apidocSignatureSpan">(force, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (force, cb) {
  var self = this;
  this.ready = false;

  this.stopHeartbeats();

  if (typeof force === 'function') {
    cb = force;
    force = false;
  }

  async.series([
    function (callback) {
      if (force) {
        self.commit(true, callback);
        return;
      }
      callback(null);
    },
    function (callback) {
      self.leaveGroup(function (error) {
        if (error) {
          logger.error('Leave group failed with', error);
        }
        callback(null);
      });
    },
    function (callback) {
      self.client.close(callback);
    }
  ], cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### close(force, cb)
* `force`: **Boolean**, if set to true, it forces the consumer to commit the current offset before closing, default `false`

Example

```js
consumer.<span class="apidocCodeKeywordSpan">close</span>(true, cb);
consumer.close(cb); //force is disabled
```

## HighLevelConsumer
âš&nbsp;ï¸ ***This consumer has been deprecated in the latest version of Kafka (0.10.1) and is likely to be removed in the future. Please
 use the ConsumerGroup instead.***

### HighLevelConsumer(client, payloads, options)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.connect" id="apidoc.element.kafka-node.ConsumerGroup.prototype.connect">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>connect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connect = function () {
  if (this.connecting) {
    logger.warn('Connect ignored. Currently connecting.');
    return;
  }

  logger.debug('Connecting %s', this.client.clientId);
  var self = this;

  this.connecting = true;
  this.emit('rebalancing');

  async.waterfall([
    function (callback) {
      if (self.client.coordinatorId) {
        return callback(null, null);
      }
      self.client.sendGroupCoordinatorRequest(self.options.groupId, callback);
    },

    function (coordinatorInfo, callback) {
      logger.debug('GroupCoordinator Response:', coordinatorInfo);
      if (coordinatorInfo) {
        self.setCoordinatorId(coordinatorInfo.coordinatorId);
      }
      self.client.sendJoinGroupRequest(self.options.groupId, emptyStrIfNull(self.memberId), self.options.sessionTimeout, self.protocols
, callback);
    },

    function (joinGroupResponse, callback) {
      self.handleJoinGroup(joinGroupResponse, callback);
    },

    function (groupAssignment, callback) {
      logger.debug('SyncGroup Request from %s', self.memberId);
      self.client.sendSyncGroupRequest(self.options.groupId, self.generationId, self.memberId, groupAssignment, callback);
    },

    function (syncGroupResponse, callback) {
      self.handleSyncGroup(syncGroupResponse, callback);
    }
  ], function (error, startFetch) {
    self.connecting = false;
    self.rebalancing = false;
    if (error) {
      return self.recovery.tryToRecoverFrom(error, 'connect');
    }

    self.ready = true;
    self.recovery.clearError();

    logger.debug('generationId', self.generationId);

    if (startFetch) {
      self.fetch();
    }
    self.startHeartbeats();
    self.emit('connect');
    self.emit('rebalanced');
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    });

    this.on('topicOwnerChange', _.debounce(function (topics) {
      verified = 0;
      self.checkForOwnersAndListenForChange(topics);
    }, 250));

    this.zk.<span class="apidocCodeKeywordSpan">connect</span>();
  } else {
    this.connectConsumerGroup();
  }
}

util.inherits(ConsumerGroupMigrator, EventEmitter);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.fetchOffset" id="apidoc.element.kafka-node.ConsumerGroup.prototype.fetchOffset">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>fetchOffset
        <span class="apidocSignatureSpan">(payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetchOffset = function (payloads, cb) {
  this.client.sendOffsetFetchV1Request(this.options.groupId, payloads, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.getDefaultOffset" id="apidoc.element.kafka-node.ConsumerGroup.prototype.getDefaultOffset">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>getDefaultOffset
        <span class="apidocSignatureSpan">(tp, defaultOffset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDefaultOffset = function (tp, defaultOffset) {
  return _.get(this.defaultOffsets, [tp.topic, tp.partition], defaultOffset);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.getOffset" id="apidoc.element.kafka-node.ConsumerGroup.prototype.getOffset">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>getOffset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOffset = function () {
  if (this.offset) {
    return this.offset;
  }
  this.offset = new Offset(this.client);
  // we can ignore this since we are already forwarding error event emitted from client
  this.offset.on('error', _.noop);
  return this.offset;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.handleJoinGroup" id="apidoc.element.kafka-node.ConsumerGroup.prototype.handleJoinGroup">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>handleJoinGroup
        <span class="apidocSignatureSpan">(joinGroupResponse, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleJoinGroup = function (joinGroupResponse, callback) {
  logger.debug('joinGroupResponse %j from %s', joinGroupResponse, this.client.clientId);

  this.isLeader = (joinGroupResponse.leaderId === joinGroupResponse.memberId);
  this.generationId = joinGroupResponse.generationId;
  this.memberId = joinGroupResponse.memberId;

  var groupAssignment;
  if (this.isLeader) {
    // assign partitions
    return this.assignPartitions(joinGroupResponse.groupProtocol, joinGroupResponse.members, callback);
  }
  callback(null, groupAssignment);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.handleSyncGroup" id="apidoc.element.kafka-node.ConsumerGroup.prototype.handleSyncGroup">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>handleSyncGroup
        <span class="apidocSignatureSpan">(syncGroupResponse, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleSyncGroup = function (syncGroupResponse, callback) {
  logger.debug('SyncGroup Response');
  var self = this;
  var ownedTopics = Object.keys(syncGroupResponse.partitions);
  if (ownedTopics.length) {
    logger.debug('%s owns topics: ', self.client.clientId, syncGroupResponse.partitions);

    const topicPartitionList = createTopicPartitionList(syncGroupResponse.partitions);
    const useDefaultOffsets = self.options.fromOffset in ACCEPTED_FROM_OFFSET;

    async.waterfall([
      function (callback) {
        self.fetchOffset(syncGroupResponse.partitions, callback);
      },
      function (offsets, callback) {
        logger.debug('%s fetchOffset Response: %j', self.client.clientId, offsets);

        var noOffset = topicPartitionList.some(function (tp) {
          return offsets[tp.topic][tp.partition] === -1;
        });

        if (noOffset) {
          logger.debug('No saved offsets');

          if (self.options.fromOffset === 'none') {
            return callback(new Error(`${self.client.clientId} owns topics and partitions which contains no saved offsets for group
 '${self.options.groupId}'`));
          }

          async.parallel([
            function (callback) {
              if (self.migrator) {
                return self.migrator.saveHighLevelConsumerOffsets(topicPartitionList, callback);
              }
              callback(null);
            },
            function (callback) {
              if (useDefaultOffsets) {
                return self.saveDefaultOffsets(topicPartitionList, callback);
              }
              callback(null);
            }
          ], function (error) {
            if (error) {
              return callback(error);
            }
            logger.debug('%s defaultOffset Response for %s: %j', self.client.clientId, self.options.fromOffset, self.defaultOffsets
);
            callback(null, offsets);
          });
        } else {
          logger.debug('Has saved offsets');
          callback(null, offsets);
        }
      },
      function (offsets, callback) {
        self.topicPayloads = self.buildPayloads(topicPartitionList).map(function (p) {
          var offset = offsets[p.topic][p.partition];
          if (offset === -1) { // -1 means no offset was saved for this topic/partition combo
            offset = useDefaultOffsets ? self.getDefaultOffset(p, 0) : 0;
            if (self.migrator) {
              offset = self.migrator.getOffset(p, offset);
            }
          }
          p.offset = offset;
          return p;
        });
        callback(null, true);
      }
    ], callback);
  } else { // no partitions assigned
    callback(null, false);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.leaveGroup" id="apidoc.element.kafka-node.ConsumerGroup.prototype.leaveGroup">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>leaveGroup
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">leaveGroup = function (callback) {
  logger.debug('%s leaving group', this.client.clientId);
  var self = this;
  this.stopHeartbeats();
  if (self.generationId != null &amp;&amp; self.memberId) {
    this.client.sendLeaveGroupRequest(this.options.groupId, this.memberId, function (error) {
      self.generationId = null;
      callback(error);
    });
  } else {
    callback(null);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.saveDefaultOffsets" id="apidoc.element.kafka-node.ConsumerGroup.prototype.saveDefaultOffsets">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>saveDefaultOffsets
        <span class="apidocSignatureSpan">(topicPartitionList, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">saveDefaultOffsets = function (topicPartitionList, callback) {
  var self = this;
  const offsetPayload = _(topicPartitionList).cloneDeep().map(tp =&gt; {
    tp.time = ACCEPTED_FROM_OFFSET[this.options.fromOffset];
    return tp;
  });

  self.getOffset().fetch(offsetPayload, function (error, result) {
    if (error) {
      return callback(error);
    }
    self.defaultOffsets = _.mapValues(result, function (partitionOffsets) {
      return _.mapValues(partitionOffsets, _.head);
    });
    callback(null);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.scheduleReconnect" id="apidoc.element.kafka-node.ConsumerGroup.prototype.scheduleReconnect">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>scheduleReconnect
        <span class="apidocSignatureSpan">(timeout)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scheduleReconnect = function (timeout) {
  assert(timeout);
  this.rebalancing = true;

  if (this.reconnectTimer) {
    clearTimeout(this.reconnectTimer);
  }

  var self = this;
  this.reconnectTimer = setTimeout(function () {
    self.reconnectTimer = null;
    self.connect();
  }, timeout);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  if (retry) {
    retryTimeout = this.getRetryTimeout(error);
  }

  if (retry &amp;&amp; retryTimeout) {
    logger.debug('RECOVERY from %s: %s retrying in %s ms', source, this.consumerGroup.client.clientId, retryTimeout, error
);
    this.consumerGroup.<span class="apidocCodeKeywordSpan">scheduleReconnect</span>(retryTimeout);
  } else {
    this.consumerGroup.emit('error', error);
  }
  this.lastError = error;
};

ConsumerGroupRecovery.prototype.clearError = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.sendHeartbeat" id="apidoc.element.kafka-node.ConsumerGroup.prototype.sendHeartbeat">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>sendHeartbeat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendHeartbeat = function () {
  assert(this.memberId, 'invalid memberId');
  assert(this.generationId &gt;= 0, 'invalid generationId');
  // logger.debug('%s â¤ï¸  -&gt;', this.client.clientId);
  var self = this;

  function heartbeatCallback (error) {
    if (error) {
      logger.warn('%s Heartbeat error:', self.client.clientId, error);
      self.recovery.tryToRecoverFrom(error, 'heartbeat');
    }
    // logger.debug('%s ðŸ’š &lt;-', self.client.clientId, error);
  }

  const heartbeat = new Heartbeat(this.client, heartbeatCallback);
  heartbeat.send(this.options.groupId, this.generationId, this.memberId);

  return heartbeat;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.sendOffsetCommitRequest" id="apidoc.element.kafka-node.ConsumerGroup.prototype.sendOffsetCommitRequest">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>sendOffsetCommitRequest
        <span class="apidocSignatureSpan">(commits, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendOffsetCommitRequest = function (commits, cb) {
  if (this.generationId &amp;&amp; this.memberId) {
    this.client.sendOffsetCommitV2Request(this.options.groupId, this.generationId, this.memberId, commits, cb);
  } else {
    cb(null, 'Nothing to be committed');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.setCoordinatorId" id="apidoc.element.kafka-node.ConsumerGroup.prototype.setCoordinatorId">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>setCoordinatorId
        <span class="apidocSignatureSpan">(coordinatorId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setCoordinatorId = function (coordinatorId) {
  this.client.coordinatorId = String(coordinatorId);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.setupProtocols" id="apidoc.element.kafka-node.ConsumerGroup.prototype.setupProtocols">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>setupProtocols
        <span class="apidocSignatureSpan">(protocols)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setupProtocols = function (protocols) {
  if (!Array.isArray(protocols)) {
    protocols = [protocols];
  }

  this.protocols = protocols.map(function (protocol) {
    if (typeof protocol === 'string') {
      if (!(protocol in builtInProtocols)) {
        throw new Error('Unknown built in assignment protocol ' + protocol);
      }
      protocol = _.assign({}, builtInProtocols[protocol]);
    } else {
      checkProtocol(protocol);
    }

    protocol.subscription = this.topics;
    return protocol;
  }, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.startHeartbeats" id="apidoc.element.kafka-node.ConsumerGroup.prototype.startHeartbeats">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>startHeartbeats
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">startHeartbeats = function () {
  assert(this.options.sessionTimeout &gt; 0);
  assert(this.ready, 'consumerGroup is not ready');

  const heartbeatIntervalMs = this.options.heartbeatInterval || (Math.floor(this.options.sessionTimeout / 3));

  logger.debug('%s started heartbeats at every %d ms', this.client.clientId, heartbeatIntervalMs);
  this.stopHeartbeats();

  let heartbeat = this.sendHeartbeat();

  this.heartbeatInterval = setInterval(() =&gt; {
    // only send another heartbeat if we got a response from the last one
    if (heartbeat.verifyResolved()) {
      heartbeat = this.sendHeartbeat();
    }
  }, heartbeatIntervalMs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.stopHeartbeats" id="apidoc.element.kafka-node.ConsumerGroup.prototype.stopHeartbeats">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>stopHeartbeats
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stopHeartbeats = function () {
  this.heartbeatInterval &amp;&amp; clearInterval(this.heartbeatInterval);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function ConsumerGroupRecovery (consumerGroup) {
this.consumerGroup = consumerGroup;
this.options = consumerGroup.options;
}

ConsumerGroupRecovery.prototype.tryToRecoverFrom = function (error, source) {
this.consumerGroup.ready = false;
this.consumerGroup.<span class="apidocCodeKeywordSpan">stopHeartbeats</span>();

var retryTimeout = false;
var retry = recoverableErrors.some(function (recoverableItem) {
  if (isErrorInstanceOf(error, recoverableItem.errors)) {
    recoverableItem.handler &amp;&amp; recoverableItem.handler.call(this.consumerGroup, error);
    return true;
  }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.ConsumerGroup.prototype.assignPartitions" id="apidoc.module.kafka-node.ConsumerGroup.prototype.assignPartitions">module kafka-node.ConsumerGroup.prototype.assignPartitions</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.assignPartitions.assignPartitions" id="apidoc.element.kafka-node.ConsumerGroup.prototype.assignPartitions.assignPartitions">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>assignPartitions
        <span class="apidocSignatureSpan">(protocol, groupMembers, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assignPartitions = function (protocol, groupMembers, callback) {
  logger.debug('Assigning Partitions to members', groupMembers);
  logger.debug('Using group protocol', protocol);

  protocol = _.find(this.protocols, {name: protocol});

  var self = this;
  var topics = _(groupMembers).map('subscription').flatten().uniq().value();

  async.waterfall([
    function (callback) {
      logger.debug('loadingMetadata for topics:', topics);
      self.client.loadMetadataForTopics(topics, callback);
    },

    function (metadataResponse, callback) {
      var metadata = mapTopicToPartitions(metadataResponse[1].metadata);
      logger.debug('mapTopicToPartitions', metadata);
      protocol.assign(metadata, groupMembers, callback);
    }
  ], callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.ConsumerGroup.prototype.close" id="apidoc.module.kafka-node.ConsumerGroup.prototype.close">module kafka-node.ConsumerGroup.prototype.close</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.close.close" id="apidoc.element.kafka-node.ConsumerGroup.prototype.close.close">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>close
        <span class="apidocSignatureSpan">(force, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (force, cb) {
  var self = this;
  this.ready = false;

  this.stopHeartbeats();

  if (typeof force === 'function') {
    cb = force;
    force = false;
  }

  async.series([
    function (callback) {
      if (force) {
        self.commit(true, callback);
        return;
      }
      callback(null);
    },
    function (callback) {
      self.leaveGroup(function (error) {
        if (error) {
          logger.error('Leave group failed with', error);
        }
        callback(null);
      });
    },
    function (callback) {
      self.client.close(callback);
    }
  ], cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### close(force, cb)
* `force`: **Boolean**, if set to true, it forces the consumer to commit the current offset before closing, default `false`

Example

```js
consumer.<span class="apidocCodeKeywordSpan">close</span>(true, cb);
consumer.close(cb); //force is disabled
```

## HighLevelConsumer
âš&nbsp;ï¸ ***This consumer has been deprecated in the latest version of Kafka (0.10.1) and is likely to be removed in the future. Please
 use the ConsumerGroup instead.***

### HighLevelConsumer(client, payloads, options)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.ConsumerGroup.prototype.connect" id="apidoc.module.kafka-node.ConsumerGroup.prototype.connect">module kafka-node.ConsumerGroup.prototype.connect</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.connect.connect" id="apidoc.element.kafka-node.ConsumerGroup.prototype.connect.connect">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>connect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connect = function () {
  if (this.connecting) {
    logger.warn('Connect ignored. Currently connecting.');
    return;
  }

  logger.debug('Connecting %s', this.client.clientId);
  var self = this;

  this.connecting = true;
  this.emit('rebalancing');

  async.waterfall([
    function (callback) {
      if (self.client.coordinatorId) {
        return callback(null, null);
      }
      self.client.sendGroupCoordinatorRequest(self.options.groupId, callback);
    },

    function (coordinatorInfo, callback) {
      logger.debug('GroupCoordinator Response:', coordinatorInfo);
      if (coordinatorInfo) {
        self.setCoordinatorId(coordinatorInfo.coordinatorId);
      }
      self.client.sendJoinGroupRequest(self.options.groupId, emptyStrIfNull(self.memberId), self.options.sessionTimeout, self.protocols
, callback);
    },

    function (joinGroupResponse, callback) {
      self.handleJoinGroup(joinGroupResponse, callback);
    },

    function (groupAssignment, callback) {
      logger.debug('SyncGroup Request from %s', self.memberId);
      self.client.sendSyncGroupRequest(self.options.groupId, self.generationId, self.memberId, groupAssignment, callback);
    },

    function (syncGroupResponse, callback) {
      self.handleSyncGroup(syncGroupResponse, callback);
    }
  ], function (error, startFetch) {
    self.connecting = false;
    self.rebalancing = false;
    if (error) {
      return self.recovery.tryToRecoverFrom(error, 'connect');
    }

    self.ready = true;
    self.recovery.clearError();

    logger.debug('generationId', self.generationId);

    if (startFetch) {
      self.fetch();
    }
    self.startHeartbeats();
    self.emit('connect');
    self.emit('rebalanced');
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    });

    this.on('topicOwnerChange', _.debounce(function (topics) {
      verified = 0;
      self.checkForOwnersAndListenForChange(topics);
    }, 250));

    this.zk.<span class="apidocCodeKeywordSpan">connect</span>();
  } else {
    this.connectConsumerGroup();
  }
}

util.inherits(ConsumerGroupMigrator, EventEmitter);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.ConsumerGroup.prototype.fetchOffset" id="apidoc.module.kafka-node.ConsumerGroup.prototype.fetchOffset">module kafka-node.ConsumerGroup.prototype.fetchOffset</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.fetchOffset.fetchOffset" id="apidoc.element.kafka-node.ConsumerGroup.prototype.fetchOffset.fetchOffset">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>fetchOffset
        <span class="apidocSignatureSpan">(payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetchOffset = function (payloads, cb) {
  this.client.sendOffsetFetchV1Request(this.options.groupId, payloads, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.ConsumerGroup.prototype.getDefaultOffset" id="apidoc.module.kafka-node.ConsumerGroup.prototype.getDefaultOffset">module kafka-node.ConsumerGroup.prototype.getDefaultOffset</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.getDefaultOffset.getDefaultOffset" id="apidoc.element.kafka-node.ConsumerGroup.prototype.getDefaultOffset.getDefaultOffset">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>getDefaultOffset
        <span class="apidocSignatureSpan">(tp, defaultOffset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDefaultOffset = function (tp, defaultOffset) {
  return _.get(this.defaultOffsets, [tp.topic, tp.partition], defaultOffset);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.ConsumerGroup.prototype.getOffset" id="apidoc.module.kafka-node.ConsumerGroup.prototype.getOffset">module kafka-node.ConsumerGroup.prototype.getOffset</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.getOffset.getOffset" id="apidoc.element.kafka-node.ConsumerGroup.prototype.getOffset.getOffset">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>getOffset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOffset = function () {
  if (this.offset) {
    return this.offset;
  }
  this.offset = new Offset(this.client);
  // we can ignore this since we are already forwarding error event emitted from client
  this.offset.on('error', _.noop);
  return this.offset;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.ConsumerGroup.prototype.handleJoinGroup" id="apidoc.module.kafka-node.ConsumerGroup.prototype.handleJoinGroup">module kafka-node.ConsumerGroup.prototype.handleJoinGroup</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.handleJoinGroup.handleJoinGroup" id="apidoc.element.kafka-node.ConsumerGroup.prototype.handleJoinGroup.handleJoinGroup">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>handleJoinGroup
        <span class="apidocSignatureSpan">(joinGroupResponse, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleJoinGroup = function (joinGroupResponse, callback) {
  logger.debug('joinGroupResponse %j from %s', joinGroupResponse, this.client.clientId);

  this.isLeader = (joinGroupResponse.leaderId === joinGroupResponse.memberId);
  this.generationId = joinGroupResponse.generationId;
  this.memberId = joinGroupResponse.memberId;

  var groupAssignment;
  if (this.isLeader) {
    // assign partitions
    return this.assignPartitions(joinGroupResponse.groupProtocol, joinGroupResponse.members, callback);
  }
  callback(null, groupAssignment);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.ConsumerGroup.prototype.handleSyncGroup" id="apidoc.module.kafka-node.ConsumerGroup.prototype.handleSyncGroup">module kafka-node.ConsumerGroup.prototype.handleSyncGroup</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.handleSyncGroup.handleSyncGroup" id="apidoc.element.kafka-node.ConsumerGroup.prototype.handleSyncGroup.handleSyncGroup">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>handleSyncGroup
        <span class="apidocSignatureSpan">(syncGroupResponse, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleSyncGroup = function (syncGroupResponse, callback) {
  logger.debug('SyncGroup Response');
  var self = this;
  var ownedTopics = Object.keys(syncGroupResponse.partitions);
  if (ownedTopics.length) {
    logger.debug('%s owns topics: ', self.client.clientId, syncGroupResponse.partitions);

    const topicPartitionList = createTopicPartitionList(syncGroupResponse.partitions);
    const useDefaultOffsets = self.options.fromOffset in ACCEPTED_FROM_OFFSET;

    async.waterfall([
      function (callback) {
        self.fetchOffset(syncGroupResponse.partitions, callback);
      },
      function (offsets, callback) {
        logger.debug('%s fetchOffset Response: %j', self.client.clientId, offsets);

        var noOffset = topicPartitionList.some(function (tp) {
          return offsets[tp.topic][tp.partition] === -1;
        });

        if (noOffset) {
          logger.debug('No saved offsets');

          if (self.options.fromOffset === 'none') {
            return callback(new Error(`${self.client.clientId} owns topics and partitions which contains no saved offsets for group
 '${self.options.groupId}'`));
          }

          async.parallel([
            function (callback) {
              if (self.migrator) {
                return self.migrator.saveHighLevelConsumerOffsets(topicPartitionList, callback);
              }
              callback(null);
            },
            function (callback) {
              if (useDefaultOffsets) {
                return self.saveDefaultOffsets(topicPartitionList, callback);
              }
              callback(null);
            }
          ], function (error) {
            if (error) {
              return callback(error);
            }
            logger.debug('%s defaultOffset Response for %s: %j', self.client.clientId, self.options.fromOffset, self.defaultOffsets
);
            callback(null, offsets);
          });
        } else {
          logger.debug('Has saved offsets');
          callback(null, offsets);
        }
      },
      function (offsets, callback) {
        self.topicPayloads = self.buildPayloads(topicPartitionList).map(function (p) {
          var offset = offsets[p.topic][p.partition];
          if (offset === -1) { // -1 means no offset was saved for this topic/partition combo
            offset = useDefaultOffsets ? self.getDefaultOffset(p, 0) : 0;
            if (self.migrator) {
              offset = self.migrator.getOffset(p, offset);
            }
          }
          p.offset = offset;
          return p;
        });
        callback(null, true);
      }
    ], callback);
  } else { // no partitions assigned
    callback(null, false);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.ConsumerGroup.prototype.leaveGroup" id="apidoc.module.kafka-node.ConsumerGroup.prototype.leaveGroup">module kafka-node.ConsumerGroup.prototype.leaveGroup</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.leaveGroup.leaveGroup" id="apidoc.element.kafka-node.ConsumerGroup.prototype.leaveGroup.leaveGroup">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>leaveGroup
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">leaveGroup = function (callback) {
  logger.debug('%s leaving group', this.client.clientId);
  var self = this;
  this.stopHeartbeats();
  if (self.generationId != null &amp;&amp; self.memberId) {
    this.client.sendLeaveGroupRequest(this.options.groupId, this.memberId, function (error) {
      self.generationId = null;
      callback(error);
    });
  } else {
    callback(null);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.ConsumerGroup.prototype.saveDefaultOffsets" id="apidoc.module.kafka-node.ConsumerGroup.prototype.saveDefaultOffsets">module kafka-node.ConsumerGroup.prototype.saveDefaultOffsets</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.saveDefaultOffsets.saveDefaultOffsets" id="apidoc.element.kafka-node.ConsumerGroup.prototype.saveDefaultOffsets.saveDefaultOffsets">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>saveDefaultOffsets
        <span class="apidocSignatureSpan">(topicPartitionList, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">saveDefaultOffsets = function (topicPartitionList, callback) {
  var self = this;
  const offsetPayload = _(topicPartitionList).cloneDeep().map(tp =&gt; {
    tp.time = ACCEPTED_FROM_OFFSET[this.options.fromOffset];
    return tp;
  });

  self.getOffset().fetch(offsetPayload, function (error, result) {
    if (error) {
      return callback(error);
    }
    self.defaultOffsets = _.mapValues(result, function (partitionOffsets) {
      return _.mapValues(partitionOffsets, _.head);
    });
    callback(null);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.ConsumerGroup.prototype.scheduleReconnect" id="apidoc.module.kafka-node.ConsumerGroup.prototype.scheduleReconnect">module kafka-node.ConsumerGroup.prototype.scheduleReconnect</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.scheduleReconnect.scheduleReconnect" id="apidoc.element.kafka-node.ConsumerGroup.prototype.scheduleReconnect.scheduleReconnect">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>scheduleReconnect
        <span class="apidocSignatureSpan">(timeout)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scheduleReconnect = function (timeout) {
  assert(timeout);
  this.rebalancing = true;

  if (this.reconnectTimer) {
    clearTimeout(this.reconnectTimer);
  }

  var self = this;
  this.reconnectTimer = setTimeout(function () {
    self.reconnectTimer = null;
    self.connect();
  }, timeout);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  if (retry) {
    retryTimeout = this.getRetryTimeout(error);
  }

  if (retry &amp;&amp; retryTimeout) {
    logger.debug('RECOVERY from %s: %s retrying in %s ms', source, this.consumerGroup.client.clientId, retryTimeout, error
);
    this.consumerGroup.<span class="apidocCodeKeywordSpan">scheduleReconnect</span>(retryTimeout);
  } else {
    this.consumerGroup.emit('error', error);
  }
  this.lastError = error;
};

ConsumerGroupRecovery.prototype.clearError = function () {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.ConsumerGroup.prototype.sendHeartbeat" id="apidoc.module.kafka-node.ConsumerGroup.prototype.sendHeartbeat">module kafka-node.ConsumerGroup.prototype.sendHeartbeat</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.sendHeartbeat.sendHeartbeat" id="apidoc.element.kafka-node.ConsumerGroup.prototype.sendHeartbeat.sendHeartbeat">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>sendHeartbeat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendHeartbeat = function () {
  assert(this.memberId, 'invalid memberId');
  assert(this.generationId &gt;= 0, 'invalid generationId');
  // logger.debug('%s â¤ï¸  -&gt;', this.client.clientId);
  var self = this;

  function heartbeatCallback (error) {
    if (error) {
      logger.warn('%s Heartbeat error:', self.client.clientId, error);
      self.recovery.tryToRecoverFrom(error, 'heartbeat');
    }
    // logger.debug('%s ðŸ’š &lt;-', self.client.clientId, error);
  }

  const heartbeat = new Heartbeat(this.client, heartbeatCallback);
  heartbeat.send(this.options.groupId, this.generationId, this.memberId);

  return heartbeat;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.ConsumerGroup.prototype.sendOffsetCommitRequest" id="apidoc.module.kafka-node.ConsumerGroup.prototype.sendOffsetCommitRequest">module kafka-node.ConsumerGroup.prototype.sendOffsetCommitRequest</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.sendOffsetCommitRequest.sendOffsetCommitRequest" id="apidoc.element.kafka-node.ConsumerGroup.prototype.sendOffsetCommitRequest.sendOffsetCommitRequest">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>sendOffsetCommitRequest
        <span class="apidocSignatureSpan">(commits, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendOffsetCommitRequest = function (commits, cb) {
  if (this.generationId &amp;&amp; this.memberId) {
    this.client.sendOffsetCommitV2Request(this.options.groupId, this.generationId, this.memberId, commits, cb);
  } else {
    cb(null, 'Nothing to be committed');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.ConsumerGroup.prototype.setCoordinatorId" id="apidoc.module.kafka-node.ConsumerGroup.prototype.setCoordinatorId">module kafka-node.ConsumerGroup.prototype.setCoordinatorId</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.setCoordinatorId.setCoordinatorId" id="apidoc.element.kafka-node.ConsumerGroup.prototype.setCoordinatorId.setCoordinatorId">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>setCoordinatorId
        <span class="apidocSignatureSpan">(coordinatorId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setCoordinatorId = function (coordinatorId) {
  this.client.coordinatorId = String(coordinatorId);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.ConsumerGroup.prototype.setupProtocols" id="apidoc.module.kafka-node.ConsumerGroup.prototype.setupProtocols">module kafka-node.ConsumerGroup.prototype.setupProtocols</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.setupProtocols.setupProtocols" id="apidoc.element.kafka-node.ConsumerGroup.prototype.setupProtocols.setupProtocols">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>setupProtocols
        <span class="apidocSignatureSpan">(protocols)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setupProtocols = function (protocols) {
  if (!Array.isArray(protocols)) {
    protocols = [protocols];
  }

  this.protocols = protocols.map(function (protocol) {
    if (typeof protocol === 'string') {
      if (!(protocol in builtInProtocols)) {
        throw new Error('Unknown built in assignment protocol ' + protocol);
      }
      protocol = _.assign({}, builtInProtocols[protocol]);
    } else {
      checkProtocol(protocol);
    }

    protocol.subscription = this.topics;
    return protocol;
  }, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.ConsumerGroup.prototype.startHeartbeats" id="apidoc.module.kafka-node.ConsumerGroup.prototype.startHeartbeats">module kafka-node.ConsumerGroup.prototype.startHeartbeats</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.startHeartbeats.startHeartbeats" id="apidoc.element.kafka-node.ConsumerGroup.prototype.startHeartbeats.startHeartbeats">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>startHeartbeats
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">startHeartbeats = function () {
  assert(this.options.sessionTimeout &gt; 0);
  assert(this.ready, 'consumerGroup is not ready');

  const heartbeatIntervalMs = this.options.heartbeatInterval || (Math.floor(this.options.sessionTimeout / 3));

  logger.debug('%s started heartbeats at every %d ms', this.client.clientId, heartbeatIntervalMs);
  this.stopHeartbeats();

  let heartbeat = this.sendHeartbeat();

  this.heartbeatInterval = setInterval(() =&gt; {
    // only send another heartbeat if we got a response from the last one
    if (heartbeat.verifyResolved()) {
      heartbeat = this.sendHeartbeat();
    }
  }, heartbeatIntervalMs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.ConsumerGroup.prototype.stopHeartbeats" id="apidoc.module.kafka-node.ConsumerGroup.prototype.stopHeartbeats">module kafka-node.ConsumerGroup.prototype.stopHeartbeats</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.stopHeartbeats.stopHeartbeats" id="apidoc.element.kafka-node.ConsumerGroup.prototype.stopHeartbeats.stopHeartbeats">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>stopHeartbeats
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stopHeartbeats = function () {
  this.heartbeatInterval &amp;&amp; clearInterval(this.heartbeatInterval);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function ConsumerGroupRecovery (consumerGroup) {
this.consumerGroup = consumerGroup;
this.options = consumerGroup.options;
}

ConsumerGroupRecovery.prototype.tryToRecoverFrom = function (error, source) {
this.consumerGroup.ready = false;
this.consumerGroup.<span class="apidocCodeKeywordSpan">stopHeartbeats</span>();

var retryTimeout = false;
var retry = recoverableErrors.some(function (recoverableItem) {
  if (isErrorInstanceOf(error, recoverableItem.errors)) {
    recoverableItem.handler &amp;&amp; recoverableItem.handler.call(this.consumerGroup, error);
    return true;
  }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.CustomPartitioner" id="apidoc.module.kafka-node.CustomPartitioner">module kafka-node.CustomPartitioner</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.CustomPartitioner.CustomPartitioner" id="apidoc.element.kafka-node.CustomPartitioner.CustomPartitioner">
        function <span class="apidocSignatureSpan">kafka-node.</span>CustomPartitioner
        <span class="apidocSignatureSpan">(partitioner)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CustomPartitioner = function (partitioner) {
  this.getPartition = partitioner;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.CustomPartitioner.super_" id="apidoc.element.kafka-node.CustomPartitioner.super_">
        function <span class="apidocSignatureSpan">kafka-node.CustomPartitioner.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.CustomPartitioner.super_" id="apidoc.module.kafka-node.CustomPartitioner.super_">module kafka-node.CustomPartitioner.super_</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.CustomPartitioner.super_.super_" id="apidoc.element.kafka-node.CustomPartitioner.super_.super_">
        function <span class="apidocSignatureSpan">kafka-node.CustomPartitioner.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.CyclicPartitioner" id="apidoc.module.kafka-node.CyclicPartitioner">module kafka-node.CyclicPartitioner</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.CyclicPartitioner.CyclicPartitioner" id="apidoc.element.kafka-node.CyclicPartitioner.CyclicPartitioner">
        function <span class="apidocSignatureSpan">kafka-node.</span>CyclicPartitioner
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CyclicPartitioner = function () {
  this.c = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.CyclicPartitioner.super_" id="apidoc.element.kafka-node.CyclicPartitioner.super_">
        function <span class="apidocSignatureSpan">kafka-node.CyclicPartitioner.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.CyclicPartitioner.prototype" id="apidoc.module.kafka-node.CyclicPartitioner.prototype">module kafka-node.CyclicPartitioner.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.CyclicPartitioner.prototype.getPartition" id="apidoc.element.kafka-node.CyclicPartitioner.prototype.getPartition">
        function <span class="apidocSignatureSpan">kafka-node.CyclicPartitioner.prototype.</span>getPartition
        <span class="apidocSignatureSpan">(partitions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPartition = function (partitions) {
  if (_.isEmpty(partitions)) return 0;
  return partitions[ this.c++ % partitions.length ];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.CyclicPartitioner.prototype.getPartition" id="apidoc.module.kafka-node.CyclicPartitioner.prototype.getPartition">module kafka-node.CyclicPartitioner.prototype.getPartition</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.CyclicPartitioner.prototype.getPartition.getPartition" id="apidoc.element.kafka-node.CyclicPartitioner.prototype.getPartition.getPartition">
        function <span class="apidocSignatureSpan">kafka-node.CyclicPartitioner.prototype.</span>getPartition
        <span class="apidocSignatureSpan">(partitions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPartition = function (partitions) {
  if (_.isEmpty(partitions)) return 0;
  return partitions[ this.c++ % partitions.length ];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.DefaultPartitioner" id="apidoc.module.kafka-node.DefaultPartitioner">module kafka-node.DefaultPartitioner</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.DefaultPartitioner.DefaultPartitioner" id="apidoc.element.kafka-node.DefaultPartitioner.DefaultPartitioner">
        function <span class="apidocSignatureSpan">kafka-node.</span>DefaultPartitioner
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">DefaultPartitioner = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.DefaultPartitioner.super_" id="apidoc.element.kafka-node.DefaultPartitioner.super_">
        function <span class="apidocSignatureSpan">kafka-node.DefaultPartitioner.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.DefaultPartitioner.prototype" id="apidoc.module.kafka-node.DefaultPartitioner.prototype">module kafka-node.DefaultPartitioner.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.DefaultPartitioner.prototype.getPartition" id="apidoc.element.kafka-node.DefaultPartitioner.prototype.getPartition">
        function <span class="apidocSignatureSpan">kafka-node.DefaultPartitioner.prototype.</span>getPartition
        <span class="apidocSignatureSpan">(partitions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPartition = function (partitions) {
  if (partitions &amp;&amp; _.isArray(partitions) &amp;&amp; partitions.length &gt; 0) {
    return partitions[0];
  } else {
    return 0;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.DefaultPartitioner.prototype.getPartition" id="apidoc.module.kafka-node.DefaultPartitioner.prototype.getPartition">module kafka-node.DefaultPartitioner.prototype.getPartition</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.DefaultPartitioner.prototype.getPartition.getPartition" id="apidoc.element.kafka-node.DefaultPartitioner.prototype.getPartition.getPartition">
        function <span class="apidocSignatureSpan">kafka-node.DefaultPartitioner.prototype.</span>getPartition
        <span class="apidocSignatureSpan">(partitions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPartition = function (partitions) {
  if (partitions &amp;&amp; _.isArray(partitions) &amp;&amp; partitions.length &gt; 0) {
    return partitions[0];
  } else {
    return 0;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.HighLevelConsumer" id="apidoc.module.kafka-node.HighLevelConsumer">module kafka-node.HighLevelConsumer</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.HighLevelConsumer" id="apidoc.element.kafka-node.HighLevelConsumer.HighLevelConsumer">
        function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer
        <span class="apidocSignatureSpan">(client, topics, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">HighLevelConsumer = function (client, topics, options) {
  if (!topics) {
    throw new Error('Must have payloads');
  }
  this.fetchCount = 0;
  this.client = client;
  this.options = _.defaults((options || {}), DEFAULTS);
  this.initialised = false;
  this.ready = false;
  this.closing = false;
  this.paused = this.options.paused;
  this.rebalancing = false;
  this.pendingRebalances = 0;
  this.committing = false;
  this.needToCommit = false;
  this.id = this.options.id || this.options.groupId + '_' + uuid.v4();
  this.payloads = this.buildPayloads(topics);
  this.topicPayloads = this.buildTopicPayloads(topics);
  this.connect();

  if (this.options.groupId) {
    validateConfig('options.groupId', this.options.groupId);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.super_" id="apidoc.element.kafka-node.HighLevelConsumer.super_">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype" id="apidoc.module.kafka-node.HighLevelConsumer.prototype">module kafka-node.HighLevelConsumer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype._releasePartitions" id="apidoc.element.kafka-node.HighLevelConsumer.prototype._releasePartitions">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>_releasePartitions
        <span class="apidocSignatureSpan">(topicPayloads, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_releasePartitions = function (topicPayloads, callback) {
  var self = this;
  async.each(topicPayloads, function (tp, cbb) {
    if (tp.partition !== undefined) {
      async.series([
        function (delcbb) {
          self.client.zk.checkPartitionOwnership(self.id, self.options.groupId, tp.topic, tp.partition, function (err) {
            if (err) {
              // Partition doesn't exist simply carry on
              cbb();
            } else delcbb();
          });
        },
        function (delcbb) {
          self.client.zk.deletePartitionOwnership(self.options.groupId, tp.topic, tp.partition, delcbb);
        },
        function (delcbb) {
          self.client.zk.checkPartitionOwnership(self.id, self.options.groupId, tp.topic, tp.partition, function (err) {
            if (err) {
              delcbb();
            } else {
              delcbb('Partition should not exist');
            }
          });
        }],
      cbb);
    } else {
      cbb();
    }
  }, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.addTopics" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.addTopics">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>addTopics
        <span class="apidocSignatureSpan">(topics, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addTopics = function (topics, cb) {
  var self = this;
  if (!this.ready) {
    setTimeout(function () {
      self.addTopics(topics, cb);
    }, 100);
    return;
  }
  this.client.addTopics(
    topics,
    function (err, added) {
      if (err) return cb &amp;&amp; cb(err, added);

      var payloads = self.buildPayloads(topics);
      // update offset of topics that will be added
      self.fetchOffset(payloads, function (err, offsets) {
        if (err) return cb(err);
        payloads.forEach(function (p) {
          var offset = offsets[p.topic][p.partition];
          if (offset === -1) offset = 0;
          p.offset = offset;
          self.topicPayloads.push(p);
        });
        // TODO: rebalance consumer
        cb &amp;&amp; cb(null, added);
      });
    }
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `topics`: **Array**, array of topics to add
* `cb`: **Function**,the callback
* `fromOffset`: **Boolean**, if true, the consumer will fetch message from the specified offset, otherwise it will fetch message
 from the last commited offset of the topic.

Example:

``` js
consumer.<span class="apidocCodeKeywordSpan">addTopics</span>(['t1', 't2'], function (err, added) {
});

or

consumer.addTopics([{ topic: 't1', offset: 10 }], function (err, added) {
}, true);
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.autoCommit" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.autoCommit">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>autoCommit
        <span class="apidocSignatureSpan">(force, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function autoCommit(force, cb) {
  if (arguments.length === 1) {
    cb = force;
    force = false;
  }

  if (!force) {
    if (this.committing) return cb(null, 'Offset committing');
    if (!this.needToCommit) return cb(null, 'Commit not needed');
  }

  this.needToCommit = false;
  this.committing = true;
  setTimeout(function () {
    this.committing = false;
  }.bind(this), this.options.autoCommitIntervalMs);

  var commits = this.topicPayloads.filter(function (p) { return p.offset !== -1; });

  if (commits.length) {
    this.sendOffsetCommitRequest(commits, cb);
  } else {
    cb(null, 'Nothing to be committed');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.buildPayloads" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.buildPayloads">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>buildPayloads
        <span class="apidocSignatureSpan">(payloads)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildPayloads = function (payloads) {
  var self = this;
  return payloads.map(function (p) {
    if (typeof p !== 'object') p = { topic: p };
    p.partition = p.partition || 0;
    p.offset = p.offset || 0;
    p.maxBytes = self.options.fetchMaxBytes;
    p.metadata = 'm'; // metadata can be arbitrary
    return p;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.buildTopicPayloads" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.buildTopicPayloads">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>buildTopicPayloads
        <span class="apidocSignatureSpan">(topics)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildTopicPayloads = function (topics) {
  return topics.map(function (j) {
    var k = { topic: j.topic };
    return k;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.close" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.close">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>close
        <span class="apidocSignatureSpan">(force, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (force, cb) {
  var self = this;
  this.ready = false;
  this.closing = true;
  clearInterval(this.checkPartitionOwnershipInterval);

  if (typeof force === 'function') {
    cb = force;
    force = false;
  }

  async.series([
    function (callback) {
      self.leaveGroup(callback);
    },
    function (callback) {
      if (force) {
        async.series([
          function (callback) {
            self.commit(true, callback);
          },
          function (callback) {
            self.client.close(callback);
          }
        ], callback);
        return;
      }
      self.client.close(callback);
    }
  ], cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### close(force, cb)
* `force`: **Boolean**, if set to true, it forces the consumer to commit the current offset before closing, default `false`

Example

```js
consumer.<span class="apidocCodeKeywordSpan">close</span>(true, cb);
consumer.close(cb); //force is disabled
```

## HighLevelConsumer
âš&nbsp;ï¸ ***This consumer has been deprecated in the latest version of Kafka (0.10.1) and is likely to be removed in the future. Please
 use the ConsumerGroup instead.***

### HighLevelConsumer(client, payloads, options)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.commit" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.commit">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>commit
        <span class="apidocSignatureSpan">(force, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function autoCommit(force, cb) {
  if (arguments.length === 1) {
    cb = force;
    force = false;
  }

  if (!force) {
    if (this.committing) return cb(null, 'Offset committing');
    if (!this.needToCommit) return cb(null, 'Commit not needed');
  }

  this.needToCommit = false;
  this.committing = true;
  setTimeout(function () {
    this.committing = false;
  }.bind(this), this.options.autoCommitIntervalMs);

  var commits = this.topicPayloads.filter(function (p) { return p.offset !== -1; });

  if (commits.length) {
    this.sendOffsetCommitRequest(commits, cb);
  } else {
    cb(null, 'Nothing to be committed');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Commit offset of the current topics manually, this method should be called when a consumer leaves

* `cb`: **Function**, the callback

Example:

``` js
consumer.<span class="apidocCodeKeywordSpan">commit</span>(function(err, data) {
});
```

### setOffset(topic, partition, offset)
Set offset of the given topic

* `topic`: **String**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.connect" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.connect">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>connect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connect = function () {
  var self = this;
  // Client alreadyexists
  if (this.client.ready) {
    this.init();
  }

  this.client.on('ready', function () {
    if (!self.initialised) self.init();

    // Check the topics exist and create a watcher on them
    var topics = self.payloads.map(function (p) {
      return p.topic;
    });

    self.client.topicExists(topics, function (err) {
      if (err) {
        return self.emit('error', err);
      }
      self.initialised = true;
    });
  });

  function checkPartitionOwnership (callback) {
    async.each(self.topicPayloads, function (tp, cbb) {
      if (tp.partition !== undefined) {
        self.client.zk.checkPartitionOwnership(self.id, self.options.groupId, tp.topic, tp.partition, function (err) {
          if (err) {
            cbb(err);
          } else {
            cbb();
          }
        });
      } else {
        cbb();
      }
    }, callback);
  }

  // Check partition ownership and registration
  this.checkPartitionOwnershipInterval = setInterval(function () {
    if (!self.rebalancing) {
      async.parallel([
        checkPartitionOwnership,
        function (callback) {
          self.client.zk.isConsumerRegistered(self.options.groupId, self.id, function (error, registered) {
            if (error) {
              return callback(error);
            }
            if (registered) {
              callback();
            } else {
              callback(new Error(util.format('Consumer %s is not registered in group %s', self.id, self.options.groupId)));
            }
          });
        }
      ], function (error) {
        if (error) {
          self.emit('error', new errors.FailedToRegisterConsumerError(error.toString(), error));
        }
      });
    }
  }, 20000);

  function fetchAndUpdateOffsets (cb) {
    self.fetchOffset(self.topicPayloads, function (err, topics) {
      if (err) {
        return cb(err);
      }

      self.ready = true;
      self.updateOffsets(topics, true);

      return cb();
    });
  }

  function rebalance () {
    logger.debug('rebalance() %s is rebalancing: %s ready: %s', self.id, self.rebalancing, self.ready);
    if (!self.rebalancing &amp;&amp; !self.closing) {
      deregister();

      self.emit('rebalancing');

      self.rebalancing = true;
      logger.debug('HighLevelConsumer rebalance retry config: %s', JSON.stringify(self.options.rebalanceRetry));
      var oldTopicPayloads = self.topicPayloads;
      var operation = retry.operation(self.options.rebalanceRetry);

      operation.attempt(function (currentAttempt) {
        self.rebalanceAttempt(oldTopicPayloads, function (err) {
          if (operation.retry(err)) {
            return;
          }
          if (err) {
            self.rebalancing = false;
            return self.emit('error', new errors.FailedToRebalanceConsumerError(operation.mainError().toString()));
          } else {
            var topicNames = self.topicPayloads.map(function (p) {
              return p.topic;
            });
            self.client.refreshMetadata(topicNames, function (err) {
              register();
              if (err) {
                self.rebalancing = false;
                self.emit('error', err);
                return;
              }

              if (self.topicPayloads.length) {
                fetchAndUpdateOffsets(function (err) {
                  self.rebalancing = false;
                  if (err) {
                    self.emit('error', new errors.FailedToRebalanceConsumerError(err.message));
                    return;
                  }
                  self.fetch();
                  self.emit('rebalanced');
                });
              } else { // was not assigned any partitions during rebalance
                self.rebalancing = false;
                self.emit('rebalanced');
              }
            });
          }
        });
      });
    }
  }

  // Wait for the consumer to be ready
  this.on('registered', rebalance);

  function register (fn) {
    logger.debug('Registered listeners %s', self.id);
    self.client.zk.on('consumersChanged', fn ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    });

    this.on('topicOwnerChange', _.debounce(function (topics) {
      verified = 0;
      self.checkForOwnersAndListenForChange(topics);
    }, 250));

    this.zk.<span class="apidocCodeKeywordSpan">connect</span>();
  } else {
    this.connectConsumerGroup();
  }
}

util.inherits(ConsumerGroupMigrator, EventEmitter);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.fetch" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.fetch">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>fetch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetch = function () {
  if (!this.ready || this.rebalancing || this.paused) {
    return;
  }

  this.client.sendFetchRequest(this, this.topicPayloads, this.options.fetchMaxWaitMs, this.options.fetchMinBytes, this.options.maxTickMessages
);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Example

```js
var kafka = require('kafka-node'),
    client = new kafka.Client(),
    offset = new kafka.Offset(client);
    offset.<span class="apidocCodeKeywordSpan">fetch</span>([
        { topic: 't', partition: 0, time: Date.now(), maxNum: 1 }
    ], function (err, data) {
        // data
        // { 't': { '0': [999] } }
    });
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.fetchOffset" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.fetchOffset">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>fetchOffset
        <span class="apidocSignatureSpan">(payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetchOffset = function (payloads, cb) {
  logger.debug('in fetchOffset %s payloads: %j', this.id, payloads);
  this.client.sendOffsetFetchRequest(this.options.groupId, payloads, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.getTopicPayloads" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.getTopicPayloads">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>getTopicPayloads
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTopicPayloads = function () {
  if (!this.rebalancing) return this.topicPayloads;
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.init" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.init">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>init
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init = function () {
  var self = this;

  if (!self.topicPayloads.length) {
    return;
  }

  self.registerConsumer(function (err) {
    if (err) {
      return self.emit('error', new errors.FailedToRegisterConsumerError(err.toString()));
    }

    // Close the
    return self.emit('registered');
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.leaveGroup" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.leaveGroup">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>leaveGroup
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">leaveGroup = function (cb) {
  var self = this;
  async.parallel([
    function (callback) {
      if (self.topicPayloads.length) {
        self._releasePartitions(self.topicPayloads, callback);
      } else {
        callback(null);
      }
    },
    function (callback) {
      self.client.zk.unregisterConsumer(self.options.groupId, self.id, callback);
    }
  ], cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.offsetRequest" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.offsetRequest">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>offsetRequest
        <span class="apidocSignatureSpan">(payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">offsetRequest = function (payloads, cb) {
  this.client.sendOffsetRequest(payloads, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.pause" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.pause">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>pause
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pause = function () {
  this.paused = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.rebalanceAttempt" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.rebalanceAttempt">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>rebalanceAttempt
        <span class="apidocSignatureSpan">(oldTopicPayloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rebalanceAttempt = function (oldTopicPayloads, cb) {
  var self = this;
  // Do the rebalance.....
  var consumerPerTopicMap;
  var newTopicPayloads = [];
  logger.debug('HighLevelConsumer %s is attempting to rebalance', self.id);
  async.series([

    // Stop fetching data and commit offsets
    function (callback) {
      logger.debug('HighLevelConsumer %s stopping data read during rebalance', self.id);
      self.stop(function () {
        callback();
      });
    },

    // Assemble the data
    function (callback) {
      logger.debug('HighLevelConsumer %s assembling data for rebalance', self.id);
      self.client.zk.getConsumersPerTopic(self.options.groupId, function (err, obj) {
        if (err) {
          callback(err);
        } else {
          consumerPerTopicMap = obj;
          callback();
        }
      });
    },

    // Release current partitions
    function (callback) {
      logger.debug('HighLevelConsumer %s releasing current partitions during rebalance', self.id);
      self._releasePartitions(oldTopicPayloads, callback);
    },

    // Rebalance
    function (callback) {
      logger.debug('HighLevelConsumer %s determining the partitions to own during rebalance', self.id);
      logger.debug('consumerPerTopicMap.consumerTopicMap %j', consumerPerTopicMap.consumerTopicMap);
      for (var topic in consumerPerTopicMap.consumerTopicMap[self.id]) {
        if (!consumerPerTopicMap.consumerTopicMap[self.id].hasOwnProperty(topic)) {
          continue;
        }
        var topicToAdd = consumerPerTopicMap.consumerTopicMap[self.id][topic];
        var numberOfConsumers = consumerPerTopicMap.topicConsumerMap[topicToAdd].length;
        var numberOfPartition = consumerPerTopicMap.topicPartitionMap[topicToAdd].length;
        var partitionsPerConsumer = Math.floor(numberOfPartition / numberOfConsumers);
        var extraPartitions = numberOfPartition % numberOfConsumers;
        var currentConsumerIndex;
        for (var index in consumerPerTopicMap.topicConsumerMap[topicToAdd]) {
          if (!consumerPerTopicMap.topicConsumerMap[topicToAdd].hasOwnProperty(index)) {
            continue;
          }
          if (consumerPerTopicMap.topicConsumerMap[topicToAdd][index] === self.id) {
            currentConsumerIndex = parseInt(index);
            break;
          }
        }
        var extraBit = currentConsumerIndex;
        if (currentConsumerIndex &gt; extraPartitions) extraBit = extraPartitions;
        var startPart = partitionsPerConsumer * currentConsumerIndex + extraBit;
        var extraNParts = 1;
        if (currentConsumerIndex + 1 &gt; extraPartitions) extraNParts = 0;
        var nParts = partitionsPerConsumer + extraNParts;

        for (var i = startPart; i &lt; startPart + nParts; i++) {
          newTopicPayloads.push({
            topic: topicToAdd,
            partition: consumerPerTopicMap.topicPartitionMap[topicToAdd][i],
            offset: 0,
            maxBytes: self.options.fetchMaxBytes,
            metadata: 'm'
          });
        }
      }
      logger.debug('newTopicPayloads %j', newTopicPayloads);
      callback();
    },

    // Update ZK with new ownership
    function (callback) {
      if (newTopicPayloads.length) {
        logger.debug('HighLevelConsumer %s gaining ownership of partitions during rebalance', self.id);
        async.eachSeries(newTopicPayloads, function (tp, cbb) {
          if (tp.partition !== undefined) {
            async.series([
              function (addcbb) {
                self.client.zk.checkPartitionOwnership(self.id, self.options.groupId, tp.topic, tp.partition, function (err) {
                  if (err) {
                    // Partition doesn't exist simply carry on
                    addcbb();
                  } else cbb(); // Partition exists simply carry on
                });
              },
              function (addcbb) {
                self.client.zk.addPartitionOwnership(self.id, self.options.groupId, tp.topic, tp.partition, function (err) {
                  if (err) {
                    addcbb(err);
                  } else addcbb(); ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.registerConsumer" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.registerConsumer">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>registerConsumer
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerConsumer = function (cb) {
  var self = this;
  var groupId = this.options.groupId;
  this.client.zk.registerConsumer(groupId, this.id, this.payloads, function (err) {
    if (err) return cb(err);
    self.client.zk.listConsumers(self.options.groupId);
    var topics = self.topicPayloads.reduce(function (ret, topicPayload) {
      if (ret.indexOf(topicPayload.topic) === -1) {
        ret.push(topicPayload.topic);
      }
      return ret;
    }, []);
    topics.forEach(function (topic) {
      self.client.zk.listPartitions(topic);
    });
    cb();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.removeTopics" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.removeTopics">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>removeTopics
        <span class="apidocSignatureSpan">(topics, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeTopics = function (topics, cb) {
  topics = typeof topics === 'string' ? [topics] : topics;
  this.payloads = this.payloads.filter(function (p) {
    return !~topics.indexOf(p.topic);
  });

  this.client.removeTopicMetadata(topics, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### removeTopics(topics, cb)
* `topics`: **Array**, array of topics to remove
* `cb`: **Function**, the callback

Example:

``` js
consumer.<span class="apidocCodeKeywordSpan">removeTopics</span>(['t1', 't2'], function (err, removed) {
});
```

### commit(cb)
Commit offset of the current topics manually, this method should be called when a consumer leaves

* `cb`: **Function**, the callback
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.resume" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.resume">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>resume
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resume = function () {
  this.paused = false;
  this.fetch();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.sendOffsetCommitRequest" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.sendOffsetCommitRequest">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>sendOffsetCommitRequest
        <span class="apidocSignatureSpan">(commits, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendOffsetCommitRequest = function (commits, cb) {
  this.client.sendOffsetCommitRequest(this.options.groupId, commits, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.setOffset" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.setOffset">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>setOffset
        <span class="apidocSignatureSpan">(topic, partition, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setOffset = function (topic, partition, offset) {
  this.topicPayloads.every(function (p) {
    if (p.topic === topic &amp;&amp; p.partition == partition) { // eslint-disable-line eqeqeq
      p.offset = offset;
      return false;
    }
    return true;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `partition`: **Number**

* `offset`: **Number**

Example:

``` js
consumer.<span class="apidocCodeKeywordSpan">setOffset</span>('topic', 0, 0);
```

### pause()
Pause the consumer. ***Calling `pause` does not automatically stop messages from being emitted.*** This is because pause just stops
 the kafka consumer fetch loop. Each iteration of the fetch loop can obtain a batch of messages (limited by `fetchMaxBytes`).

### resume()
Resume the consumer. Resumes the fetch loop.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.stop" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.stop">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>stop
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stop = function (cb) {
  if (!this.options.autoCommit) return cb &amp;&amp; cb();
  this.commit(true, function (err) {
    cb &amp;&amp; cb(err);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.updateOffsets" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.updateOffsets">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>updateOffsets
        <span class="apidocSignatureSpan">(topics, initing)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateOffsets = function (topics, initing) {
  this.topicPayloads.forEach(p =&gt; {
    if (!_.isEmpty(topics[p.topic]) &amp;&amp; topics[p.topic][p.partition] !== undefined) {
      var offset = topics[p.topic][p.partition];
      if (offset === -1) offset = 0;
      if (!initing) p.offset = offset + 1;
      else p.offset = offset;
      this.needToCommit = true;
    }
  });

  if (this.options.autoCommit &amp;&amp; !initing) {
    this.autoCommit(false, function (err) {
      err &amp;&amp; logger.debug('auto commit offset', err);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype._releasePartitions" id="apidoc.module.kafka-node.HighLevelConsumer.prototype._releasePartitions">module kafka-node.HighLevelConsumer.prototype._releasePartitions</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype._releasePartitions._releasePartitions" id="apidoc.element.kafka-node.HighLevelConsumer.prototype._releasePartitions._releasePartitions">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>_releasePartitions
        <span class="apidocSignatureSpan">(topicPayloads, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_releasePartitions = function (topicPayloads, callback) {
  var self = this;
  async.each(topicPayloads, function (tp, cbb) {
    if (tp.partition !== undefined) {
      async.series([
        function (delcbb) {
          self.client.zk.checkPartitionOwnership(self.id, self.options.groupId, tp.topic, tp.partition, function (err) {
            if (err) {
              // Partition doesn't exist simply carry on
              cbb();
            } else delcbb();
          });
        },
        function (delcbb) {
          self.client.zk.deletePartitionOwnership(self.options.groupId, tp.topic, tp.partition, delcbb);
        },
        function (delcbb) {
          self.client.zk.checkPartitionOwnership(self.id, self.options.groupId, tp.topic, tp.partition, function (err) {
            if (err) {
              delcbb();
            } else {
              delcbb('Partition should not exist');
            }
          });
        }],
      cbb);
    } else {
      cbb();
    }
  }, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype.addTopics" id="apidoc.module.kafka-node.HighLevelConsumer.prototype.addTopics">module kafka-node.HighLevelConsumer.prototype.addTopics</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.addTopics.addTopics" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.addTopics.addTopics">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>addTopics
        <span class="apidocSignatureSpan">(topics, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addTopics = function (topics, cb) {
  var self = this;
  if (!this.ready) {
    setTimeout(function () {
      self.addTopics(topics, cb);
    }, 100);
    return;
  }
  this.client.addTopics(
    topics,
    function (err, added) {
      if (err) return cb &amp;&amp; cb(err, added);

      var payloads = self.buildPayloads(topics);
      // update offset of topics that will be added
      self.fetchOffset(payloads, function (err, offsets) {
        if (err) return cb(err);
        payloads.forEach(function (p) {
          var offset = offsets[p.topic][p.partition];
          if (offset === -1) offset = 0;
          p.offset = offset;
          self.topicPayloads.push(p);
        });
        // TODO: rebalance consumer
        cb &amp;&amp; cb(null, added);
      });
    }
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `topics`: **Array**, array of topics to add
* `cb`: **Function**,the callback
* `fromOffset`: **Boolean**, if true, the consumer will fetch message from the specified offset, otherwise it will fetch message
 from the last commited offset of the topic.

Example:

``` js
consumer.<span class="apidocCodeKeywordSpan">addTopics</span>(['t1', 't2'], function (err, added) {
});

or

consumer.addTopics([{ topic: 't1', offset: 10 }], function (err, added) {
}, true);
```
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype.autoCommit" id="apidoc.module.kafka-node.HighLevelConsumer.prototype.autoCommit">module kafka-node.HighLevelConsumer.prototype.autoCommit</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.autoCommit.autoCommit" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.autoCommit.autoCommit">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>autoCommit
        <span class="apidocSignatureSpan">(force, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function autoCommit(force, cb) {
  if (arguments.length === 1) {
    cb = force;
    force = false;
  }

  if (!force) {
    if (this.committing) return cb(null, 'Offset committing');
    if (!this.needToCommit) return cb(null, 'Commit not needed');
  }

  this.needToCommit = false;
  this.committing = true;
  setTimeout(function () {
    this.committing = false;
  }.bind(this), this.options.autoCommitIntervalMs);

  var commits = this.topicPayloads.filter(function (p) { return p.offset !== -1; });

  if (commits.length) {
    this.sendOffsetCommitRequest(commits, cb);
  } else {
    cb(null, 'Nothing to be committed');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype.buildPayloads" id="apidoc.module.kafka-node.HighLevelConsumer.prototype.buildPayloads">module kafka-node.HighLevelConsumer.prototype.buildPayloads</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.buildPayloads.buildPayloads" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.buildPayloads.buildPayloads">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>buildPayloads
        <span class="apidocSignatureSpan">(payloads)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildPayloads = function (payloads) {
  var self = this;
  return payloads.map(function (p) {
    if (typeof p !== 'object') p = { topic: p };
    p.partition = p.partition || 0;
    p.offset = p.offset || 0;
    p.maxBytes = self.options.fetchMaxBytes;
    p.metadata = 'm'; // metadata can be arbitrary
    return p;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype.buildTopicPayloads" id="apidoc.module.kafka-node.HighLevelConsumer.prototype.buildTopicPayloads">module kafka-node.HighLevelConsumer.prototype.buildTopicPayloads</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.buildTopicPayloads.buildTopicPayloads" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.buildTopicPayloads.buildTopicPayloads">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>buildTopicPayloads
        <span class="apidocSignatureSpan">(topics)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildTopicPayloads = function (topics) {
  return topics.map(function (j) {
    var k = { topic: j.topic };
    return k;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype.close" id="apidoc.module.kafka-node.HighLevelConsumer.prototype.close">module kafka-node.HighLevelConsumer.prototype.close</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.close.close" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.close.close">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>close
        <span class="apidocSignatureSpan">(force, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (force, cb) {
  var self = this;
  this.ready = false;
  this.closing = true;
  clearInterval(this.checkPartitionOwnershipInterval);

  if (typeof force === 'function') {
    cb = force;
    force = false;
  }

  async.series([
    function (callback) {
      self.leaveGroup(callback);
    },
    function (callback) {
      if (force) {
        async.series([
          function (callback) {
            self.commit(true, callback);
          },
          function (callback) {
            self.client.close(callback);
          }
        ], callback);
        return;
      }
      self.client.close(callback);
    }
  ], cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### close(force, cb)
* `force`: **Boolean**, if set to true, it forces the consumer to commit the current offset before closing, default `false`

Example

```js
consumer.<span class="apidocCodeKeywordSpan">close</span>(true, cb);
consumer.close(cb); //force is disabled
```

## HighLevelConsumer
âš&nbsp;ï¸ ***This consumer has been deprecated in the latest version of Kafka (0.10.1) and is likely to be removed in the future. Please
 use the ConsumerGroup instead.***

### HighLevelConsumer(client, payloads, options)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype.connect" id="apidoc.module.kafka-node.HighLevelConsumer.prototype.connect">module kafka-node.HighLevelConsumer.prototype.connect</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.connect.connect" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.connect.connect">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>connect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connect = function () {
  var self = this;
  // Client alreadyexists
  if (this.client.ready) {
    this.init();
  }

  this.client.on('ready', function () {
    if (!self.initialised) self.init();

    // Check the topics exist and create a watcher on them
    var topics = self.payloads.map(function (p) {
      return p.topic;
    });

    self.client.topicExists(topics, function (err) {
      if (err) {
        return self.emit('error', err);
      }
      self.initialised = true;
    });
  });

  function checkPartitionOwnership (callback) {
    async.each(self.topicPayloads, function (tp, cbb) {
      if (tp.partition !== undefined) {
        self.client.zk.checkPartitionOwnership(self.id, self.options.groupId, tp.topic, tp.partition, function (err) {
          if (err) {
            cbb(err);
          } else {
            cbb();
          }
        });
      } else {
        cbb();
      }
    }, callback);
  }

  // Check partition ownership and registration
  this.checkPartitionOwnershipInterval = setInterval(function () {
    if (!self.rebalancing) {
      async.parallel([
        checkPartitionOwnership,
        function (callback) {
          self.client.zk.isConsumerRegistered(self.options.groupId, self.id, function (error, registered) {
            if (error) {
              return callback(error);
            }
            if (registered) {
              callback();
            } else {
              callback(new Error(util.format('Consumer %s is not registered in group %s', self.id, self.options.groupId)));
            }
          });
        }
      ], function (error) {
        if (error) {
          self.emit('error', new errors.FailedToRegisterConsumerError(error.toString(), error));
        }
      });
    }
  }, 20000);

  function fetchAndUpdateOffsets (cb) {
    self.fetchOffset(self.topicPayloads, function (err, topics) {
      if (err) {
        return cb(err);
      }

      self.ready = true;
      self.updateOffsets(topics, true);

      return cb();
    });
  }

  function rebalance () {
    logger.debug('rebalance() %s is rebalancing: %s ready: %s', self.id, self.rebalancing, self.ready);
    if (!self.rebalancing &amp;&amp; !self.closing) {
      deregister();

      self.emit('rebalancing');

      self.rebalancing = true;
      logger.debug('HighLevelConsumer rebalance retry config: %s', JSON.stringify(self.options.rebalanceRetry));
      var oldTopicPayloads = self.topicPayloads;
      var operation = retry.operation(self.options.rebalanceRetry);

      operation.attempt(function (currentAttempt) {
        self.rebalanceAttempt(oldTopicPayloads, function (err) {
          if (operation.retry(err)) {
            return;
          }
          if (err) {
            self.rebalancing = false;
            return self.emit('error', new errors.FailedToRebalanceConsumerError(operation.mainError().toString()));
          } else {
            var topicNames = self.topicPayloads.map(function (p) {
              return p.topic;
            });
            self.client.refreshMetadata(topicNames, function (err) {
              register();
              if (err) {
                self.rebalancing = false;
                self.emit('error', err);
                return;
              }

              if (self.topicPayloads.length) {
                fetchAndUpdateOffsets(function (err) {
                  self.rebalancing = false;
                  if (err) {
                    self.emit('error', new errors.FailedToRebalanceConsumerError(err.message));
                    return;
                  }
                  self.fetch();
                  self.emit('rebalanced');
                });
              } else { // was not assigned any partitions during rebalance
                self.rebalancing = false;
                self.emit('rebalanced');
              }
            });
          }
        });
      });
    }
  }

  // Wait for the consumer to be ready
  this.on('registered', rebalance);

  function register (fn) {
    logger.debug('Registered listeners %s', self.id);
    self.client.zk.on('consumersChanged', fn ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    });

    this.on('topicOwnerChange', _.debounce(function (topics) {
      verified = 0;
      self.checkForOwnersAndListenForChange(topics);
    }, 250));

    this.zk.<span class="apidocCodeKeywordSpan">connect</span>();
  } else {
    this.connectConsumerGroup();
  }
}

util.inherits(ConsumerGroupMigrator, EventEmitter);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype.fetch" id="apidoc.module.kafka-node.HighLevelConsumer.prototype.fetch">module kafka-node.HighLevelConsumer.prototype.fetch</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.fetch.fetch" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.fetch.fetch">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>fetch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetch = function () {
  if (!this.ready || this.rebalancing || this.paused) {
    return;
  }

  this.client.sendFetchRequest(this, this.topicPayloads, this.options.fetchMaxWaitMs, this.options.fetchMinBytes, this.options.maxTickMessages
);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Example

```js
var kafka = require('kafka-node'),
    client = new kafka.Client(),
    offset = new kafka.Offset(client);
    offset.<span class="apidocCodeKeywordSpan">fetch</span>([
        { topic: 't', partition: 0, time: Date.now(), maxNum: 1 }
    ], function (err, data) {
        // data
        // { 't': { '0': [999] } }
    });
```
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype.fetchOffset" id="apidoc.module.kafka-node.HighLevelConsumer.prototype.fetchOffset">module kafka-node.HighLevelConsumer.prototype.fetchOffset</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.fetchOffset.fetchOffset" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.fetchOffset.fetchOffset">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>fetchOffset
        <span class="apidocSignatureSpan">(payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetchOffset = function (payloads, cb) {
  logger.debug('in fetchOffset %s payloads: %j', this.id, payloads);
  this.client.sendOffsetFetchRequest(this.options.groupId, payloads, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype.getTopicPayloads" id="apidoc.module.kafka-node.HighLevelConsumer.prototype.getTopicPayloads">module kafka-node.HighLevelConsumer.prototype.getTopicPayloads</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.getTopicPayloads.getTopicPayloads" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.getTopicPayloads.getTopicPayloads">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>getTopicPayloads
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTopicPayloads = function () {
  if (!this.rebalancing) return this.topicPayloads;
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype.init" id="apidoc.module.kafka-node.HighLevelConsumer.prototype.init">module kafka-node.HighLevelConsumer.prototype.init</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.init.init" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.init.init">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>init
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init = function () {
  var self = this;

  if (!self.topicPayloads.length) {
    return;
  }

  self.registerConsumer(function (err) {
    if (err) {
      return self.emit('error', new errors.FailedToRegisterConsumerError(err.toString()));
    }

    // Close the
    return self.emit('registered');
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype.leaveGroup" id="apidoc.module.kafka-node.HighLevelConsumer.prototype.leaveGroup">module kafka-node.HighLevelConsumer.prototype.leaveGroup</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.leaveGroup.leaveGroup" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.leaveGroup.leaveGroup">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>leaveGroup
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">leaveGroup = function (cb) {
  var self = this;
  async.parallel([
    function (callback) {
      if (self.topicPayloads.length) {
        self._releasePartitions(self.topicPayloads, callback);
      } else {
        callback(null);
      }
    },
    function (callback) {
      self.client.zk.unregisterConsumer(self.options.groupId, self.id, callback);
    }
  ], cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype.offsetRequest" id="apidoc.module.kafka-node.HighLevelConsumer.prototype.offsetRequest">module kafka-node.HighLevelConsumer.prototype.offsetRequest</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.offsetRequest.offsetRequest" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.offsetRequest.offsetRequest">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>offsetRequest
        <span class="apidocSignatureSpan">(payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">offsetRequest = function (payloads, cb) {
  this.client.sendOffsetRequest(payloads, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype.pause" id="apidoc.module.kafka-node.HighLevelConsumer.prototype.pause">module kafka-node.HighLevelConsumer.prototype.pause</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.pause.pause" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.pause.pause">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>pause
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pause = function () {
  this.paused = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype.rebalanceAttempt" id="apidoc.module.kafka-node.HighLevelConsumer.prototype.rebalanceAttempt">module kafka-node.HighLevelConsumer.prototype.rebalanceAttempt</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.rebalanceAttempt.rebalanceAttempt" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.rebalanceAttempt.rebalanceAttempt">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>rebalanceAttempt
        <span class="apidocSignatureSpan">(oldTopicPayloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rebalanceAttempt = function (oldTopicPayloads, cb) {
  var self = this;
  // Do the rebalance.....
  var consumerPerTopicMap;
  var newTopicPayloads = [];
  logger.debug('HighLevelConsumer %s is attempting to rebalance', self.id);
  async.series([

    // Stop fetching data and commit offsets
    function (callback) {
      logger.debug('HighLevelConsumer %s stopping data read during rebalance', self.id);
      self.stop(function () {
        callback();
      });
    },

    // Assemble the data
    function (callback) {
      logger.debug('HighLevelConsumer %s assembling data for rebalance', self.id);
      self.client.zk.getConsumersPerTopic(self.options.groupId, function (err, obj) {
        if (err) {
          callback(err);
        } else {
          consumerPerTopicMap = obj;
          callback();
        }
      });
    },

    // Release current partitions
    function (callback) {
      logger.debug('HighLevelConsumer %s releasing current partitions during rebalance', self.id);
      self._releasePartitions(oldTopicPayloads, callback);
    },

    // Rebalance
    function (callback) {
      logger.debug('HighLevelConsumer %s determining the partitions to own during rebalance', self.id);
      logger.debug('consumerPerTopicMap.consumerTopicMap %j', consumerPerTopicMap.consumerTopicMap);
      for (var topic in consumerPerTopicMap.consumerTopicMap[self.id]) {
        if (!consumerPerTopicMap.consumerTopicMap[self.id].hasOwnProperty(topic)) {
          continue;
        }
        var topicToAdd = consumerPerTopicMap.consumerTopicMap[self.id][topic];
        var numberOfConsumers = consumerPerTopicMap.topicConsumerMap[topicToAdd].length;
        var numberOfPartition = consumerPerTopicMap.topicPartitionMap[topicToAdd].length;
        var partitionsPerConsumer = Math.floor(numberOfPartition / numberOfConsumers);
        var extraPartitions = numberOfPartition % numberOfConsumers;
        var currentConsumerIndex;
        for (var index in consumerPerTopicMap.topicConsumerMap[topicToAdd]) {
          if (!consumerPerTopicMap.topicConsumerMap[topicToAdd].hasOwnProperty(index)) {
            continue;
          }
          if (consumerPerTopicMap.topicConsumerMap[topicToAdd][index] === self.id) {
            currentConsumerIndex = parseInt(index);
            break;
          }
        }
        var extraBit = currentConsumerIndex;
        if (currentConsumerIndex &gt; extraPartitions) extraBit = extraPartitions;
        var startPart = partitionsPerConsumer * currentConsumerIndex + extraBit;
        var extraNParts = 1;
        if (currentConsumerIndex + 1 &gt; extraPartitions) extraNParts = 0;
        var nParts = partitionsPerConsumer + extraNParts;

        for (var i = startPart; i &lt; startPart + nParts; i++) {
          newTopicPayloads.push({
            topic: topicToAdd,
            partition: consumerPerTopicMap.topicPartitionMap[topicToAdd][i],
            offset: 0,
            maxBytes: self.options.fetchMaxBytes,
            metadata: 'm'
          });
        }
      }
      logger.debug('newTopicPayloads %j', newTopicPayloads);
      callback();
    },

    // Update ZK with new ownership
    function (callback) {
      if (newTopicPayloads.length) {
        logger.debug('HighLevelConsumer %s gaining ownership of partitions during rebalance', self.id);
        async.eachSeries(newTopicPayloads, function (tp, cbb) {
          if (tp.partition !== undefined) {
            async.series([
              function (addcbb) {
                self.client.zk.checkPartitionOwnership(self.id, self.options.groupId, tp.topic, tp.partition, function (err) {
                  if (err) {
                    // Partition doesn't exist simply carry on
                    addcbb();
                  } else cbb(); // Partition exists simply carry on
                });
              },
              function (addcbb) {
                self.client.zk.addPartitionOwnership(self.id, self.options.groupId, tp.topic, tp.partition, function (err) {
                  if (err) {
                    addcbb(err);
                  } else addcbb(); ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype.registerConsumer" id="apidoc.module.kafka-node.HighLevelConsumer.prototype.registerConsumer">module kafka-node.HighLevelConsumer.prototype.registerConsumer</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.registerConsumer.registerConsumer" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.registerConsumer.registerConsumer">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>registerConsumer
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerConsumer = function (cb) {
  var self = this;
  var groupId = this.options.groupId;
  this.client.zk.registerConsumer(groupId, this.id, this.payloads, function (err) {
    if (err) return cb(err);
    self.client.zk.listConsumers(self.options.groupId);
    var topics = self.topicPayloads.reduce(function (ret, topicPayload) {
      if (ret.indexOf(topicPayload.topic) === -1) {
        ret.push(topicPayload.topic);
      }
      return ret;
    }, []);
    topics.forEach(function (topic) {
      self.client.zk.listPartitions(topic);
    });
    cb();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype.removeTopics" id="apidoc.module.kafka-node.HighLevelConsumer.prototype.removeTopics">module kafka-node.HighLevelConsumer.prototype.removeTopics</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.removeTopics.removeTopics" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.removeTopics.removeTopics">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>removeTopics
        <span class="apidocSignatureSpan">(topics, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeTopics = function (topics, cb) {
  topics = typeof topics === 'string' ? [topics] : topics;
  this.payloads = this.payloads.filter(function (p) {
    return !~topics.indexOf(p.topic);
  });

  this.client.removeTopicMetadata(topics, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### removeTopics(topics, cb)
* `topics`: **Array**, array of topics to remove
* `cb`: **Function**, the callback

Example:

``` js
consumer.<span class="apidocCodeKeywordSpan">removeTopics</span>(['t1', 't2'], function (err, removed) {
});
```

### commit(cb)
Commit offset of the current topics manually, this method should be called when a consumer leaves

* `cb`: **Function**, the callback
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype.resume" id="apidoc.module.kafka-node.HighLevelConsumer.prototype.resume">module kafka-node.HighLevelConsumer.prototype.resume</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.resume.resume" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.resume.resume">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>resume
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resume = function () {
  this.paused = false;
  this.fetch();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype.sendOffsetCommitRequest" id="apidoc.module.kafka-node.HighLevelConsumer.prototype.sendOffsetCommitRequest">module kafka-node.HighLevelConsumer.prototype.sendOffsetCommitRequest</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.sendOffsetCommitRequest.sendOffsetCommitRequest" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.sendOffsetCommitRequest.sendOffsetCommitRequest">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>sendOffsetCommitRequest
        <span class="apidocSignatureSpan">(commits, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendOffsetCommitRequest = function (commits, cb) {
  this.client.sendOffsetCommitRequest(this.options.groupId, commits, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype.setOffset" id="apidoc.module.kafka-node.HighLevelConsumer.prototype.setOffset">module kafka-node.HighLevelConsumer.prototype.setOffset</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.setOffset.setOffset" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.setOffset.setOffset">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>setOffset
        <span class="apidocSignatureSpan">(topic, partition, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setOffset = function (topic, partition, offset) {
  this.topicPayloads.every(function (p) {
    if (p.topic === topic &amp;&amp; p.partition == partition) { // eslint-disable-line eqeqeq
      p.offset = offset;
      return false;
    }
    return true;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `partition`: **Number**

* `offset`: **Number**

Example:

``` js
consumer.<span class="apidocCodeKeywordSpan">setOffset</span>('topic', 0, 0);
```

### pause()
Pause the consumer. ***Calling `pause` does not automatically stop messages from being emitted.*** This is because pause just stops
 the kafka consumer fetch loop. Each iteration of the fetch loop can obtain a batch of messages (limited by `fetchMaxBytes`).

### resume()
Resume the consumer. Resumes the fetch loop.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype.stop" id="apidoc.module.kafka-node.HighLevelConsumer.prototype.stop">module kafka-node.HighLevelConsumer.prototype.stop</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.stop.stop" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.stop.stop">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>stop
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stop = function (cb) {
  if (!this.options.autoCommit) return cb &amp;&amp; cb();
  this.commit(true, function (err) {
    cb &amp;&amp; cb(err);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype.updateOffsets" id="apidoc.module.kafka-node.HighLevelConsumer.prototype.updateOffsets">module kafka-node.HighLevelConsumer.prototype.updateOffsets</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.updateOffsets.updateOffsets" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.updateOffsets.updateOffsets">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>updateOffsets
        <span class="apidocSignatureSpan">(topics, initing)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateOffsets = function (topics, initing) {
  this.topicPayloads.forEach(p =&gt; {
    if (!_.isEmpty(topics[p.topic]) &amp;&amp; topics[p.topic][p.partition] !== undefined) {
      var offset = topics[p.topic][p.partition];
      if (offset === -1) offset = 0;
      if (!initing) p.offset = offset + 1;
      else p.offset = offset;
      this.needToCommit = true;
    }
  });

  if (this.options.autoCommit &amp;&amp; !initing) {
    this.autoCommit(false, function (err) {
      err &amp;&amp; logger.debug('auto commit offset', err);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.HighLevelProducer" id="apidoc.module.kafka-node.HighLevelProducer">module kafka-node.HighLevelProducer</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelProducer.HighLevelProducer" id="apidoc.element.kafka-node.HighLevelProducer.HighLevelProducer">
        function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelProducer
        <span class="apidocSignatureSpan">(client, options, customPartitioner)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HighLevelProducer(client, options, customPartitioner) {
  BaseProducer.call(this, client, options, BaseProducer.PARTITIONER_TYPES.cyclic, customPartitioner);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelProducer.super_" id="apidoc.element.kafka-node.HighLevelProducer.super_">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.</span>super_
        <span class="apidocSignatureSpan">(client, options, defaultPartitionerType, customPartitioner)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BaseProducer(client, options, defaultPartitionerType, customPartitioner) {
  options = options || {};

  this.ready = false;
  this.client = client;

  this.requireAcks = options.requireAcks === undefined
    ? DEFAULTS.requireAcks
    : options.requireAcks;
  this.ackTimeoutMs = options.ackTimeoutMs === undefined
    ? DEFAULTS.ackTimeoutMs
    : options.ackTimeoutMs;

  if (customPartitioner !== undefined &amp;&amp; options.partitionerType !== PARTITIONER_TYPES.custom) {
    throw new Error('Partitioner Type must be custom if providing a customPartitioner.');
  } else if (customPartitioner === undefined &amp;&amp; options.partitionerType === PARTITIONER_TYPES.custom) {
    throw new Error('No customer partitioner defined');
  }

  var partitionerType = PARTITIONER_MAP[options.partitionerType] || PARTITIONER_MAP[defaultPartitionerType];

  // eslint-disable-next-line
  this.partitioner = new partitionerType(customPartitioner);

  this.connect();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.HighLevelProducer.super_" id="apidoc.module.kafka-node.HighLevelProducer.super_">module kafka-node.HighLevelProducer.super_</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelProducer.super_.super_" id="apidoc.element.kafka-node.HighLevelProducer.super_.super_">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.HighLevelProducer.super_.prototype" id="apidoc.module.kafka-node.HighLevelProducer.super_.prototype">module kafka-node.HighLevelProducer.super_.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.buildPayloads" id="apidoc.element.kafka-node.HighLevelProducer.super_.prototype.buildPayloads">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.super_.prototype.</span>buildPayloads
        <span class="apidocSignatureSpan">(payloads, topicMetadata)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildPayloads = function (payloads, topicMetadata) {
  const topicPartitionRequests = Object.create(null);
  payloads.forEach((p) =&gt; {
    p.partition = p.hasOwnProperty('partition') ? p.partition : this.partitioner.getPartition(_.map(topicMetadata[p.topic], 'partition
'), p.key);
    p.attributes = p.hasOwnProperty('attributes') ? p.attributes : 0;
    let messages = _.isArray(p.messages) ? p.messages : [p.messages];

    messages = messages.map(function (message) {
      if (message instanceof KeyedMessage) {
        return message;
      }
      return new Message(0, 0, '', message);
    });

    let key = p.topic + p.partition;
    let request = topicPartitionRequests[key];

    if (request == null) {
      topicPartitionRequests[key] = new ProduceRequest(p.topic, p.partition, messages, p.attributes);
    } else {
      assert(request.attributes === p.attributes);
      Array.prototype.push.apply(request.messages, messages);
    }
  });
  return _.values(topicPartitionRequests);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.close" id="apidoc.element.kafka-node.HighLevelProducer.super_.prototype.close">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.super_.prototype.</span>close
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (cb) {
  this.client.close(cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### close(force, cb)
* `force`: **Boolean**, if set to true, it forces the consumer to commit the current offset before closing, default `false`

Example

```js
consumer.<span class="apidocCodeKeywordSpan">close</span>(true, cb);
consumer.close(cb); //force is disabled
```

## HighLevelConsumer
âš&nbsp;ï¸ ***This consumer has been deprecated in the latest version of Kafka (0.10.1) and is likely to be removed in the future. Please
 use the ConsumerGroup instead.***

### HighLevelConsumer(client, payloads, options)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.connect" id="apidoc.element.kafka-node.HighLevelProducer.super_.prototype.connect">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.super_.prototype.</span>connect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connect = function () {
  // emiter...
  var self = this;
  this.ready = this.client.ready;
  if (this.ready) self.emit('ready');
  this.client.on('ready', function () {
    if (!self.ready) {
      self.ready = true;
      self.emit('ready');
    }
  });
  this.client.on('brokersChanged', function () {
    let topics = Object.keys(this.topicMetadata);
    this.refreshMetadata(topics, function (error) {
      if (error) {
        self.emit('error', error);
      }
    });
  });
  this.client.on('error', function (err) {
    self.emit('error', err);
  });
  this.client.on('close', function () {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    });

    this.on('topicOwnerChange', _.debounce(function (topics) {
      verified = 0;
      self.checkForOwnersAndListenForChange(topics);
    }, 250));

    this.zk.<span class="apidocCodeKeywordSpan">connect</span>();
  } else {
    this.connectConsumerGroup();
  }
}

util.inherits(ConsumerGroupMigrator, EventEmitter);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.createTopics" id="apidoc.element.kafka-node.HighLevelProducer.super_.prototype.createTopics">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.super_.prototype.</span>createTopics
        <span class="apidocSignatureSpan">(topics, async, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createTopics = function (topics, async, cb) {
  if (!this.ready) {
    return cb(new Error('Producer not ready!'));
  }

  this.client.createTopics(topics, async, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

``` js
var kafka = require('kafka-node'),
    Producer = kafka.Producer,
    client = new kafka.Client(),
    producer = new Producer(client);
// Create topics sync
producer.<span class="apidocCodeKeywordSpan">createTopics</span>(['t','t1'], false, function (err, data) {
    console.log(data);
});
// Create topics async
producer.createTopics(['t'], true, function (err, data) {});
producer.createTopics(['t'], function (err, data) {});// Simply omit 2nd arg
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.send" id="apidoc.element.kafka-node.HighLevelProducer.super_.prototype.send">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.super_.prototype.</span>send
        <span class="apidocSignatureSpan">(payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">send = function (payloads, cb) {
  var client = this.client;
  var requireAcks = this.requireAcks;
  var ackTimeoutMs = this.ackTimeoutMs;

  client.sendProduceRequest(this.buildPayloads(payloads, client.topicMetadata), requireAcks, ackTimeoutMs, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    producer = new Producer(client),
    km = new KeyedMessage('key', 'message'),
    payloads = [
        { topic: 'topic1', messages: 'hi', partition: 0 },
        { topic: 'topic2', messages: ['hello', 'world', km] }
    ];
producer.on('ready', function () {
    producer.<span class="apidocCodeKeywordSpan">send</span>(payloads, function (err, data) {
        console.log(data);
    });
});

producer.on('error', function (err) {})
```
&gt; âš&nbsp;ï¸**WARNING**: Batch multiple messages of the same topic/partition together as an array on the `messages` attribute otherwise
 you may lose messages!
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.HighLevelProducer.super_.prototype.buildPayloads" id="apidoc.module.kafka-node.HighLevelProducer.super_.prototype.buildPayloads">module kafka-node.HighLevelProducer.super_.prototype.buildPayloads</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.buildPayloads.buildPayloads" id="apidoc.element.kafka-node.HighLevelProducer.super_.prototype.buildPayloads.buildPayloads">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.super_.prototype.</span>buildPayloads
        <span class="apidocSignatureSpan">(payloads, topicMetadata)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildPayloads = function (payloads, topicMetadata) {
  const topicPartitionRequests = Object.create(null);
  payloads.forEach((p) =&gt; {
    p.partition = p.hasOwnProperty('partition') ? p.partition : this.partitioner.getPartition(_.map(topicMetadata[p.topic], 'partition
'), p.key);
    p.attributes = p.hasOwnProperty('attributes') ? p.attributes : 0;
    let messages = _.isArray(p.messages) ? p.messages : [p.messages];

    messages = messages.map(function (message) {
      if (message instanceof KeyedMessage) {
        return message;
      }
      return new Message(0, 0, '', message);
    });

    let key = p.topic + p.partition;
    let request = topicPartitionRequests[key];

    if (request == null) {
      topicPartitionRequests[key] = new ProduceRequest(p.topic, p.partition, messages, p.attributes);
    } else {
      assert(request.attributes === p.attributes);
      Array.prototype.push.apply(request.messages, messages);
    }
  });
  return _.values(topicPartitionRequests);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.HighLevelProducer.super_.prototype.close" id="apidoc.module.kafka-node.HighLevelProducer.super_.prototype.close">module kafka-node.HighLevelProducer.super_.prototype.close</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.close.close" id="apidoc.element.kafka-node.HighLevelProducer.super_.prototype.close.close">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.super_.prototype.</span>close
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (cb) {
  this.client.close(cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### close(force, cb)
* `force`: **Boolean**, if set to true, it forces the consumer to commit the current offset before closing, default `false`

Example

```js
consumer.<span class="apidocCodeKeywordSpan">close</span>(true, cb);
consumer.close(cb); //force is disabled
```

## HighLevelConsumer
âš&nbsp;ï¸ ***This consumer has been deprecated in the latest version of Kafka (0.10.1) and is likely to be removed in the future. Please
 use the ConsumerGroup instead.***

### HighLevelConsumer(client, payloads, options)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.HighLevelProducer.super_.prototype.connect" id="apidoc.module.kafka-node.HighLevelProducer.super_.prototype.connect">module kafka-node.HighLevelProducer.super_.prototype.connect</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.connect.connect" id="apidoc.element.kafka-node.HighLevelProducer.super_.prototype.connect.connect">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.super_.prototype.</span>connect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connect = function () {
  // emiter...
  var self = this;
  this.ready = this.client.ready;
  if (this.ready) self.emit('ready');
  this.client.on('ready', function () {
    if (!self.ready) {
      self.ready = true;
      self.emit('ready');
    }
  });
  this.client.on('brokersChanged', function () {
    let topics = Object.keys(this.topicMetadata);
    this.refreshMetadata(topics, function (error) {
      if (error) {
        self.emit('error', error);
      }
    });
  });
  this.client.on('error', function (err) {
    self.emit('error', err);
  });
  this.client.on('close', function () {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    });

    this.on('topicOwnerChange', _.debounce(function (topics) {
      verified = 0;
      self.checkForOwnersAndListenForChange(topics);
    }, 250));

    this.zk.<span class="apidocCodeKeywordSpan">connect</span>();
  } else {
    this.connectConsumerGroup();
  }
}

util.inherits(ConsumerGroupMigrator, EventEmitter);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.HighLevelProducer.super_.prototype.createTopics" id="apidoc.module.kafka-node.HighLevelProducer.super_.prototype.createTopics">module kafka-node.HighLevelProducer.super_.prototype.createTopics</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.createTopics.createTopics" id="apidoc.element.kafka-node.HighLevelProducer.super_.prototype.createTopics.createTopics">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.super_.prototype.</span>createTopics
        <span class="apidocSignatureSpan">(topics, async, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createTopics = function (topics, async, cb) {
  if (!this.ready) {
    return cb(new Error('Producer not ready!'));
  }

  this.client.createTopics(topics, async, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

``` js
var kafka = require('kafka-node'),
    Producer = kafka.Producer,
    client = new kafka.Client(),
    producer = new Producer(client);
// Create topics sync
producer.<span class="apidocCodeKeywordSpan">createTopics</span>(['t','t1'], false, function (err, data) {
    console.log(data);
});
// Create topics async
producer.createTopics(['t'], true, function (err, data) {});
producer.createTopics(['t'], function (err, data) {});// Simply omit 2nd arg
```
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.HighLevelProducer.super_.prototype.send" id="apidoc.module.kafka-node.HighLevelProducer.super_.prototype.send">module kafka-node.HighLevelProducer.super_.prototype.send</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.send.send" id="apidoc.element.kafka-node.HighLevelProducer.super_.prototype.send.send">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.super_.prototype.</span>send
        <span class="apidocSignatureSpan">(payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">send = function (payloads, cb) {
  var client = this.client;
  var requireAcks = this.requireAcks;
  var ackTimeoutMs = this.ackTimeoutMs;

  client.sendProduceRequest(this.buildPayloads(payloads, client.topicMetadata), requireAcks, ackTimeoutMs, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    producer = new Producer(client),
    km = new KeyedMessage('key', 'message'),
    payloads = [
        { topic: 'topic1', messages: 'hi', partition: 0 },
        { topic: 'topic2', messages: ['hello', 'world', km] }
    ];
producer.on('ready', function () {
    producer.<span class="apidocCodeKeywordSpan">send</span>(payloads, function (err, data) {
        console.log(data);
    });
});

producer.on('error', function (err) {})
```
&gt; âš&nbsp;ï¸**WARNING**: Batch multiple messages of the same topic/partition together as an array on the `messages` attribute otherwise
 you may lose messages!
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.KeyedMessage" id="apidoc.module.kafka-node.KeyedMessage">module kafka-node.KeyedMessage</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.KeyedMessage.KeyedMessage" id="apidoc.element.kafka-node.KeyedMessage.KeyedMessage">
        function <span class="apidocSignatureSpan">kafka-node.</span>KeyedMessage
        <span class="apidocSignatureSpan">(key, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function KeyedMessage(key, value) {
  exports.Message.call(this, 0, 0, key, value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.KeyedPartitioner" id="apidoc.module.kafka-node.KeyedPartitioner">module kafka-node.KeyedPartitioner</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.KeyedPartitioner.KeyedPartitioner" id="apidoc.element.kafka-node.KeyedPartitioner.KeyedPartitioner">
        function <span class="apidocSignatureSpan">kafka-node.</span>KeyedPartitioner
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">KeyedPartitioner = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.KeyedPartitioner.super_" id="apidoc.element.kafka-node.KeyedPartitioner.super_">
        function <span class="apidocSignatureSpan">kafka-node.KeyedPartitioner.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.KeyedPartitioner.prototype" id="apidoc.module.kafka-node.KeyedPartitioner.prototype">module kafka-node.KeyedPartitioner.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.KeyedPartitioner.prototype.getPartition" id="apidoc.element.kafka-node.KeyedPartitioner.prototype.getPartition">
        function <span class="apidocSignatureSpan">kafka-node.KeyedPartitioner.prototype.</span>getPartition
        <span class="apidocSignatureSpan">(partitions, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPartition = function (partitions, key) {
  key = key || '';

  var index = this.hashCode(key) % partitions.length;
  return partitions[index];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.KeyedPartitioner.prototype.hashCode" id="apidoc.element.kafka-node.KeyedPartitioner.prototype.hashCode">
        function <span class="apidocSignatureSpan">kafka-node.KeyedPartitioner.prototype.</span>hashCode
        <span class="apidocSignatureSpan">(string)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hashCode = function (string) {
  var hash = 0;
  var length = string.length;

  for (var i = 0; i &lt; length; i++) {
    hash = ((hash * 31) + string.charCodeAt(i)) &amp; 0x7fffffff;
  }

  return (hash === 0) ? 1 : hash;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  return (hash === 0) ? 1 : hash;
};

KeyedPartitioner.prototype.getPartition = function (partitions, key) {
  key = key || '';

  var index = this.<span class="apidocCodeKeywordSpan">hashCode</span>(key) % partitions.length;
  return partitions[index];
};

var CustomPartitioner = function (partitioner) {
  this.getPartition = partitioner;
};
util.inherits(CustomPartitioner, Partitioner);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.KeyedPartitioner.prototype.getPartition" id="apidoc.module.kafka-node.KeyedPartitioner.prototype.getPartition">module kafka-node.KeyedPartitioner.prototype.getPartition</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.KeyedPartitioner.prototype.getPartition.getPartition" id="apidoc.element.kafka-node.KeyedPartitioner.prototype.getPartition.getPartition">
        function <span class="apidocSignatureSpan">kafka-node.KeyedPartitioner.prototype.</span>getPartition
        <span class="apidocSignatureSpan">(partitions, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPartition = function (partitions, key) {
  key = key || '';

  var index = this.hashCode(key) % partitions.length;
  return partitions[index];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.KeyedPartitioner.prototype.hashCode" id="apidoc.module.kafka-node.KeyedPartitioner.prototype.hashCode">module kafka-node.KeyedPartitioner.prototype.hashCode</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.KeyedPartitioner.prototype.hashCode.hashCode" id="apidoc.element.kafka-node.KeyedPartitioner.prototype.hashCode.hashCode">
        function <span class="apidocSignatureSpan">kafka-node.KeyedPartitioner.prototype.</span>hashCode
        <span class="apidocSignatureSpan">(string)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hashCode = function (string) {
  var hash = 0;
  var length = string.length;

  for (var i = 0; i &lt; length; i++) {
    hash = ((hash * 31) + string.charCodeAt(i)) &amp; 0x7fffffff;
  }

  return (hash === 0) ? 1 : hash;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  return (hash === 0) ? 1 : hash;
};

KeyedPartitioner.prototype.getPartition = function (partitions, key) {
  key = key || '';

  var index = this.<span class="apidocCodeKeywordSpan">hashCode</span>(key) % partitions.length;
  return partitions[index];
};

var CustomPartitioner = function (partitioner) {
  this.getPartition = partitioner;
};
util.inherits(CustomPartitioner, Partitioner);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Offset" id="apidoc.module.kafka-node.Offset">module kafka-node.Offset</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Offset.Offset" id="apidoc.element.kafka-node.Offset.Offset">
        function <span class="apidocSignatureSpan">kafka-node.</span>Offset
        <span class="apidocSignatureSpan">(client)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Offset = function (client) {
  var self = this;
  this.client = client;
  this.ready = this.client.ready;
  this.client.on('ready', function () {
    self.ready = true;
    self.emit('ready');
  });
  this.client.once('connect', function () {
    self.emit('connect');
  });
  this.client.on('error', function (err) {
    self.emit('error', err);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `cb`: *Function*, the callback

Example

```js
var kafka = require('kafka-node'),
    client = new kafka.Client(),
    offset = new kafka.<span class="apidocCodeKeywordSpan">Offset</span>(client);
    offset.fetch([
        { topic: 't', partition: 0, time: Date.now(), maxNum: 1 }
    ], function (err, data) {
        // data
        // { 't': { '0': [999] } }
    });
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Offset.super_" id="apidoc.element.kafka-node.Offset.super_">
        function <span class="apidocSignatureSpan">kafka-node.Offset.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Offset.prototype" id="apidoc.module.kafka-node.Offset.prototype">module kafka-node.Offset.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Offset.prototype.buildPayloads" id="apidoc.element.kafka-node.Offset.prototype.buildPayloads">
        function <span class="apidocSignatureSpan">kafka-node.Offset.prototype.</span>buildPayloads
        <span class="apidocSignatureSpan">(payloads)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildPayloads = function (payloads) {
  return payloads.map(function (p) {
    p.partition = p.partition || 0;
    p.time = p.time || Date.now();
    p.maxNum = p.maxNum || 1;
    p.metadata = 'm'; // metadata can be arbitrary
    return p;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Offset.prototype.commit" id="apidoc.element.kafka-node.Offset.prototype.commit">
        function <span class="apidocSignatureSpan">kafka-node.Offset.prototype.</span>commit
        <span class="apidocSignatureSpan">(groupId, payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">commit = function (groupId, payloads, cb) {
  if (!this.ready) {
    this.once('ready', () =&gt; this.commit(groupId, payloads, cb));
    return;
  }
  this.client.sendOffsetCommitRequest(groupId, this.buildPayloads(payloads), cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Commit offset of the current topics manually, this method should be called when a consumer leaves

* `cb`: **Function**, the callback

Example:

``` js
consumer.<span class="apidocCodeKeywordSpan">commit</span>(function(err, data) {
});
```

### setOffset(topic, partition, offset)
Set offset of the given topic

* `topic`: **String**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Offset.prototype.fetch" id="apidoc.element.kafka-node.Offset.prototype.fetch">
        function <span class="apidocSignatureSpan">kafka-node.Offset.prototype.</span>fetch
        <span class="apidocSignatureSpan">(payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetch = function (payloads, cb) {
  if (!this.ready) {
    this.once('ready', () =&gt; this.fetch(payloads, cb));
    return;
  }
  this.client.sendOffsetRequest(this.buildPayloads(payloads), cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Example

```js
var kafka = require('kafka-node'),
    client = new kafka.Client(),
    offset = new kafka.Offset(client);
    offset.<span class="apidocCodeKeywordSpan">fetch</span>([
        { topic: 't', partition: 0, time: Date.now(), maxNum: 1 }
    ], function (err, data) {
        // data
        // { 't': { '0': [999] } }
    });
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Offset.prototype.fetchCommits" id="apidoc.element.kafka-node.Offset.prototype.fetchCommits">
        function <span class="apidocSignatureSpan">kafka-node.Offset.prototype.</span>fetchCommits
        <span class="apidocSignatureSpan">(groupId, payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetchCommits = function (groupId, payloads, cb) {
  if (!this.ready) {
    this.once('ready', () =&gt; this.fetchCommits(groupId, payloads, cb));
    return;
  }
  this.client.sendOffsetFetchRequest(groupId, this.buildPayloads(payloads), cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Example

```js
var kafka = require('kafka-node'),
    client = new kafka.Client(),
    offset = new kafka.Offset(client);
    offset.<span class="apidocCodeKeywordSpan">fetchCommits</span>('groupId', [
        { topic: 't', partition: 0 }
    ], function (err, data) {
    });
```

### fetchLatestOffsets(topics, cb)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Offset.prototype.fetchEarliestOffsets" id="apidoc.element.kafka-node.Offset.prototype.fetchEarliestOffsets">
        function <span class="apidocSignatureSpan">kafka-node.Offset.prototype.</span>fetchEarliestOffsets
        <span class="apidocSignatureSpan">(topics, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetchEarliestOffsets = function (topics, cb) {
  fetchOffsets(this, topics, cb, -2);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### fetchEarliestOffsets(topics, cb)

Example

```js
	var partition = 0;
	var topic = 't';
	offset.<span class="apidocCodeKeywordSpan">fetchEarliestOffsets</span>([topic], function (error, offsets) {
		if (error)
			return handleError(error);
		console.log(offsets[topic][partition]);
	});
```

# Troubleshooting / FAQ
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Offset.prototype.fetchLatestOffsets" id="apidoc.element.kafka-node.Offset.prototype.fetchLatestOffsets">
        function <span class="apidocSignatureSpan">kafka-node.Offset.prototype.</span>fetchLatestOffsets
        <span class="apidocSignatureSpan">(topics, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetchLatestOffsets = function (topics, cb) {
  fetchOffsets(this, topics, cb, -1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### fetchLatestOffsets(topics, cb)

Example

```js
	var partition = 0;
	var topic = 't';
	offset.<span class="apidocCodeKeywordSpan">fetchLatestOffsets</span>([topic], function (error, offsets) {
		if (error)
			return handleError(error);
		console.log(offsets[topic][partition]);
	});
```

### fetchEarliestOffsets(topics, cb)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Offset.prototype.buildPayloads" id="apidoc.module.kafka-node.Offset.prototype.buildPayloads">module kafka-node.Offset.prototype.buildPayloads</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Offset.prototype.buildPayloads.buildPayloads" id="apidoc.element.kafka-node.Offset.prototype.buildPayloads.buildPayloads">
        function <span class="apidocSignatureSpan">kafka-node.Offset.prototype.</span>buildPayloads
        <span class="apidocSignatureSpan">(payloads)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildPayloads = function (payloads) {
  return payloads.map(function (p) {
    p.partition = p.partition || 0;
    p.time = p.time || Date.now();
    p.maxNum = p.maxNum || 1;
    p.metadata = 'm'; // metadata can be arbitrary
    return p;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Offset.prototype.commit" id="apidoc.module.kafka-node.Offset.prototype.commit">module kafka-node.Offset.prototype.commit</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Offset.prototype.commit.commit" id="apidoc.element.kafka-node.Offset.prototype.commit.commit">
        function <span class="apidocSignatureSpan">kafka-node.Offset.prototype.</span>commit
        <span class="apidocSignatureSpan">(groupId, payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">commit = function (groupId, payloads, cb) {
  if (!this.ready) {
    this.once('ready', () =&gt; this.commit(groupId, payloads, cb));
    return;
  }
  this.client.sendOffsetCommitRequest(groupId, this.buildPayloads(payloads), cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Commit offset of the current topics manually, this method should be called when a consumer leaves

* `cb`: **Function**, the callback

Example:

``` js
consumer.<span class="apidocCodeKeywordSpan">commit</span>(function(err, data) {
});
```

### setOffset(topic, partition, offset)
Set offset of the given topic

* `topic`: **String**
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Offset.prototype.fetch" id="apidoc.module.kafka-node.Offset.prototype.fetch">module kafka-node.Offset.prototype.fetch</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Offset.prototype.fetch.fetch" id="apidoc.element.kafka-node.Offset.prototype.fetch.fetch">
        function <span class="apidocSignatureSpan">kafka-node.Offset.prototype.</span>fetch
        <span class="apidocSignatureSpan">(payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetch = function (payloads, cb) {
  if (!this.ready) {
    this.once('ready', () =&gt; this.fetch(payloads, cb));
    return;
  }
  this.client.sendOffsetRequest(this.buildPayloads(payloads), cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Example

```js
var kafka = require('kafka-node'),
    client = new kafka.Client(),
    offset = new kafka.Offset(client);
    offset.<span class="apidocCodeKeywordSpan">fetch</span>([
        { topic: 't', partition: 0, time: Date.now(), maxNum: 1 }
    ], function (err, data) {
        // data
        // { 't': { '0': [999] } }
    });
```
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Offset.prototype.fetchCommits" id="apidoc.module.kafka-node.Offset.prototype.fetchCommits">module kafka-node.Offset.prototype.fetchCommits</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Offset.prototype.fetchCommits.fetchCommits" id="apidoc.element.kafka-node.Offset.prototype.fetchCommits.fetchCommits">
        function <span class="apidocSignatureSpan">kafka-node.Offset.prototype.</span>fetchCommits
        <span class="apidocSignatureSpan">(groupId, payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetchCommits = function (groupId, payloads, cb) {
  if (!this.ready) {
    this.once('ready', () =&gt; this.fetchCommits(groupId, payloads, cb));
    return;
  }
  this.client.sendOffsetFetchRequest(groupId, this.buildPayloads(payloads), cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Example

```js
var kafka = require('kafka-node'),
    client = new kafka.Client(),
    offset = new kafka.Offset(client);
    offset.<span class="apidocCodeKeywordSpan">fetchCommits</span>('groupId', [
        { topic: 't', partition: 0 }
    ], function (err, data) {
    });
```

### fetchLatestOffsets(topics, cb)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Offset.prototype.fetchEarliestOffsets" id="apidoc.module.kafka-node.Offset.prototype.fetchEarliestOffsets">module kafka-node.Offset.prototype.fetchEarliestOffsets</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Offset.prototype.fetchEarliestOffsets.fetchEarliestOffsets" id="apidoc.element.kafka-node.Offset.prototype.fetchEarliestOffsets.fetchEarliestOffsets">
        function <span class="apidocSignatureSpan">kafka-node.Offset.prototype.</span>fetchEarliestOffsets
        <span class="apidocSignatureSpan">(topics, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetchEarliestOffsets = function (topics, cb) {
  fetchOffsets(this, topics, cb, -2);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### fetchEarliestOffsets(topics, cb)

Example

```js
	var partition = 0;
	var topic = 't';
	offset.<span class="apidocCodeKeywordSpan">fetchEarliestOffsets</span>([topic], function (error, offsets) {
		if (error)
			return handleError(error);
		console.log(offsets[topic][partition]);
	});
```

# Troubleshooting / FAQ
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Offset.prototype.fetchLatestOffsets" id="apidoc.module.kafka-node.Offset.prototype.fetchLatestOffsets">module kafka-node.Offset.prototype.fetchLatestOffsets</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Offset.prototype.fetchLatestOffsets.fetchLatestOffsets" id="apidoc.element.kafka-node.Offset.prototype.fetchLatestOffsets.fetchLatestOffsets">
        function <span class="apidocSignatureSpan">kafka-node.Offset.prototype.</span>fetchLatestOffsets
        <span class="apidocSignatureSpan">(topics, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetchLatestOffsets = function (topics, cb) {
  fetchOffsets(this, topics, cb, -1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### fetchLatestOffsets(topics, cb)

Example

```js
	var partition = 0;
	var topic = 't';
	offset.<span class="apidocCodeKeywordSpan">fetchLatestOffsets</span>([topic], function (error, offsets) {
		if (error)
			return handleError(error);
		console.log(offsets[topic][partition]);
	});
```

### fetchEarliestOffsets(topics, cb)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Producer" id="apidoc.module.kafka-node.Producer">module kafka-node.Producer</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Producer.Producer" id="apidoc.element.kafka-node.Producer.Producer">
        function <span class="apidocSignatureSpan">kafka-node.</span>Producer
        <span class="apidocSignatureSpan">(client, options, customPartitioner)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Producer(client, options, customPartitioner) {
  BaseProducer.call(this, client, options, BaseProducer.PARTITIONER_TYPES.default, customPartitioner);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Producer.super_" id="apidoc.element.kafka-node.Producer.super_">
        function <span class="apidocSignatureSpan">kafka-node.Producer.</span>super_
        <span class="apidocSignatureSpan">(client, options, defaultPartitionerType, customPartitioner)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BaseProducer(client, options, defaultPartitionerType, customPartitioner) {
  options = options || {};

  this.ready = false;
  this.client = client;

  this.requireAcks = options.requireAcks === undefined
    ? DEFAULTS.requireAcks
    : options.requireAcks;
  this.ackTimeoutMs = options.ackTimeoutMs === undefined
    ? DEFAULTS.ackTimeoutMs
    : options.ackTimeoutMs;

  if (customPartitioner !== undefined &amp;&amp; options.partitionerType !== PARTITIONER_TYPES.custom) {
    throw new Error('Partitioner Type must be custom if providing a customPartitioner.');
  } else if (customPartitioner === undefined &amp;&amp; options.partitionerType === PARTITIONER_TYPES.custom) {
    throw new Error('No customer partitioner defined');
  }

  var partitionerType = PARTITIONER_MAP[options.partitionerType] || PARTITIONER_MAP[defaultPartitionerType];

  // eslint-disable-next-line
  this.partitioner = new partitionerType(customPartitioner);

  this.connect();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.RandomPartitioner" id="apidoc.module.kafka-node.RandomPartitioner">module kafka-node.RandomPartitioner</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.RandomPartitioner.RandomPartitioner" id="apidoc.element.kafka-node.RandomPartitioner.RandomPartitioner">
        function <span class="apidocSignatureSpan">kafka-node.</span>RandomPartitioner
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RandomPartitioner = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.RandomPartitioner.super_" id="apidoc.element.kafka-node.RandomPartitioner.super_">
        function <span class="apidocSignatureSpan">kafka-node.RandomPartitioner.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.RandomPartitioner.prototype" id="apidoc.module.kafka-node.RandomPartitioner.prototype">module kafka-node.RandomPartitioner.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.RandomPartitioner.prototype.getPartition" id="apidoc.element.kafka-node.RandomPartitioner.prototype.getPartition">
        function <span class="apidocSignatureSpan">kafka-node.RandomPartitioner.prototype.</span>getPartition
        <span class="apidocSignatureSpan">(partitions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPartition = function (partitions) {
  return partitions[Math.floor(Math.random() * partitions.length)];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.RandomPartitioner.prototype.getPartition" id="apidoc.module.kafka-node.RandomPartitioner.prototype.getPartition">module kafka-node.RandomPartitioner.prototype.getPartition</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.RandomPartitioner.prototype.getPartition.getPartition" id="apidoc.element.kafka-node.RandomPartitioner.prototype.getPartition.getPartition">
        function <span class="apidocSignatureSpan">kafka-node.RandomPartitioner.prototype.</span>getPartition
        <span class="apidocSignatureSpan">(partitions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPartition = function (partitions) {
  return partitions[Math.floor(Math.random() * partitions.length)];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.consumerGroupHeartbeat" id="apidoc.module.kafka-node.consumerGroupHeartbeat">module kafka-node.consumerGroupHeartbeat</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.consumerGroupHeartbeat.consumerGroupHeartbeat" id="apidoc.element.kafka-node.consumerGroupHeartbeat.consumerGroupHeartbeat">
        function <span class="apidocSignatureSpan">kafka-node.</span>consumerGroupHeartbeat
        <span class="apidocSignatureSpan">(client, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Heartbeat {
  constructor (client, handler) {
    this.client = client;
    this.handler = handler;
    this.pending = true;
  }

  send (groupId, generationId, memberId) {
    this.client.sendHeartbeatRequest(groupId, generationId, memberId, (error) =&gt; {
      if (this.canceled) {
        logger.debug('heartbeat yielded after being canceled', error);
        return;
      }
      this.pending = false;
      this.handler(error);
    });
  }

  verifyResolved () {
    if (this.pending) {
      this.canceled = true;
      this.pending = false;
      this.handler(new HeartbeatTimeoutError('Heartbeat timed out'));
      return false;
    }
    return true;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.consumerGroupMigrator" id="apidoc.module.kafka-node.consumerGroupMigrator">module kafka-node.consumerGroupMigrator</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.consumerGroupMigrator.consumerGroupMigrator" id="apidoc.element.kafka-node.consumerGroupMigrator.consumerGroupMigrator">
        function <span class="apidocSignatureSpan">kafka-node.</span>consumerGroupMigrator
        <span class="apidocSignatureSpan">(consumerGroup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ConsumerGroupMigrator(consumerGroup) {
  EventEmitter.call(this);
  assert(consumerGroup);
  const self = this;
  this.consumerGroup = consumerGroup;
  this.client = consumerGroup.client;
  var verified = 0;

  if (consumerGroup.options.migrateRolling) {
    this.zk = zookeeper.createClient(consumerGroup.client.connectionString, {retries: 10});
    this.zk.on('connected', function () {
      self.filterByExistingZkTopics(function (error, topics) {
        if (error) {
          return self.emit('error', error);
        }

        if (topics.length) {
          self.checkForOwnersAndListenForChange(topics);
        } else {
          logger.debug('No HLC topics exist in zookeeper.');
          self.connectConsumerGroup();
        }
      });
    });

    this.on('noOwnersForTopics', function (topics) {
      logger.debug('No owners for topics %s reported.', topics);
      if (++verified &lt;= NUMER_OF_TIMES_TO_VERIFY) {
        logger.debug('%s verify %d of %d HLC has given up ownership by checking again in %d', self.client.clientId, verified,
          NUMER_OF_TIMES_TO_VERIFY, VERIFY_WAIT_TIME_MS);

        setTimeout(function () {
          self.checkForOwners(topics);
        }, VERIFY_WAIT_TIME_MS);
      } else {
        self.connectConsumerGroup();
      }
    });

    this.on('topicOwnerChange', _.debounce(function (topics) {
      verified = 0;
      self.checkForOwnersAndListenForChange(topics);
    }, 250));

    this.zk.connect();
  } else {
    this.connectConsumerGroup();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.consumerGroupMigrator.super_" id="apidoc.element.kafka-node.consumerGroupMigrator.super_">
        function <span class="apidocSignatureSpan">kafka-node.consumerGroupMigrator.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.consumerGroupMigrator.prototype" id="apidoc.module.kafka-node.consumerGroupMigrator.prototype">module kafka-node.consumerGroupMigrator.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.consumerGroupMigrator.prototype.checkForOwners" id="apidoc.element.kafka-node.consumerGroupMigrator.prototype.checkForOwners">
        function <span class="apidocSignatureSpan">kafka-node.consumerGroupMigrator.prototype.</span>checkForOwners
        <span class="apidocSignatureSpan">(topics, listenForChange)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkForOwners = function (topics, listenForChange) {
  const self = this;
  const path = '/consumers/' + this.consumerGroup.options.groupId + '/owners/';
  var ownedPartitions = 0;

  function topicWatcher (event) {
    self.emit('topicOwnerChange', topics);
  }

  async.each(topics,
    function (topic, callback) {
      const args = [path + topic];

      if (listenForChange) {
        logger.debug('%s listening for changes in topic %s', self.client.clientId, topic);
        args.push(topicWatcher);
      }

      args.push(function (error, children, stats) {
        if (error) {
          return callback(error);
        }
        ownedPartitions += children.length;
        callback(null);
      });

      self.zk.getChildren.apply(self.zk, args);
    },
    function (error) {
      if (error) {
        return self.emit('error', error);
      }
      if (ownedPartitions === 0) {
        self.emit('noOwnersForTopics', topics);
      } else {
        logger.debug('%s %d partitions are owned by old HLC... waiting...', self.client.clientId, ownedPartitions);
      }
    }
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.on('noOwnersForTopics', function (topics) {
  logger.debug('No owners for topics %s reported.', topics);
  if (++verified &lt;= NUMER_OF_TIMES_TO_VERIFY) {
    logger.debug('%s verify %d of %d HLC has given up ownership by checking again in %d', self.client.clientId, verified
,
      NUMER_OF_TIMES_TO_VERIFY, VERIFY_WAIT_TIME_MS);

    setTimeout(function () {
      self.<span class="apidocCodeKeywordSpan">checkForOwners</span>(topics);
    }, VERIFY_WAIT_TIME_MS);
  } else {
    self.connectConsumerGroup();
  }
});

this.on('topicOwnerChange', _.debounce(function (topics) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.consumerGroupMigrator.prototype.checkForOwnersAndListenForChange" id="apidoc.element.kafka-node.consumerGroupMigrator.prototype.checkForOwnersAndListenForChange">
        function <span class="apidocSignatureSpan">kafka-node.consumerGroupMigrator.prototype.</span>checkForOwnersAndListenForChange
        <span class="apidocSignatureSpan">(topics)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkForOwnersAndListenForChange = function (topics) {
  this.checkForOwners(topics, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.zk.on('connected', function () {
  self.filterByExistingZkTopics(function (error, topics) {
    if (error) {
      return self.emit('error', error);
    }

    if (topics.length) {
      self.<span class="apidocCodeKeywordSpan">checkForOwnersAndListenForChange</span>(topics);
    } else {
      logger.debug('No HLC topics exist in zookeeper.');
      self.connectConsumerGroup();
    }
  });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.consumerGroupMigrator.prototype.connectConsumerGroup" id="apidoc.element.kafka-node.consumerGroupMigrator.prototype.connectConsumerGroup">
        function <span class="apidocSignatureSpan">kafka-node.consumerGroupMigrator.prototype.</span>connectConsumerGroup
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connectConsumerGroup = function () {
  logger.debug('%s connecting consumer group', this.client.clientId);
  const self = this;
  if (this.client.ready) {
    this.consumerGroup.connect();
  } else {
    this.client.once('ready', function () {
      self.consumerGroup.connect();
    });
  }
  this.zk &amp;&amp; this.zk.close();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return self.emit('error', error);
    }

    if (topics.length) {
      self.checkForOwnersAndListenForChange(topics);
    } else {
      logger.debug('No HLC topics exist in zookeeper.');
      self.<span class="apidocCodeKeywordSpan">connectConsumerGroup</span>();
    }
  });
});

this.on('noOwnersForTopics', function (topics) {
  logger.debug('No owners for topics %s reported.', topics);
  if (++verified &lt;= NUMER_OF_TIMES_TO_VERIFY) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.consumerGroupMigrator.prototype.filterByExistingZkTopics" id="apidoc.element.kafka-node.consumerGroupMigrator.prototype.filterByExistingZkTopics">
        function <span class="apidocSignatureSpan">kafka-node.consumerGroupMigrator.prototype.</span>filterByExistingZkTopics
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filterByExistingZkTopics = function (callback) {
  const self = this;
  const path = '/consumers/' + this.consumerGroup.options.groupId + '/owners/';

  async.filter(this.consumerGroup.topics, function (topic, cb) {
    const topicPath = path + topic;
    logger.debug('%s checking zk path %s', self.client.clientId, topicPath);
    self.zk.exists(topicPath, function (error, stat) {
      if (error) {
        return callback(error);
      }
      cb(stat);
    });
  }, function (result) {
    callback(null, result);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.consumerGroup = consumerGroup;
  this.client = consumerGroup.client;
  var verified = 0;

  if (consumerGroup.options.migrateRolling) {
    this.zk = zookeeper.createClient(consumerGroup.client.connectionString, {retries: 10});
    this.zk.on('connected', function () {
      self.<span class="apidocCodeKeywordSpan">filterByExistingZkTopics</span>(function (error, topics) {
if (error) {
  return self.emit('error', error);
}

if (topics.length) {
  self.checkForOwnersAndListenForChange(topics);
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.consumerGroupMigrator.prototype.getOffset" id="apidoc.element.kafka-node.consumerGroupMigrator.prototype.getOffset">
        function <span class="apidocSignatureSpan">kafka-node.consumerGroupMigrator.prototype.</span>getOffset
        <span class="apidocSignatureSpan">(tp, defaultOffset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOffset = function (tp, defaultOffset) {
  const offset = _.get(this.offsets, [tp.topic, tp.partition], defaultOffset);
  if (offset === -1) {
    return defaultOffset;
  }
  return offset;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.consumerGroupMigrator.prototype.saveHighLevelConsumerOffsets" id="apidoc.element.kafka-node.consumerGroupMigrator.prototype.saveHighLevelConsumerOffsets">
        function <span class="apidocSignatureSpan">kafka-node.consumerGroupMigrator.prototype.</span>saveHighLevelConsumerOffsets
        <span class="apidocSignatureSpan">(topicPartitionList, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">saveHighLevelConsumerOffsets = function (topicPartitionList, callback) {
  const self = this;
  this.client.sendOffsetFetchRequest(this.consumerGroup.options.groupId, topicPartitionList, function (error, results) {
    logger.debug('sendOffsetFetchRequest response:', results, error);
    if (error) {
      return callback(error);
    }
    self.offsets = results;
    callback(null);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.consumerGroupRecovery" id="apidoc.module.kafka-node.consumerGroupRecovery">module kafka-node.consumerGroupRecovery</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.consumerGroupRecovery.consumerGroupRecovery" id="apidoc.element.kafka-node.consumerGroupRecovery.consumerGroupRecovery">
        function <span class="apidocSignatureSpan">kafka-node.</span>consumerGroupRecovery
        <span class="apidocSignatureSpan">(consumerGroup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ConsumerGroupRecovery(consumerGroup) {
  this.consumerGroup = consumerGroup;
  this.options = consumerGroup.options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.consumerGroupRecovery.prototype" id="apidoc.module.kafka-node.consumerGroupRecovery.prototype">module kafka-node.consumerGroupRecovery.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.consumerGroupRecovery.prototype.clearError" id="apidoc.element.kafka-node.consumerGroupRecovery.prototype.clearError">
        function <span class="apidocSignatureSpan">kafka-node.consumerGroupRecovery.prototype.</span>clearError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearError = function () {
  this.lastError = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.consumerGroupRecovery.prototype.getRetryTimeout" id="apidoc.element.kafka-node.consumerGroupRecovery.prototype.getRetryTimeout">
        function <span class="apidocSignatureSpan">kafka-node.consumerGroupRecovery.prototype.</span>getRetryTimeout
        <span class="apidocSignatureSpan">(error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getRetryTimeout = function (error) {
  assert(error);
  if (!this._timeouts) {
    this._timeouts = retry.timeouts({
      retries: this.options.retries,
      factor: this.options.retryFactor,
      minTimeout: this.options.retryMinTimeout
    });
  }

  if (this._retryIndex == null || this.lastError == null ||
      error.errorCode !== this.lastError.errorCode) {
    this._retryIndex = 0;
  }

  var index = this._retryIndex++;
  if (index &gt;= this._timeouts.length) {
    return false;
  }
  return this._timeouts[index];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    recoverableItem.handler &amp;&amp; recoverableItem.handler.call(this.consumerGroup, error);
    return true;
  }
  return false;
}, this);

if (retry) {
  retryTimeout = this.<span class="apidocCodeKeywordSpan">getRetryTimeout</span>(error);
}

if (retry &amp;&amp; retryTimeout) {
  logger.debug('RECOVERY from %s: %s retrying in %s ms', source, this.consumerGroup.client.clientId, retryTimeout, error
);
  this.consumerGroup.scheduleReconnect(retryTimeout);
} else {
  this.consumerGroup.emit('error', error);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.consumerGroupRecovery.prototype.tryToRecoverFrom" id="apidoc.element.kafka-node.consumerGroupRecovery.prototype.tryToRecoverFrom">
        function <span class="apidocSignatureSpan">kafka-node.consumerGroupRecovery.prototype.</span>tryToRecoverFrom
        <span class="apidocSignatureSpan">(error, source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tryToRecoverFrom = function (error, source) {
  this.consumerGroup.ready = false;
  this.consumerGroup.stopHeartbeats();

  var retryTimeout = false;
  var retry = recoverableErrors.some(function (recoverableItem) {
    if (isErrorInstanceOf(error, recoverableItem.errors)) {
      recoverableItem.handler &amp;&amp; recoverableItem.handler.call(this.consumerGroup, error);
      return true;
    }
    return false;
  }, this);

  if (retry) {
    retryTimeout = this.getRetryTimeout(error);
  }

  if (retry &amp;&amp; retryTimeout) {
    logger.debug('RECOVERY from %s: %s retrying in %s ms', source, this.consumerGroup.client.clientId, retryTimeout, error);
    this.consumerGroup.scheduleReconnect(retryTimeout);
  } else {
    this.consumerGroup.emit('error', error);
  }
  this.lastError = error;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.logging" id="apidoc.module.kafka-node.logging">module kafka-node.logging</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.logging.logging" id="apidoc.element.kafka-node.logging.logging">
        function <span class="apidocSignatureSpan">kafka-node.</span>logging
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getLogger(name) {
  return loggerProvider(name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.logging.setLoggerProvider" id="apidoc.element.kafka-node.logging.setLoggerProvider">
        function <span class="apidocSignatureSpan">kafka-node.logging.</span>setLoggerProvider
        <span class="apidocSignatureSpan">(provider)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setLoggerProvider(provider) {
  loggerProvider = provider;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### How do I set a logger provider?

For performance reasons, initialization of the `kafka-node` module creates all necessary loggers. This means that custom logger
providers need to be set *before requiring the `kafka-node` module*. The following example shows how this can be done:

```javascript
// first configure the logger provider
const kafkaLogging = require('kafka-node/logging');
kafkaLogging.<span class="apidocCodeKeywordSpan">setLoggerProvider</span>(consoleLoggerProvider);

// then require kafka-node and continue as normal
const kafka = require('kafka-node');
```

# Running Tests
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.partitioner" id="apidoc.module.kafka-node.partitioner">module kafka-node.partitioner</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.partitioner.CustomPartitioner" id="apidoc.element.kafka-node.partitioner.CustomPartitioner">
        function <span class="apidocSignatureSpan">kafka-node.partitioner.</span>CustomPartitioner
        <span class="apidocSignatureSpan">(partitioner)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CustomPartitioner = function (partitioner) {
  this.getPartition = partitioner;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.partitioner.CyclicPartitioner" id="apidoc.element.kafka-node.partitioner.CyclicPartitioner">
        function <span class="apidocSignatureSpan">kafka-node.partitioner.</span>CyclicPartitioner
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CyclicPartitioner = function () {
  this.c = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.partitioner.DefaultPartitioner" id="apidoc.element.kafka-node.partitioner.DefaultPartitioner">
        function <span class="apidocSignatureSpan">kafka-node.partitioner.</span>DefaultPartitioner
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">DefaultPartitioner = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.partitioner.KeyedPartitioner" id="apidoc.element.kafka-node.partitioner.KeyedPartitioner">
        function <span class="apidocSignatureSpan">kafka-node.partitioner.</span>KeyedPartitioner
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">KeyedPartitioner = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.partitioner.RandomPartitioner" id="apidoc.element.kafka-node.partitioner.RandomPartitioner">
        function <span class="apidocSignatureSpan">kafka-node.partitioner.</span>RandomPartitioner
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RandomPartitioner = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.utils" id="apidoc.module.kafka-node.utils">module kafka-node.utils</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.utils.createTopicPartitionList" id="apidoc.element.kafka-node.utils.createTopicPartitionList">
        function <span class="apidocSignatureSpan">kafka-node.utils.</span>createTopicPartitionList
        <span class="apidocSignatureSpan">(topicPartitions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createTopicPartitionList(topicPartitions) {
  var tpList = [];
  for (var topic in topicPartitions) {
    if (!topicPartitions.hasOwnProperty(topic)) {
      continue;
    }
    topicPartitions[topic].forEach(function (partition) {
      tpList.push({
        topic: topic,
        partition: partition
      });
    });
  }
  return tpList;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.utils.groupPartitionsByTopic" id="apidoc.element.kafka-node.utils.groupPartitionsByTopic">
        function <span class="apidocSignatureSpan">kafka-node.utils.</span>groupPartitionsByTopic
        <span class="apidocSignatureSpan">(topicPartitions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function groupPartitionsByTopic(topicPartitions) {
  assert(Array.isArray(topicPartitions));
  return topicPartitions.reduce(function (result, tp) {
    if (!(tp.topic in result)) {
      result[tp.topic] = [tp.partition];
    } else {
      result[tp.topic].push(tp.partition);
    }
    return result;
  }, {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.utils.validateConfig" id="apidoc.element.kafka-node.utils.validateConfig">
        function <span class="apidocSignatureSpan">kafka-node.utils.</span>validateConfig
        <span class="apidocSignatureSpan">(property, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function validateConfig(property, value) {
  if (!legalChars.test(value)) {
    throw new InvalidConfigError([property, value, "is illegal, contains a character other than ASCII alphanumerics, '.', '_' and
 '-'"].join(' '));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.utils.validateTopicNames" id="apidoc.element.kafka-node.utils.validateTopicNames">
        function <span class="apidocSignatureSpan">kafka-node.utils.</span>validateTopicNames
        <span class="apidocSignatureSpan">(topics)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function validateTopicNames(topics) {
  // Rewriting same validations done by Apache Kafka team for topics
  // iterating over topics
  topics.some(function (topic) {
    if (topic.length &lt;= 0) {
      throw new InvalidConfigError('topic name is illegal, cannot be empty');
    }
    if (topic === '.' || topic === '..') {
      throw new InvalidConfigError('topic name cannot be . or ..');
    }
    if (topic.length &gt; allowedTopicLength) {
      throw new InvalidConfigError(`topic name is illegal, cannot be longer than ${allowedTopicLength} characters`);
    }
    if (!legalChars.test(topic)) {
      throw new InvalidConfigError(`topic name ${topic} is illegal, contains a character other than ASCII alphanumerics .,_ and -`);
    }
  });
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.utils.validateTopics" id="apidoc.element.kafka-node.utils.validateTopics">
        function <span class="apidocSignatureSpan">kafka-node.utils.</span>validateTopics
        <span class="apidocSignatureSpan">(topics)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function validateTopics(topics) {
  if (topics.some(function (topic) {
    if ('partition' in topic) {
      return typeof topic.partition !== 'number';
    }
    return false;
  })) {
    throw new InvalidConfigError('Offset must be a number and can not contain characters');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.zookeeper" id="apidoc.module.kafka-node.zookeeper">module kafka-node.zookeeper</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.zookeeper.Zookeeper" id="apidoc.element.kafka-node.zookeeper.Zookeeper">
        function <span class="apidocSignatureSpan">kafka-node.zookeeper.</span>Zookeeper
        <span class="apidocSignatureSpan">(connectionString, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Zookeeper = function (connectionString, options) {
  this.client = zookeeper.createClient(connectionString, options);

  var that = this;
  this.client.on('connected', function () {
    that.listBrokers();
  });
  this.client.on('disconnected', function () {
    that.emit('disconnected');
  });
  this.client.connect();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.zookeeper.ZookeeperConsumerMappings" id="apidoc.element.kafka-node.zookeeper.ZookeeperConsumerMappings">
        function <span class="apidocSignatureSpan">kafka-node.zookeeper.</span>ZookeeperConsumerMappings
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ZookeeperConsumerMappings = function () {
  this.consumerTopicMap = {};
  this.topicConsumerMap = {};
  this.topicPartitionMap = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>