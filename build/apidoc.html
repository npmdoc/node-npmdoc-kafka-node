<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/SOHU-Co/kafka-node#readme"

    >kafka-node (v1.6.0)</a>
</h1>
<h4>Client for Apache Kafka v0.8+</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node">module kafka-node</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client">
            function <span class="apidocSignatureSpan">kafka-node.</span>Client
            <span class="apidocSignatureSpan">(connectionString, clientId, zkOptions, noAckBatchOptions, sslOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer">
            function <span class="apidocSignatureSpan">kafka-node.</span>Consumer
            <span class="apidocSignatureSpan">(client, topics, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup">
            function <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup
            <span class="apidocSignatureSpan">(memberOptions, topics)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.CustomPartitioner">
            function <span class="apidocSignatureSpan">kafka-node.</span>CustomPartitioner
            <span class="apidocSignatureSpan">(partitioner)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.CyclicPartitioner">
            function <span class="apidocSignatureSpan">kafka-node.</span>CyclicPartitioner
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.DefaultPartitioner">
            function <span class="apidocSignatureSpan">kafka-node.</span>DefaultPartitioner
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer">
            function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer
            <span class="apidocSignatureSpan">(client, topics, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelProducer">
            function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelProducer
            <span class="apidocSignatureSpan">(client, options, customPartitioner)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelProducer.super_">
            function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelProducer.super_
            <span class="apidocSignatureSpan">(client, options, defaultPartitionerType, customPartitioner)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.KeyedMessage">
            function <span class="apidocSignatureSpan">kafka-node.</span>KeyedMessage
            <span class="apidocSignatureSpan">(key, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.KeyedPartitioner">
            function <span class="apidocSignatureSpan">kafka-node.</span>KeyedPartitioner
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Offset">
            function <span class="apidocSignatureSpan">kafka-node.</span>Offset
            <span class="apidocSignatureSpan">(client)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Producer">
            function <span class="apidocSignatureSpan">kafka-node.</span>Producer
            <span class="apidocSignatureSpan">(client, options, customPartitioner)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.RandomPartitioner">
            function <span class="apidocSignatureSpan">kafka-node.</span>RandomPartitioner
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.consumerGroupMigrator">
            function <span class="apidocSignatureSpan">kafka-node.</span>consumerGroupMigrator
            <span class="apidocSignatureSpan">(consumerGroup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.consumerGroupRecovery">
            function <span class="apidocSignatureSpan">kafka-node.</span>consumerGroupRecovery
            <span class="apidocSignatureSpan">(consumerGroup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.logging">
            function <span class="apidocSignatureSpan">kafka-node.</span>logging
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>Consumer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>CyclicPartitioner.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>DefaultPartitioner.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>HighLevelProducer.super_.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>KeyedPartitioner.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>Offset.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>RandomPartitioner.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>consumerGroupMigrator.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>consumerGroupRecovery.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>partitioner</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>utils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>zookeeper</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Client">module kafka-node.Client</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.Client">
            function <span class="apidocSignatureSpan">kafka-node.</span>Client
            <span class="apidocSignatureSpan">(connectionString, clientId, zkOptions, noAckBatchOptions, sslOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.super_">
            function <span class="apidocSignatureSpan">kafka-node.Client.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Client.prototype">module kafka-node.Client.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.addTopics">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>addTopics
            <span class="apidocSignatureSpan">(topics, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.brokerForLeader">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>brokerForLeader
            <span class="apidocSignatureSpan">(leader, longpolling)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.checkMetadatas">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>checkMetadatas
            <span class="apidocSignatureSpan">(payloads)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.clearCallbackQueue">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>clearCallbackQueue
            <span class="apidocSignatureSpan">(socket, error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.close">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>close
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.closeBrokers">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>closeBrokers
            <span class="apidocSignatureSpan">(brokers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.connect">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>connect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.createBroker">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>createBroker
            <span class="apidocSignatureSpan">(host, port, longpolling)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.createTopics">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>createTopics
            <span class="apidocSignatureSpan">(topics, isAsync, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.getBrokers">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>getBrokers
            <span class="apidocSignatureSpan">(longpolling)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.handleReceivedData">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>handleReceivedData
            <span class="apidocSignatureSpan">(socket)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.hasMetadata">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>hasMetadata
            <span class="apidocSignatureSpan">(topic, partition)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.leaderByPartition">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>leaderByPartition
            <span class="apidocSignatureSpan">(topic, partition)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.loadMetadataForTopics">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>loadMetadataForTopics
            <span class="apidocSignatureSpan">(topics, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.nextId">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>nextId
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.nextSocketId">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>nextSocketId
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.payloadsByLeader">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>payloadsByLeader
            <span class="apidocSignatureSpan">(payloads)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.queueCallback">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>queueCallback
            <span class="apidocSignatureSpan">(socket, id, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.reconnectBroker">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>reconnectBroker
            <span class="apidocSignatureSpan">(oldSocket)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.refreshBrokers">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>refreshBrokers
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.refreshMetadata">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>refreshMetadata
            <span class="apidocSignatureSpan">(topicNames, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.removeTopicMetadata">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>removeTopicMetadata
            <span class="apidocSignatureSpan">(topics, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.send">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>send
            <span class="apidocSignatureSpan">(payloads, encoder, decoder, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendFetchRequest">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendFetchRequest
            <span class="apidocSignatureSpan">(consumer, payloads, fetchMaxWaitMs, fetchMinBytes, maxTickMessages)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendGroupCoordinatorRequest">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendGroupCoordinatorRequest
            <span class="apidocSignatureSpan">(groupId, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendGroupRequest">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendGroupRequest
            <span class="apidocSignatureSpan">(encode, decode, requestArgs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendHeartbeatRequest">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendHeartbeatRequest
            <span class="apidocSignatureSpan">(groupId, generationId, memberId, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendJoinGroupRequest">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendJoinGroupRequest
            <span class="apidocSignatureSpan">(groupId, memberId, sessionTimeout, groupProtocol, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendLeaveGroupRequest">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendLeaveGroupRequest
            <span class="apidocSignatureSpan">(groupId, memberId, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendOffsetCommitRequest">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendOffsetCommitRequest
            <span class="apidocSignatureSpan">(group, payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendOffsetCommitV2Request">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendOffsetCommitV2Request
            <span class="apidocSignatureSpan">(group, generationId, memberId, payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendOffsetFetchRequest">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendOffsetFetchRequest
            <span class="apidocSignatureSpan">(group, payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendOffsetFetchV1Request">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendOffsetFetchV1Request
            <span class="apidocSignatureSpan">(group, payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendOffsetRequest">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendOffsetRequest
            <span class="apidocSignatureSpan">(payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendProduceRequest">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendProduceRequest
            <span class="apidocSignatureSpan">(payloads, requireAcks, ackTimeoutMs, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendSyncGroupRequest">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendSyncGroupRequest
            <span class="apidocSignatureSpan">(groupId, generationId, memberId, groupAssignment, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendToBroker">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendToBroker
            <span class="apidocSignatureSpan">(payloads, encoder, decoder, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.setupBroker">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>setupBroker
            <span class="apidocSignatureSpan">(host, port, longpolling, brokers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.setupBrokerProfiles">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>setupBrokerProfiles
            <span class="apidocSignatureSpan">(brokers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.topicExists">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>topicExists
            <span class="apidocSignatureSpan">(topics, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.unqueueCallback">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>unqueueCallback
            <span class="apidocSignatureSpan">(socket, id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.updateMetadatas">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>updateMetadatas
            <span class="apidocSignatureSpan">(metadatas)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Consumer">module kafka-node.Consumer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.Consumer">
            function <span class="apidocSignatureSpan">kafka-node.</span>Consumer
            <span class="apidocSignatureSpan">(client, topics, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.super_">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Consumer.prototype">module kafka-node.Consumer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.addTopics">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>addTopics
            <span class="apidocSignatureSpan">(topics, cb, fromOffset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.autoCommit">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>autoCommit
            <span class="apidocSignatureSpan">(force, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.buildPayloads">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>buildPayloads
            <span class="apidocSignatureSpan">(payloads)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.close">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>close
            <span class="apidocSignatureSpan">(force, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.commit">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>commit
            <span class="apidocSignatureSpan">(force, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.connect">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>connect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.fetch">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>fetch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.fetchOffset">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>fetchOffset
            <span class="apidocSignatureSpan">(payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.init">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>init
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.pause">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>pause
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.pauseTopics">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>pauseTopics
            <span class="apidocSignatureSpan">(topics)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.removeTopics">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>removeTopics
            <span class="apidocSignatureSpan">(topics, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.resume">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>resume
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.resumeTopics">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>resumeTopics
            <span class="apidocSignatureSpan">(topics)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.setOffset">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>setOffset
            <span class="apidocSignatureSpan">(topic, partition, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.updateOffsets">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>updateOffsets
            <span class="apidocSignatureSpan">(topics, initing)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.ConsumerGroup">module kafka-node.ConsumerGroup</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.ConsumerGroup">
            function <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup
            <span class="apidocSignatureSpan">(memberOptions, topics)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.super_">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.</span>super_
            <span class="apidocSignatureSpan">(client, topics, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.ConsumerGroup.prototype">module kafka-node.ConsumerGroup.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.assignPartitions">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>assignPartitions
            <span class="apidocSignatureSpan">(protocol, groupMembers, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.close">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>close
            <span class="apidocSignatureSpan">(force, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.connect">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>connect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.fetchOffset">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>fetchOffset
            <span class="apidocSignatureSpan">(payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.getDefaultOffset">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>getDefaultOffset
            <span class="apidocSignatureSpan">(tp, defaultOffset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.getOffset">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>getOffset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.handleJoinGroup">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>handleJoinGroup
            <span class="apidocSignatureSpan">(joinGroupResponse, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.handleSyncGroup">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>handleSyncGroup
            <span class="apidocSignatureSpan">(syncGroupResponse, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.leaveGroup">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>leaveGroup
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.saveDefaultOffsets">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>saveDefaultOffsets
            <span class="apidocSignatureSpan">(topicPartitionList, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.scheduleReconnect">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>scheduleReconnect
            <span class="apidocSignatureSpan">(timeout)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.sendHeartbeat">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>sendHeartbeat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.sendOffsetCommitRequest">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>sendOffsetCommitRequest
            <span class="apidocSignatureSpan">(commits, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.setCoordinatorId">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>setCoordinatorId
            <span class="apidocSignatureSpan">(coordinatorId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.setupProtocols">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>setupProtocols
            <span class="apidocSignatureSpan">(protocols)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.startHeartbeats">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>startHeartbeats
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.stopHeartbeats">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>stopHeartbeats
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.CustomPartitioner">module kafka-node.CustomPartitioner</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.CustomPartitioner.CustomPartitioner">
            function <span class="apidocSignatureSpan">kafka-node.</span>CustomPartitioner
            <span class="apidocSignatureSpan">(partitioner)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.CustomPartitioner.super_">
            function <span class="apidocSignatureSpan">kafka-node.CustomPartitioner.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.CyclicPartitioner">module kafka-node.CyclicPartitioner</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.CyclicPartitioner.CyclicPartitioner">
            function <span class="apidocSignatureSpan">kafka-node.</span>CyclicPartitioner
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.CyclicPartitioner.super_">
            function <span class="apidocSignatureSpan">kafka-node.CyclicPartitioner.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.CyclicPartitioner.prototype">module kafka-node.CyclicPartitioner.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.CyclicPartitioner.prototype.getPartition">
            function <span class="apidocSignatureSpan">kafka-node.CyclicPartitioner.prototype.</span>getPartition
            <span class="apidocSignatureSpan">(partitions)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.DefaultPartitioner">module kafka-node.DefaultPartitioner</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.DefaultPartitioner.DefaultPartitioner">
            function <span class="apidocSignatureSpan">kafka-node.</span>DefaultPartitioner
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.DefaultPartitioner.super_">
            function <span class="apidocSignatureSpan">kafka-node.DefaultPartitioner.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.DefaultPartitioner.prototype">module kafka-node.DefaultPartitioner.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.DefaultPartitioner.prototype.getPartition">
            function <span class="apidocSignatureSpan">kafka-node.DefaultPartitioner.prototype.</span>getPartition
            <span class="apidocSignatureSpan">(partitions)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.HighLevelConsumer">module kafka-node.HighLevelConsumer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.HighLevelConsumer">
            function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer
            <span class="apidocSignatureSpan">(client, topics, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.super_">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype">module kafka-node.HighLevelConsumer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype._releasePartitions">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>_releasePartitions
            <span class="apidocSignatureSpan">(topicPayloads, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.addTopics">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>addTopics
            <span class="apidocSignatureSpan">(topics, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.autoCommit">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>autoCommit
            <span class="apidocSignatureSpan">(force, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.buildPayloads">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>buildPayloads
            <span class="apidocSignatureSpan">(payloads)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.buildTopicPayloads">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>buildTopicPayloads
            <span class="apidocSignatureSpan">(topics)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.close">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>close
            <span class="apidocSignatureSpan">(force, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.commit">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>commit
            <span class="apidocSignatureSpan">(force, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.connect">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>connect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.fetch">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>fetch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.fetchOffset">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>fetchOffset
            <span class="apidocSignatureSpan">(payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.getTopicPayloads">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>getTopicPayloads
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.init">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>init
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.leaveGroup">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>leaveGroup
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.offsetRequest">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>offsetRequest
            <span class="apidocSignatureSpan">(payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.pause">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>pause
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.rebalanceAttempt">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>rebalanceAttempt
            <span class="apidocSignatureSpan">(oldTopicPayloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.registerConsumer">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>registerConsumer
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.removeTopics">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>removeTopics
            <span class="apidocSignatureSpan">(topics, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.resume">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>resume
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.sendOffsetCommitRequest">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>sendOffsetCommitRequest
            <span class="apidocSignatureSpan">(commits, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.setOffset">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>setOffset
            <span class="apidocSignatureSpan">(topic, partition, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.stop">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>stop
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.updateOffsets">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>updateOffsets
            <span class="apidocSignatureSpan">(topics, initing)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.HighLevelProducer">module kafka-node.HighLevelProducer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelProducer.HighLevelProducer">
            function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelProducer
            <span class="apidocSignatureSpan">(client, options, customPartitioner)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelProducer.super_">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.</span>super_
            <span class="apidocSignatureSpan">(client, options, defaultPartitionerType, customPartitioner)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.</span>PARTITIONER_TYPES</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.HighLevelProducer.super_">module kafka-node.HighLevelProducer.super_</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelProducer.super_.super_">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.super_.</span>PARTITIONER_TYPES</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.HighLevelProducer.super_.prototype">module kafka-node.HighLevelProducer.super_.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.buildPayloads">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.super_.prototype.</span>buildPayloads
            <span class="apidocSignatureSpan">(payloads, topicMetadata)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.close">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.super_.prototype.</span>close
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.connect">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.super_.prototype.</span>connect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.createTopics">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.super_.prototype.</span>createTopics
            <span class="apidocSignatureSpan">(topics, async, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.send">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.super_.prototype.</span>send
            <span class="apidocSignatureSpan">(payloads, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.KeyedPartitioner">module kafka-node.KeyedPartitioner</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.KeyedPartitioner.KeyedPartitioner">
            function <span class="apidocSignatureSpan">kafka-node.</span>KeyedPartitioner
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.KeyedPartitioner.super_">
            function <span class="apidocSignatureSpan">kafka-node.KeyedPartitioner.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.KeyedPartitioner.prototype">module kafka-node.KeyedPartitioner.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.KeyedPartitioner.prototype.getPartition">
            function <span class="apidocSignatureSpan">kafka-node.KeyedPartitioner.prototype.</span>getPartition
            <span class="apidocSignatureSpan">(partitions, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.KeyedPartitioner.prototype.hashCode">
            function <span class="apidocSignatureSpan">kafka-node.KeyedPartitioner.prototype.</span>hashCode
            <span class="apidocSignatureSpan">(string)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Offset">module kafka-node.Offset</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Offset.Offset">
            function <span class="apidocSignatureSpan">kafka-node.</span>Offset
            <span class="apidocSignatureSpan">(client)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Offset.super_">
            function <span class="apidocSignatureSpan">kafka-node.Offset.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Offset.prototype">module kafka-node.Offset.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Offset.prototype.buildPayloads">
            function <span class="apidocSignatureSpan">kafka-node.Offset.prototype.</span>buildPayloads
            <span class="apidocSignatureSpan">(payloads)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Offset.prototype.commit">
            function <span class="apidocSignatureSpan">kafka-node.Offset.prototype.</span>commit
            <span class="apidocSignatureSpan">(groupId, payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Offset.prototype.fetch">
            function <span class="apidocSignatureSpan">kafka-node.Offset.prototype.</span>fetch
            <span class="apidocSignatureSpan">(payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Offset.prototype.fetchCommits">
            function <span class="apidocSignatureSpan">kafka-node.Offset.prototype.</span>fetchCommits
            <span class="apidocSignatureSpan">(groupId, payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Offset.prototype.fetchEarliestOffsets">
            function <span class="apidocSignatureSpan">kafka-node.Offset.prototype.</span>fetchEarliestOffsets
            <span class="apidocSignatureSpan">(topics, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Offset.prototype.fetchLatestOffsets">
            function <span class="apidocSignatureSpan">kafka-node.Offset.prototype.</span>fetchLatestOffsets
            <span class="apidocSignatureSpan">(topics, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Producer">module kafka-node.Producer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Producer.Producer">
            function <span class="apidocSignatureSpan">kafka-node.</span>Producer
            <span class="apidocSignatureSpan">(client, options, customPartitioner)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Producer.super_">
            function <span class="apidocSignatureSpan">kafka-node.Producer.</span>super_
            <span class="apidocSignatureSpan">(client, options, defaultPartitionerType, customPartitioner)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.Producer.</span>PARTITIONER_TYPES</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.RandomPartitioner">module kafka-node.RandomPartitioner</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.RandomPartitioner.RandomPartitioner">
            function <span class="apidocSignatureSpan">kafka-node.</span>RandomPartitioner
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.RandomPartitioner.super_">
            function <span class="apidocSignatureSpan">kafka-node.RandomPartitioner.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.RandomPartitioner.prototype">module kafka-node.RandomPartitioner.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.RandomPartitioner.prototype.getPartition">
            function <span class="apidocSignatureSpan">kafka-node.RandomPartitioner.prototype.</span>getPartition
            <span class="apidocSignatureSpan">(partitions)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.consumerGroupMigrator">module kafka-node.consumerGroupMigrator</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.consumerGroupMigrator.consumerGroupMigrator">
            function <span class="apidocSignatureSpan">kafka-node.</span>consumerGroupMigrator
            <span class="apidocSignatureSpan">(consumerGroup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.consumerGroupMigrator.super_">
            function <span class="apidocSignatureSpan">kafka-node.consumerGroupMigrator.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.consumerGroupMigrator.prototype">module kafka-node.consumerGroupMigrator.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.consumerGroupMigrator.prototype.checkForOwners">
            function <span class="apidocSignatureSpan">kafka-node.consumerGroupMigrator.prototype.</span>checkForOwners
            <span class="apidocSignatureSpan">(topics, listenForChange)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.consumerGroupMigrator.prototype.checkForOwnersAndListenForChange">
            function <span class="apidocSignatureSpan">kafka-node.consumerGroupMigrator.prototype.</span>checkForOwnersAndListenForChange
            <span class="apidocSignatureSpan">(topics)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.consumerGroupMigrator.prototype.connectConsumerGroup">
            function <span class="apidocSignatureSpan">kafka-node.consumerGroupMigrator.prototype.</span>connectConsumerGroup
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.consumerGroupMigrator.prototype.filterByExistingZkTopics">
            function <span class="apidocSignatureSpan">kafka-node.consumerGroupMigrator.prototype.</span>filterByExistingZkTopics
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.consumerGroupMigrator.prototype.getOffset">
            function <span class="apidocSignatureSpan">kafka-node.consumerGroupMigrator.prototype.</span>getOffset
            <span class="apidocSignatureSpan">(tp, defaultOffset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.consumerGroupMigrator.prototype.saveHighLevelConsumerOffsets">
            function <span class="apidocSignatureSpan">kafka-node.consumerGroupMigrator.prototype.</span>saveHighLevelConsumerOffsets
            <span class="apidocSignatureSpan">(topicPartitionList, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.consumerGroupRecovery">module kafka-node.consumerGroupRecovery</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.consumerGroupRecovery.consumerGroupRecovery">
            function <span class="apidocSignatureSpan">kafka-node.</span>consumerGroupRecovery
            <span class="apidocSignatureSpan">(consumerGroup)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.consumerGroupRecovery.prototype">module kafka-node.consumerGroupRecovery.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.consumerGroupRecovery.prototype.clearError">
            function <span class="apidocSignatureSpan">kafka-node.consumerGroupRecovery.prototype.</span>clearError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.consumerGroupRecovery.prototype.getRetryTimeout">
            function <span class="apidocSignatureSpan">kafka-node.consumerGroupRecovery.prototype.</span>getRetryTimeout
            <span class="apidocSignatureSpan">(error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.consumerGroupRecovery.prototype.tryToRecoverFrom">
            function <span class="apidocSignatureSpan">kafka-node.consumerGroupRecovery.prototype.</span>tryToRecoverFrom
            <span class="apidocSignatureSpan">(error, source)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.logging">module kafka-node.logging</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.logging.logging">
            function <span class="apidocSignatureSpan">kafka-node.</span>logging
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.logging.setLoggerProvider">
            function <span class="apidocSignatureSpan">kafka-node.logging.</span>setLoggerProvider
            <span class="apidocSignatureSpan">(provider)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.partitioner">module kafka-node.partitioner</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.partitioner.CustomPartitioner">
            function <span class="apidocSignatureSpan">kafka-node.partitioner.</span>CustomPartitioner
            <span class="apidocSignatureSpan">(partitioner)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.partitioner.CyclicPartitioner">
            function <span class="apidocSignatureSpan">kafka-node.partitioner.</span>CyclicPartitioner
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.partitioner.DefaultPartitioner">
            function <span class="apidocSignatureSpan">kafka-node.partitioner.</span>DefaultPartitioner
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.partitioner.KeyedPartitioner">
            function <span class="apidocSignatureSpan">kafka-node.partitioner.</span>KeyedPartitioner
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.partitioner.RandomPartitioner">
            function <span class="apidocSignatureSpan">kafka-node.partitioner.</span>RandomPartitioner
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.utils">module kafka-node.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.utils.createTopicPartitionList">
            function <span class="apidocSignatureSpan">kafka-node.utils.</span>createTopicPartitionList
            <span class="apidocSignatureSpan">(topicPartitions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.utils.groupPartitionsByTopic">
            function <span class="apidocSignatureSpan">kafka-node.utils.</span>groupPartitionsByTopic
            <span class="apidocSignatureSpan">(topicPartitions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.utils.validateConfig">
            function <span class="apidocSignatureSpan">kafka-node.utils.</span>validateConfig
            <span class="apidocSignatureSpan">(property, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.utils.validateTopicNames">
            function <span class="apidocSignatureSpan">kafka-node.utils.</span>validateTopicNames
            <span class="apidocSignatureSpan">(topics)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.utils.validateTopics">
            function <span class="apidocSignatureSpan">kafka-node.utils.</span>validateTopics
            <span class="apidocSignatureSpan">(topics)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.zookeeper">module kafka-node.zookeeper</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.zookeeper.Zookeeper">
            function <span class="apidocSignatureSpan">kafka-node.zookeeper.</span>Zookeeper
            <span class="apidocSignatureSpan">(connectionString, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.zookeeper.ZookeeperConsumerMappings">
            function <span class="apidocSignatureSpan">kafka-node.zookeeper.</span>ZookeeperConsumerMappings
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node" id="apidoc.module.kafka-node">module kafka-node</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client" id="apidoc.element.kafka-node.Client">
        function <span class="apidocSignatureSpan">kafka-node.</span>Client
        <span class="apidocSignatureSpan">(connectionString, clientId, zkOptions, noAckBatchOptions, sslOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client = function (connectionString, clientId, zkOptions, noAckBatchOptions, sslOptions) {
  if (this instanceof Client === false) {
    return new Client(connectionString, clientId, zkOptions, noAckBatchOptions, sslOptions);
  }

  this.sslOptions = sslOptions;
  this.ssl = !!sslOptions;

  if (clientId) {
    validateConfig(&#x27;clientId&#x27;, clientId);
  }

  this.connectionString = connectionString || &#x27;localhost:2181/&#x27;;
  this.clientId = clientId || &#x27;kafka-node-client&#x27;;
  this.zkOptions = zkOptions;
  this.noAckBatchOptions = noAckBatchOptions;
  this.brokers = {};
  this.longpollingBrokers = {};
  this.topicMetadata = {};
  this.topicPartitions = {};
  this.correlationId = 0;
  this._socketId = 0;
  this.cbqueue = {};
  this.brokerMetadata = {};
  this.ready = false;
  this.connect();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    partitionerType: 2
}
```

``` js
var kafka = require(&#x27;kafka-node&#x27;),
    Producer = kafka.Producer,
    client = new kafka.<span class="apidocCodeKeywordSpan">Client</span>(),
    producer = new Producer(client);
```

### Events

- `ready`: this event is emitted when producer is ready to send messages.
- `error`: this is the error event propagates from internal client, producer should always listen it.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer" id="apidoc.element.kafka-node.Consumer">
        function <span class="apidocSignatureSpan">kafka-node.</span>Consumer
        <span class="apidocSignatureSpan">(client, topics, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Consumer = function (client, topics, options) {
  if (!topics) {
    throw new Error(&#x27;Must have payloads&#x27;);
  }

  utils.validateTopics(topics);

  this.fetchCount = 0;
  this.client = client;
  this.options = _.defaults((options || {}), DEFAULTS);
  this.ready = false;
  this.paused = this.options.paused;
  this.id = nextId();
  this.payloads = this.buildPayloads(topics);
  this.connect();
  this.encoding = this.options.encoding;

  if (this.options.groupId) {
    utils.validateConfig(&#x27;options.groupId&#x27;, this.options.groupId);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup" id="apidoc.element.kafka-node.ConsumerGroup">
        function <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup
        <span class="apidocSignatureSpan">(memberOptions, topics)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ConsumerGroup(memberOptions, topics) {
  EventEmitter.call(this);
  const self = this;
  this.options = _.defaults((memberOptions || {}), DEFAULTS);

  if (!this.options.heartbeatInterval) {
    this.options.heartbeatInterval = Math.floor(this.options.sessionTimeout / 3);
  }

  if (memberOptions.ssl === true) {
    memberOptions.ssl = {};
  }

  if (!(this.options.fromOffset in ACCEPTED_FROM_OFFSET)) {
    throw new Error(`fromOffset ${this.options.fromOffset} should be either: ${Object.keys(ACCEPTED_FROM_OFFSET).join(&#x27;, &#x27;)}`);
  }

  if (!(this.options.outOfRangeOffset in ACCEPTED_FROM_OFFSET)) {
    throw new Error(`outOfRangeOffset ${this.options.outOfRangeOffset} should be either: ${Object.keys(ACCEPTED_FROM_OFFSET).join
(&#x27;, &#x27;)}`);
  }

  this.client = new Client(memberOptions.host, memberOptions.id, memberOptions.zk,
    memberOptions.batch, memberOptions.ssl);

  if (_.isString(topics)) {
    topics = [topics];
  }

  assert(Array.isArray(topics), &#x27;Array of topics is required&#x27;);

  this.topics = topics;

  this.recovery = new ConsumerGroupRecovery(this);

  this.setupProtocols(this.options.protocol);

  if (this.options.connectOnReady &#x26;&#x26; !this.options.migrateHLC) {
    this.client.once(&#x27;ready&#x27;, this.connect.bind(this));
  }

  if (this.options.migrateHLC) {
    const ConsumerGroupMigrator = require(&#x27;./consumerGroupMigrator&#x27;);
    this.migrator = new ConsumerGroupMigrator(this);
    this.migrator.on(&#x27;error&#x27;, function (error) {
      self.emit(&#x27;error&#x27;, error);
    });
  }

  this.client.on(&#x27;error&#x27;, function (err) {
    logger.error(&#x27;Error from %s&#x27;, self.client.clientId, err);
    self.emit(&#x27;error&#x27;, err);
  });

  const recoverFromBrokerChange = _.debounce(function () {
    logger.debug(&#x27;brokersChanged refreshing metadata&#x27;);
    self.client.refreshMetadata(self.topics, function (error) {
      if (error) {
        self.emit(error);
        return;
      }
      self.paused = false;
      if (!self.ready &#x26;&#x26; !self.connecting) {
        if (self.reconnectTimer) {
          // brokers changed so bypass backoff retry and reconnect now
          clearTimeout(self.reconnectTimer);
          self.reconnectTimer = null;
        }
        self.connect();
      } else if (!self.connecting) {
        self.fetch();
      }
    });
  }, 200);

  this.client.on(&#x27;brokersChanged&#x27;, function () {
    self.pause();
    recoverFromBrokerChange();
  });

  this.client.on(&#x27;reconnect&#x27;, function (lastError) {
    self.fetch();
  });

  this.on(&#x27;offsetOutOfRange&#x27;, topic =&#x3e; {
    this.pause();
    if (this.options.outOfRangeOffset === &#x27;none&#x27;) {
      this.emit(&#x27;error&#x27;, new errors.InvalidConsumerOffsetError(`Offset out of range for topic &#x22;${topic.topic}&#x22; partition ${topic
.partition}`));
      return;
    }

    topic.time = ACCEPTED_FROM_OFFSET[this.options.outOfRangeOffset];

    this.getOffset().fetch([topic], (error, result) =&#x3e; {
      if (error) {
        this.emit(&#x27;error&#x27;, new errors.InvalidConsumerOffsetError(`Fetching ${this.options.outOfRangeOffset} offset failed`, error
));
        return;
      }
      const offset = _.head(result[topic.topic][topic.partition]);
      const oldOffset = _.find(this.topicPayloads, {topic: topic.topic, partition: topic.partition}).offset;

      logger.debug(&#x27;replacing %s-%s stale offset of %d with %d&#x27;, topic.topic, topic.partition, oldOffset, offset);

      this.setOffset(topic.topic, topic.partition, offset);
      this.resume();
    });
  });

  // &#x27;done&#x27; will be emit when a message fetch request complete
  this.on(&#x27;done&#x27;, function (topics) {
    self.updateOffsets(topics);
    if (!self.paused) {
      setImmediate(function () {
        self.fetch();
      });
    }
  });

  if (this.options.groupId) {
    validateConfig(&#x27;options.groupId&#x27;, this.options.groupId);
  }

  this.isLeader = false;
  this.coordinatorId = null;
  this.generationId = null;
  this.ready = false;
  this.topicPayloads = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.CustomPartitioner" id="apidoc.element.kafka-node.CustomPartitioner">
        function <span class="apidocSignatureSpan">kafka-node.</span>CustomPartitioner
        <span class="apidocSignatureSpan">(partitioner)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CustomPartitioner = function (partitioner) {
  this.getPartition = partitioner;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.CyclicPartitioner" id="apidoc.element.kafka-node.CyclicPartitioner">
        function <span class="apidocSignatureSpan">kafka-node.</span>CyclicPartitioner
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CyclicPartitioner = function () {
  this.c = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.DefaultPartitioner" id="apidoc.element.kafka-node.DefaultPartitioner">
        function <span class="apidocSignatureSpan">kafka-node.</span>DefaultPartitioner
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">DefaultPartitioner = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer" id="apidoc.element.kafka-node.HighLevelConsumer">
        function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer
        <span class="apidocSignatureSpan">(client, topics, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">HighLevelConsumer = function (client, topics, options) {
  if (!topics) {
    throw new Error(&#x27;Must have payloads&#x27;);
  }
  this.fetchCount = 0;
  this.client = client;
  this.options = _.defaults((options || {}), DEFAULTS);
  this.initialised = false;
  this.ready = false;
  this.closing = false;
  this.paused = this.options.paused;
  this.rebalancing = false;
  this.pendingRebalances = 0;
  this.committing = false;
  this.needToCommit = false;
  this.id = this.options.id || this.options.groupId + &#x27;_&#x27; + uuid.v4();
  this.payloads = this.buildPayloads(topics);
  this.topicPayloads = this.buildTopicPayloads(topics);
  this.connect();

  if (this.options.groupId) {
    validateConfig(&#x27;options.groupId&#x27;, this.options.groupId);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelProducer" id="apidoc.element.kafka-node.HighLevelProducer">
        function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelProducer
        <span class="apidocSignatureSpan">(client, options, customPartitioner)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HighLevelProducer(client, options, customPartitioner) {
  BaseProducer.call(this, client, options, BaseProducer.PARTITIONER_TYPES.cyclic, customPartitioner);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelProducer.super_" id="apidoc.element.kafka-node.HighLevelProducer.super_">
        function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelProducer.super_
        <span class="apidocSignatureSpan">(client, options, defaultPartitionerType, customPartitioner)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BaseProducer(client, options, defaultPartitionerType, customPartitioner) {
  options = options || {};

  this.ready = false;
  this.client = client;

  this.requireAcks = options.requireAcks === undefined
    ? DEFAULTS.requireAcks
    : options.requireAcks;
  this.ackTimeoutMs = options.ackTimeoutMs === undefined
    ? DEFAULTS.ackTimeoutMs
    : options.ackTimeoutMs;

  if (customPartitioner !== undefined &#x26;&#x26; options.partitionerType !== PARTITIONER_TYPES.custom) {
    throw new Error(&#x27;Partitioner Type must be custom if providing a customPartitioner.&#x27;);
  } else if (customPartitioner === undefined &#x26;&#x26; options.partitionerType === PARTITIONER_TYPES.custom) {
    throw new Error(&#x27;No customer partitioner defined&#x27;);
  }

  var partitionerType = PARTITIONER_MAP[options.partitionerType] || PARTITIONER_MAP[defaultPartitionerType];

  // eslint-disable-next-line
  this.partitioner = new partitionerType(customPartitioner);

  this.connect();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.KeyedMessage" id="apidoc.element.kafka-node.KeyedMessage">
        function <span class="apidocSignatureSpan">kafka-node.</span>KeyedMessage
        <span class="apidocSignatureSpan">(key, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function KeyedMessage(key, value) {
  exports.Message.call(this, 0, 0, key, value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.KeyedPartitioner" id="apidoc.element.kafka-node.KeyedPartitioner">
        function <span class="apidocSignatureSpan">kafka-node.</span>KeyedPartitioner
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">KeyedPartitioner = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Offset" id="apidoc.element.kafka-node.Offset">
        function <span class="apidocSignatureSpan">kafka-node.</span>Offset
        <span class="apidocSignatureSpan">(client)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Offset = function (client) {
  var self = this;
  this.client = client;
  this.ready = this.client.ready;
  this.client.on(&#x27;ready&#x27;, function () {
    self.ready = true;
    self.emit(&#x27;ready&#x27;);
  });
  this.client.once(&#x27;connect&#x27;, function () {
    self.emit(&#x27;connect&#x27;);
  });
  this.client.on(&#x27;error&#x27;, function (err) {
    self.emit(&#x27;error&#x27;, err);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `cb`: *Function*, the callback

Example

```js
var kafka = require(&#x27;kafka-node&#x27;),
    client = new kafka.Client(),
    offset = new kafka.<span class="apidocCodeKeywordSpan">Offset</span>(client);
    offset.fetch([
        { topic: &#x27;t&#x27;, partition: 0, time: Date.now(), maxNum: 1 }
    ], function (err, data) {
        // data
        // { &#x27;t&#x27;: { &#x27;0&#x27;: [999] } }
    });
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Producer" id="apidoc.element.kafka-node.Producer">
        function <span class="apidocSignatureSpan">kafka-node.</span>Producer
        <span class="apidocSignatureSpan">(client, options, customPartitioner)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Producer(client, options, customPartitioner) {
  BaseProducer.call(this, client, options, BaseProducer.PARTITIONER_TYPES.default, customPartitioner);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.RandomPartitioner" id="apidoc.element.kafka-node.RandomPartitioner">
        function <span class="apidocSignatureSpan">kafka-node.</span>RandomPartitioner
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RandomPartitioner = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.consumerGroupMigrator" id="apidoc.element.kafka-node.consumerGroupMigrator">
        function <span class="apidocSignatureSpan">kafka-node.</span>consumerGroupMigrator
        <span class="apidocSignatureSpan">(consumerGroup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ConsumerGroupMigrator(consumerGroup) {
  EventEmitter.call(this);
  assert(consumerGroup);
  const self = this;
  this.consumerGroup = consumerGroup;
  this.client = consumerGroup.client;
  var verified = 0;

  if (consumerGroup.options.migrateRolling) {
    this.zk = zookeeper.createClient(consumerGroup.client.connectionString, {retries: 10});
    this.zk.on(&#x27;connected&#x27;, function () {
      self.filterByExistingZkTopics(function (error, topics) {
        if (error) {
          return self.emit(&#x27;error&#x27;, error);
        }

        if (topics.length) {
          self.checkForOwnersAndListenForChange(topics);
        } else {
          logger.debug(&#x27;No HLC topics exist in zookeeper.&#x27;);
          self.connectConsumerGroup();
        }
      });
    });

    this.on(&#x27;noOwnersForTopics&#x27;, function (topics) {
      logger.debug(&#x27;No owners for topics %s reported.&#x27;, topics);
      if (++verified &#x3c;= NUMER_OF_TIMES_TO_VERIFY) {
        logger.debug(&#x27;%s verify %d of %d HLC has given up ownership by checking again in %d&#x27;, self.client.clientId, verified,
          NUMER_OF_TIMES_TO_VERIFY, VERIFY_WAIT_TIME_MS);

        setTimeout(function () {
          self.checkForOwners(topics);
        }, VERIFY_WAIT_TIME_MS);
      } else {
        self.connectConsumerGroup();
      }
    });

    this.on(&#x27;topicOwnerChange&#x27;, _.debounce(function (topics) {
      verified = 0;
      self.checkForOwnersAndListenForChange(topics);
    }, 250));

    this.zk.connect();
  } else {
    this.connectConsumerGroup();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.consumerGroupRecovery" id="apidoc.element.kafka-node.consumerGroupRecovery">
        function <span class="apidocSignatureSpan">kafka-node.</span>consumerGroupRecovery
        <span class="apidocSignatureSpan">(consumerGroup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ConsumerGroupRecovery(consumerGroup) {
  this.consumerGroup = consumerGroup;
  this.options = consumerGroup.options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.logging" id="apidoc.element.kafka-node.logging">
        function <span class="apidocSignatureSpan">kafka-node.</span>logging
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getLogger(name) {
  return loggerProvider(name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Client" id="apidoc.module.kafka-node.Client">module kafka-node.Client</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client.Client" id="apidoc.element.kafka-node.Client.Client">
        function <span class="apidocSignatureSpan">kafka-node.</span>Client
        <span class="apidocSignatureSpan">(connectionString, clientId, zkOptions, noAckBatchOptions, sslOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client = function (connectionString, clientId, zkOptions, noAckBatchOptions, sslOptions) {
  if (this instanceof Client === false) {
    return new Client(connectionString, clientId, zkOptions, noAckBatchOptions, sslOptions);
  }

  this.sslOptions = sslOptions;
  this.ssl = !!sslOptions;

  if (clientId) {
    validateConfig(&#x27;clientId&#x27;, clientId);
  }

  this.connectionString = connectionString || &#x27;localhost:2181/&#x27;;
  this.clientId = clientId || &#x27;kafka-node-client&#x27;;
  this.zkOptions = zkOptions;
  this.noAckBatchOptions = noAckBatchOptions;
  this.brokers = {};
  this.longpollingBrokers = {};
  this.topicMetadata = {};
  this.topicPartitions = {};
  this.correlationId = 0;
  this._socketId = 0;
  this.cbqueue = {};
  this.brokerMetadata = {};
  this.ready = false;
  this.connect();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    partitionerType: 2
}
```

``` js
var kafka = require(&#x27;kafka-node&#x27;),
    Producer = kafka.Producer,
    client = new kafka.<span class="apidocCodeKeywordSpan">Client</span>(),
    producer = new Producer(client);
```

### Events

- `ready`: this event is emitted when producer is ready to send messages.
- `error`: this is the error event propagates from internal client, producer should always listen it.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.super_" id="apidoc.element.kafka-node.Client.super_">
        function <span class="apidocSignatureSpan">kafka-node.Client.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Client.prototype" id="apidoc.module.kafka-node.Client.prototype">module kafka-node.Client.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.addTopics" id="apidoc.element.kafka-node.Client.prototype.addTopics">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>addTopics
        <span class="apidocSignatureSpan">(topics, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addTopics = function (topics, cb) {
  var self = this;
  this.topicExists(topics, function (err) {
    if (err) return cb(err);
    self.loadMetadataForTopics(topics, function (err, resp) {
      if (err) return cb(err);
      self.updateMetadatas(resp);
      cb(null, topics);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `topics`: **Array**, array of topics to add
* `cb`: **Function**,the callback
* `fromOffset`: **Boolean**, if true, the consumer will fetch message from the specified offset, otherwise it will fetch message
 from the last commited offset of the topic.

Example:

``` js
consumer.<span class="apidocCodeKeywordSpan">addTopics</span>([&#x27;t1&#x27;, &#x27;t2&#x27;], function (err, added) {
});

or

consumer.addTopics([{ topic: &#x27;t1&#x27;, offset: 10 }], function (err, added) {
}, true);
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.brokerForLeader" id="apidoc.element.kafka-node.Client.prototype.brokerForLeader">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>brokerForLeader
        <span class="apidocSignatureSpan">(leader, longpolling)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">brokerForLeader = function (leader, longpolling) {
  var addr;
  var brokers = this.getBrokers(longpolling);
  // If leader is not give, choose the first broker as leader
  if (typeof leader === &#x27;undefined&#x27;) {
    if (!_.isEmpty(brokers)) {
      addr = Object.keys(brokers)[0];
      return brokers[addr];
    } else if (!_.isEmpty(this.brokerMetadata)) {
      leader = Object.keys(this.brokerMetadata)[0];
    } else {
      return;
    }
  }

  var broker = _.find(this.brokerProfiles, {id: leader});

  if (!broker) {
    return;
  }

  addr = broker.host + &#x27;:&#x27; + broker.port;

  return brokers[addr] || this.setupBroker(broker.host, broker.port, longpolling, brokers);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.checkMetadatas" id="apidoc.element.kafka-node.Client.prototype.checkMetadatas">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>checkMetadatas
        <span class="apidocSignatureSpan">(payloads)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkMetadatas = function (payloads) {
  if (_.isEmpty(this.topicMetadata)) return [ [], payloads ];
  // out: [ [metadata exists], [metadata not exists] ]
  var out = [ [], [] ];
  payloads.forEach(function (p) {
    if (this.hasMetadata(p.topic, p.partition)) out[0].push(p);
    else out[1].push(p);
  }.bind(this));
  return out;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.clearCallbackQueue" id="apidoc.element.kafka-node.Client.prototype.clearCallbackQueue">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>clearCallbackQueue
        <span class="apidocSignatureSpan">(socket, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearCallbackQueue = function (socket, error) {
  var socketId = socket.socketId;
  var longpolling = socket.longpolling;

  if (!this.cbqueue.hasOwnProperty(socketId)) {
    return;
  }

  var queue = this.cbqueue[socketId];

  if (!longpolling) {
    Object.keys(queue).forEach(function (key) {
      var handlers = queue[key];
      var cb = handlers[1];
      cb(error);
    });
  }
  delete this.cbqueue[socketId];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.close" id="apidoc.element.kafka-node.Client.prototype.close">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>close
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (cb) {
  this.closeBrokers(this.brokers);
  this.closeBrokers(this.longpollingBrokers);
  this.zk.close();
  cb &#x26;&#x26; cb();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### close(force, cb)
* `force`: **Boolean**, if set to true, it forces the consumer to commit the current offset before closing, default `false`

Example

```js
consumer.<span class="apidocCodeKeywordSpan">close</span>(true, cb);
consumer.close(cb); //force is disabled
```

## HighLevelConsumer
⚠️ ***This consumer has been deprecated in the latest version of Kafka (0.10.1) and is likely to be removed in the future. Please
 use the ConsumerGroup instead.***

### HighLevelConsumer(client, payloads, options)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.closeBrokers" id="apidoc.element.kafka-node.Client.prototype.closeBrokers">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>closeBrokers
        <span class="apidocSignatureSpan">(brokers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">closeBrokers = function (brokers) {
  _.each(brokers, function (broker) {
    broker.socket.closing = true;
    broker.socket.end();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.connect" id="apidoc.element.kafka-node.Client.prototype.connect">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>connect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connect = function () {
  var zk = this.zk = new Zookeeper(this.connectionString, this.zkOptions);
  var self = this;
  zk.once(&#x27;init&#x27;, function (brokers) {
    try {
      self.ready = true;
      self.brokerMetadata = brokers;
      self.setupBrokerProfiles(brokers);
      Object
          .keys(self.brokerProfiles)
          .some(function (key, index) {
            var broker = self.brokerProfiles[key];
            self.setupBroker(broker.host, broker.port, false, self.brokers);
            // Only connect one broker
            return !index;
          });
      self.emit(&#x27;ready&#x27;);
    } catch (error) {
      self.ready = false;
      self.emit(&#x27;error&#x27;, error);
    }
  });
  zk.on(&#x27;brokersChanged&#x27;, function (brokerMetadata) {
    try {
      self.brokerMetadata = brokerMetadata;
      logger.debug(&#x27;brokersChanged&#x27;, brokerMetadata);
      self.setupBrokerProfiles(brokerMetadata);
      self.refreshBrokers();
      // Emit after a 3 seconds
      setTimeout(function () {
        self.emit(&#x27;brokersChanged&#x27;);
      }, 3000);
    } catch (error) {
      self.emit(&#x27;error&#x27;, error);
    }
  });
  zk.once(&#x27;disconnected&#x27;, function () {
    if (!zk.closed) {
      zk.close();
      self.connect();
      self.emit(&#x27;zkReconnect&#x27;);
    }
  });
  zk.on(&#x27;error&#x27;, function (err) {
    self.emit(&#x27;error&#x27;, err);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    });

    this.on(&#x27;topicOwnerChange&#x27;, _.debounce(function (topics) {
      verified = 0;
      self.checkForOwnersAndListenForChange(topics);
    }, 250));

    this.zk.<span class="apidocCodeKeywordSpan">connect</span>();
  } else {
    this.connectConsumerGroup();
  }
}

util.inherits(ConsumerGroupMigrator, EventEmitter);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.createBroker" id="apidoc.element.kafka-node.Client.prototype.createBroker">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>createBroker
        <span class="apidocSignatureSpan">(host, port, longpolling)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createBroker = function (host, port, longpolling) {
  var self = this;
  var socket;
  if (self.ssl) {
    socket = tls.connect(port, host, self.sslOptions);
  } else {
    socket = net.createConnection(port, host);
  }
  socket.addr = host + &#x27;:&#x27; + port;
  socket.host = host;
  socket.port = port;
  socket.socketId = this.nextSocketId();
  if (longpolling) socket.longpolling = true;

  socket.on(&#x27;connect&#x27;, function () {
    var lastError = this.error;
    this.error = null;
    if (lastError) {
      this.waiting = false;
      self.emit(&#x27;reconnect&#x27;);
    } else {
      self.emit(&#x27;connect&#x27;);
    }
  });
  socket.on(&#x27;error&#x27;, function (err) {
    this.error = err;
    self.emit(&#x27;error&#x27;, err);
  });
  socket.on(&#x27;close&#x27;, function (hadError) {
    self.emit(&#x27;close&#x27;, this);
    if (hadError &#x26;&#x26; this.error) {
      self.clearCallbackQueue(this, this.error);
    } else {
      self.clearCallbackQueue(this, new errors.BrokerNotAvailableError(&#x27;Broker not available&#x27;));
    }
    retry(this);
  });
  socket.on(&#x27;end&#x27;, function () {
    retry(this);
  });
  socket.buffer = new Buffer([]);
  socket.on(&#x27;data&#x27;, function (data) {
    this.buffer = Buffer.concat([this.buffer, data]);
    self.handleReceivedData(this);
  });
  socket.setKeepAlive(true, 60000);

  function retry (s) {
    if (s.retrying || s.closing) return;
    s.retrying = true;
    s.retryTimer = setTimeout(function () {
      if (s.closing) return;
      self.reconnectBroker(s);
    }, 1000);
  }
  return new BrokerWrapper(socket, this.noAckBatchOptions);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.createTopics" id="apidoc.element.kafka-node.Client.prototype.createTopics">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>createTopics
        <span class="apidocSignatureSpan">(topics, isAsync, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createTopics = function (topics, isAsync, cb) {
  topics = typeof topics === &#x27;string&#x27; ? [topics] : topics;

  if (typeof isAsync === &#x27;function&#x27; &#x26;&#x26; typeof cb === &#x27;undefined&#x27;) {
    cb = isAsync;
    isAsync = true;
  }

  try {
    validateKafkaTopics(topics);
  } catch (e) {
    if (isAsync) return cb(e);
    throw e;
  }

  cb = _.once(cb);

  const getTopicsFromKafka = (topics, callback) =&#x3e; {
    this.loadMetadataForTopics(topics, function (error, resp) {
      if (error) {
        return callback(error);
      }
      callback(null, Object.keys(resp[1].metadata));
    });
  };

  const operation = retry.operation({ minTimeout: 200, maxTimeout: 2000 });

  operation.attempt(currentAttempt =&#x3e; {
    logger.debug(&#x27;create topics currentAttempt&#x27;, currentAttempt);
    getTopicsFromKafka(topics, function (error, kafkaTopics) {
      if (error) {
        if (operation.retry(error)) {
          return;
        }
      }

      logger.debug(&#x27;kafka reported topics&#x27;, kafkaTopics);
      const left = _.difference(topics, kafkaTopics);
      if (left.length === 0) {
        logger.debug(`Topics created ${kafkaTopics}`);
        return cb(null, kafkaTopics);
      }

      logger.debug(`Topics left ${left.join(&#x27;, &#x27;)}`);
      if (!operation.retry(new Error(`Topics not created ${left}`))) {
        cb(operation.mainError());
      }
    });
  });

  if (!isAsync) {
    cb(null);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

``` js
var kafka = require(&#x27;kafka-node&#x27;),
    Producer = kafka.Producer,
    client = new kafka.Client(),
    producer = new Producer(client);
// Create topics sync
producer.<span class="apidocCodeKeywordSpan">createTopics</span>([&#x27;t&#x27;,&#x27;t1&#x27;], false, function (err, data) {
    console.log(data);
});
// Create topics async
producer.createTopics([&#x27;t&#x27;], true, function (err, data) {});
producer.createTopics([&#x27;t&#x27;], function (err, data) {});// Simply omit 2nd arg
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.getBrokers" id="apidoc.element.kafka-node.Client.prototype.getBrokers">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>getBrokers
        <span class="apidocSignatureSpan">(longpolling)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getBrokers = function (longpolling) {
  return longpolling ? this.longpollingBrokers : this.brokers;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.handleReceivedData" id="apidoc.element.kafka-node.Client.prototype.handleReceivedData">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>handleReceivedData
        <span class="apidocSignatureSpan">(socket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleReceivedData = function (socket) {
  var vars = Binary.parse(socket.buffer).word32bu(&#x27;size&#x27;).word32bu(&#x27;correlationId&#x27;).vars;
  var size = vars.size + 4;
  var correlationId = vars.correlationId;

  if (socket.buffer.length &#x3e;= size) {
    var resp = socket.buffer.slice(0, size);
    var handlers = this.unqueueCallback(socket, correlationId);

    if (!handlers) return;
    var decoder = handlers[0];
    var cb = handlers[1];
    var result = decoder(resp);
    (result instanceof Error)
      ? cb.call(this, result)
      : cb.call(this, null, result);
    socket.buffer = socket.buffer.slice(size);
    if (socket.longpolling) socket.waiting = false;
  } else { return; }

  if (socket.buffer.length) {
    setImmediate(function () { this.handleReceivedData(socket); }.bind(this));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.hasMetadata" id="apidoc.element.kafka-node.Client.prototype.hasMetadata">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>hasMetadata
        <span class="apidocSignatureSpan">(topic, partition)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasMetadata = function (topic, partition) {
  var brokerMetadata = this.brokerMetadata;
  var leader = this.leaderByPartition(topic, partition);

  return (leader !== undefined) &#x26;&#x26; brokerMetadata[leader];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.leaderByPartition" id="apidoc.element.kafka-node.Client.prototype.leaderByPartition">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>leaderByPartition
        <span class="apidocSignatureSpan">(topic, partition)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">leaderByPartition = function (topic, partition) {
  var topicMetadata = this.topicMetadata;
  return topicMetadata[topic] &#x26;&#x26; topicMetadata[topic][partition] &#x26;&#x26; topicMetadata[topic][partition].leader;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.loadMetadataForTopics" id="apidoc.element.kafka-node.Client.prototype.loadMetadataForTopics">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>loadMetadataForTopics
        <span class="apidocSignatureSpan">(topics, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadMetadataForTopics = function (topics, cb) {
  var correlationId = this.nextId();
  var request = protocol.encodeMetadataRequest(this.clientId, correlationId, topics);
  var broker = this.brokerForLeader();

  if (!broker || !broker.socket || broker.socket.error || broker.socket.destroyed) {
    return cb(new errors.BrokerNotAvailableError(&#x27;Broker not available&#x27;));
  }

  this.queueCallback(broker.socket, correlationId, [protocol.decodeMetadataResponse, cb]);
  broker.write(request);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

## How do I get a list of all topics?

Call `client.loadMetadataForTopics` with a blank topic array to get the entire list of available topics (and available brokers).

```js
client.once(&#x27;connect&#x27;, function () {
	client.<span class="apidocCodeKeywordSpan">loadMetadataForTopics</span>([], function (error, results) {
	  if (error) {
	  	return console.error(error);
	  }
	  console.log(&#x27;%j&#x27;, _.get(results, &#x27;1.metadata&#x27;));
	});
});
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.nextId" id="apidoc.element.kafka-node.Client.prototype.nextId">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>nextId
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nextId = function () {
  if (this.correlationId &#x3e;= MAX_INT32) {
    this.correlationId = 0;
  }
  return this.correlationId++;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.nextSocketId" id="apidoc.element.kafka-node.Client.prototype.nextSocketId">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>nextSocketId
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nextSocketId = function () {
  return this._socketId++;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.payloadsByLeader" id="apidoc.element.kafka-node.Client.prototype.payloadsByLeader">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>payloadsByLeader
        <span class="apidocSignatureSpan">(payloads)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">payloadsByLeader = function (payloads) {
  return payloads.reduce(function (out, p) {
    var leader = this.leaderByPartition(p.topic, p.partition);
    out[leader] = out[leader] || [];
    out[leader].push(p);
    return out;
  }.bind(this), {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.queueCallback" id="apidoc.element.kafka-node.Client.prototype.queueCallback">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>queueCallback
        <span class="apidocSignatureSpan">(socket, id, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">queueCallback = function (socket, id, data) {
  var socketId = socket.socketId;
  var queue;

  if (this.cbqueue.hasOwnProperty(socketId)) {
    queue = this.cbqueue[socketId];
  } else {
    queue = {};
    this.cbqueue[socketId] = queue;
  }

  queue[id] = data;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.reconnectBroker" id="apidoc.element.kafka-node.Client.prototype.reconnectBroker">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>reconnectBroker
        <span class="apidocSignatureSpan">(oldSocket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reconnectBroker = function (oldSocket) {
  oldSocket.retrying = false;
  if (oldSocket.error) {
    oldSocket.destroy();
  }
  var brokers = this.getBrokers(oldSocket.longpolling);
  var newBroker = this.setupBroker(oldSocket.host, oldSocket.port, oldSocket.longpolling, brokers);
  newBroker.socket.error = oldSocket.error;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.refreshBrokers" id="apidoc.element.kafka-node.Client.prototype.refreshBrokers">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>refreshBrokers
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">refreshBrokers = function () {
  var self = this;
  var validBrokers = Object.keys(this.brokerProfiles);

  function closeDeadBrokers (brokers) {
    var deadBrokerKeys = _.difference(Object.keys(brokers), validBrokers);
    if (deadBrokerKeys.length) {
      self.closeBrokers(deadBrokerKeys.map(function (key) {
        var broker = brokers[key];
        delete brokers[key];
        return broker;
      }));
    }
  }

  closeDeadBrokers(this.brokers);
  closeDeadBrokers(this.longpollingBrokers);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.refreshMetadata" id="apidoc.element.kafka-node.Client.prototype.refreshMetadata">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>refreshMetadata
        <span class="apidocSignatureSpan">(topicNames, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">refreshMetadata = function (topicNames, cb) {
  var self = this;
  if (!topicNames.length) return cb();
  attemptRequestMetadata(topicNames, cb);

  function attemptRequestMetadata (topics, cb) {
    var operation = retry.operation({ minTimeout: 200, maxTimeout: 1000 });
    operation.attempt(function (currentAttempt) {
      logger.debug(&#x27;refresh metadata currentAttempt&#x27;, currentAttempt);
      self.loadMetadataForTopics(topics, function (err, resp) {
        err = err || resp[1].error;
        if (operation.retry(err)) {
          return;
        }
        if (err) {
          logger.debug(&#x27;refresh metadata error&#x27;, err.message);
          return cb(err);
        }
        self.updateMetadatas(resp);
        cb();
      });
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Error:

```
BrokerNotAvailableError: Could not find the leader
```

Call `client.<span class="apidocCodeKeywordSpan">refreshMetadata</span>()` before sending the first message. Reference issue [#354
](https://github.com/SOHU-Co/kafka-node/issues/354)



## How do I debug an issue?
This module uses the [debug module](https://github.com/visionmedia/debug) so you can just run below before starting your app.

```bash
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.removeTopicMetadata" id="apidoc.element.kafka-node.Client.prototype.removeTopicMetadata">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>removeTopicMetadata
        <span class="apidocSignatureSpan">(topics, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeTopicMetadata = function (topics, cb) {
  topics.forEach(function (t) {
    if (this.topicMetadata[t]) delete this.topicMetadata[t];
  }.bind(this));
  cb(null, topics.length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.send" id="apidoc.element.kafka-node.Client.prototype.send">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>send
        <span class="apidocSignatureSpan">(payloads, encoder, decoder, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">send = function (payloads, encoder, decoder, cb) {
  var self = this;
  var _payloads = payloads;
  // payloads: [ [metadata exists], [metadata not exists] ]
  payloads = this.checkMetadatas(payloads);
  if (payloads[0].length &#x26;&#x26; !payloads[1].length) {
    this.sendToBroker(_.flatten(payloads), encoder, decoder, cb);
    return;
  }
  if (payloads[1].length) {
    var topicNames = payloads[1].map(function (p) { return p.topic; });
    this.loadMetadataForTopics(topicNames, function (err, resp) {
      if (err) {
        return cb(err);
      }

      var error = resp[1].error;
      if (error) {
        return cb(error);
      }

      self.updateMetadatas(resp);
      // check payloads again
      payloads = self.checkMetadatas(_payloads);
      if (payloads[1].length) {
        return cb(new errors.BrokerNotAvailableError(&#x27;Could not find the leader&#x27;));
      }

      self.sendToBroker(payloads[1].concat(payloads[0]), encoder, decoder, cb);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    producer = new Producer(client),
    km = new KeyedMessage(&#x27;key&#x27;, &#x27;message&#x27;),
    payloads = [
        { topic: &#x27;topic1&#x27;, messages: &#x27;hi&#x27;, partition: 0 },
        { topic: &#x27;topic2&#x27;, messages: [&#x27;hello&#x27;, &#x27;world&#x27;, km] }
    ];
producer.on(&#x27;ready&#x27;, function () {
    producer.<span class="apidocCodeKeywordSpan">send</span>(payloads, function (err, data) {
        console.log(data);
    });
});

producer.on(&#x27;error&#x27;, function (err) {})
```
&#x3e; ⚠️**WARNING**: Batch multiple messages of the same topic/partition together as an array on the `messages` attribute otherwise
 you may lose messages!
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendFetchRequest" id="apidoc.element.kafka-node.Client.prototype.sendFetchRequest">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendFetchRequest
        <span class="apidocSignatureSpan">(consumer, payloads, fetchMaxWaitMs, fetchMinBytes, maxTickMessages)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendFetchRequest = function (consumer, payloads, fetchMaxWaitMs, fetchMinBytes, maxTickMessages) {
  var self = this;
  var encoder = protocol.encodeFetchRequest(fetchMaxWaitMs, fetchMinBytes);
  var decoder = protocol.decodeFetchResponse(function (err, type, message) {
    if (err) {
      if (err.message === &#x27;OffsetOutOfRange&#x27;) {
        return consumer.emit(&#x27;offsetOutOfRange&#x27;, err);
      } else if (err.message === &#x27;NotLeaderForPartition&#x27; || err.message === &#x27;UnknownTopicOrPartition&#x27;) {
        return self.emit(&#x27;brokersChanged&#x27;);
      }

      return consumer.emit(&#x27;error&#x27;, err);
    }

    var encoding = consumer.options.encoding;

    if (type === &#x27;message&#x27;) {
      if (encoding !== &#x27;buffer&#x27; &#x26;&#x26; message.value) {
        message.value = message.value.toString(encoding);
      }

      consumer.emit(&#x27;message&#x27;, message);
    } else {
      consumer.emit(&#x27;done&#x27;, message);
    }
  }, maxTickMessages);

  this.send(payloads, encoder, decoder, function (err) {
    if (err) {
      Array.prototype.unshift.call(arguments, &#x27;error&#x27;);
      consumer.emit.apply(consumer, arguments);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendGroupCoordinatorRequest" id="apidoc.element.kafka-node.Client.prototype.sendGroupCoordinatorRequest">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendGroupCoordinatorRequest
        <span class="apidocSignatureSpan">(groupId, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendGroupCoordinatorRequest = function (groupId, cb) {
  this.sendGroupRequest(protocol.encodeGroupCoordinatorRequest, protocol.decodeGroupCoordinatorResponse, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendGroupRequest" id="apidoc.element.kafka-node.Client.prototype.sendGroupRequest">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendGroupRequest
        <span class="apidocSignatureSpan">(encode, decode, requestArgs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendGroupRequest = function (encode, decode, requestArgs) {
  requestArgs = _.values(requestArgs);
  var cb = requestArgs.pop();
  var correlationId = this.nextId();

  requestArgs.unshift(this.clientId, correlationId);

  var request = encode.apply(null, requestArgs);
  var broker = this.brokerForLeader(this.coordinatorId);

  if (!broker || !broker.socket || broker.socket.error || broker.socket.destroyed) {
    return cb(new errors.BrokerNotAvailableError(&#x27;Broker not available&#x27;));
  }

  this.queueCallback(broker.socket, correlationId, [decode, cb]);
  broker.write(request);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendHeartbeatRequest" id="apidoc.element.kafka-node.Client.prototype.sendHeartbeatRequest">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendHeartbeatRequest
        <span class="apidocSignatureSpan">(groupId, generationId, memberId, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendHeartbeatRequest = function (groupId, generationId, memberId, cb) {
  this.sendGroupRequest(protocol.encodeGroupHeartbeat, protocol.decodeGroupHeartbeat, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
constructor (client, handler) {
  this.client = client;
  this.handler = handler;
  this.pending = true;
}

send (groupId, generationId, memberId) {
  this.client.<span class="apidocCodeKeywordSpan">sendHeartbeatRequest</span>(groupId, generationId, memberId, (error) =&#x3e; {
    if (this.canceled) {
      logger.debug(&#x27;heartbeat yielded after being canceled&#x27;, error);
      return;
    }
    this.pending = false;
    this.handler(error);
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendJoinGroupRequest" id="apidoc.element.kafka-node.Client.prototype.sendJoinGroupRequest">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendJoinGroupRequest
        <span class="apidocSignatureSpan">(groupId, memberId, sessionTimeout, groupProtocol, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendJoinGroupRequest = function (groupId, memberId, sessionTimeout, groupProtocol, cb) {
  this.sendGroupRequest(protocol.encodeJoinGroupRequest, protocol.decodeJoinGroupResponse, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendLeaveGroupRequest" id="apidoc.element.kafka-node.Client.prototype.sendLeaveGroupRequest">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendLeaveGroupRequest
        <span class="apidocSignatureSpan">(groupId, memberId, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendLeaveGroupRequest = function (groupId, memberId, cb) {
  this.sendGroupRequest(protocol.encodeLeaveGroupRequest, protocol.decodeLeaveGroupResponse, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendOffsetCommitRequest" id="apidoc.element.kafka-node.Client.prototype.sendOffsetCommitRequest">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendOffsetCommitRequest
        <span class="apidocSignatureSpan">(group, payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendOffsetCommitRequest = function (group, payloads, cb) {
  var encoder = protocol.encodeOffsetCommitRequest(group);
  var decoder = protocol.decodeOffsetCommitResponse;
  this.send(payloads, encoder, decoder, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendOffsetCommitV2Request" id="apidoc.element.kafka-node.Client.prototype.sendOffsetCommitV2Request">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendOffsetCommitV2Request
        <span class="apidocSignatureSpan">(group, generationId, memberId, payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendOffsetCommitV2Request = function (group, generationId, memberId, payloads, cb) {
  var encoder = protocol.encodeOffsetCommitV2Request;
  var decoder = protocol.decodeOffsetCommitResponse;
  this.sendGroupRequest(encoder, decoder, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendOffsetFetchRequest" id="apidoc.element.kafka-node.Client.prototype.sendOffsetFetchRequest">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendOffsetFetchRequest
        <span class="apidocSignatureSpan">(group, payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendOffsetFetchRequest = function (group, payloads, cb) {
  var encoder = protocol.encodeOffsetFetchRequest(group);
  var decoder = protocol.decodeOffsetFetchResponse;
  this.send(payloads, encoder, decoder, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }
);
};

ConsumerGroupMigrator.prototype.saveHighLevelConsumerOffsets = function (topicPartitionList, callback) {
const self = this;
this.client.<span class="apidocCodeKeywordSpan">sendOffsetFetchRequest</span>(this.consumerGroup.options.groupId, topicPartitionList
, function (error, results) {
  logger.debug(&#x27;sendOffsetFetchRequest response:&#x27;, results, error);
  if (error) {
    return callback(error);
  }
  self.offsets = results;
  callback(null);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendOffsetFetchV1Request" id="apidoc.element.kafka-node.Client.prototype.sendOffsetFetchV1Request">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendOffsetFetchV1Request
        <span class="apidocSignatureSpan">(group, payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendOffsetFetchV1Request = function (group, payloads, cb) {
  var encoder = protocol.encodeOffsetFetchV1Request;
  var decoder = protocol.decodeOffsetFetchV1Response;
  this.sendGroupRequest(encoder, decoder, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendOffsetRequest" id="apidoc.element.kafka-node.Client.prototype.sendOffsetRequest">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendOffsetRequest
        <span class="apidocSignatureSpan">(payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendOffsetRequest = function (payloads, cb) {
  var encoder = protocol.encodeOffsetRequest;
  var decoder = protocol.decodeOffsetResponse;
  this.send(payloads, encoder, decoder, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendProduceRequest" id="apidoc.element.kafka-node.Client.prototype.sendProduceRequest">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendProduceRequest
        <span class="apidocSignatureSpan">(payloads, requireAcks, ackTimeoutMs, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendProduceRequest = function (payloads, requireAcks, ackTimeoutMs, cb) {
  var encoder = protocol.encodeProduceRequest(requireAcks, ackTimeoutMs);
  var decoder = protocol.decodeProduceResponse;
  var self = this;

  decoder.requireAcks = requireAcks;

  async.each(payloads, buildRequest, function (err) {
    if (err) return cb(err);
    self.send(payloads, encoder, decoder, function (err, result) {
      if (err) {
        if (err.message === &#x27;NotLeaderForPartition&#x27;) {
          self.emit(&#x27;brokersChanged&#x27;);
        }
        cb(err);
      } else {
        cb(null, result);
      }
    });
  });

  function buildRequest (payload, cb) {
    var attributes = payload.attributes;
    var codec = getCodec(attributes);

    if (!codec) return cb();

    var innerSet = encodeMessageSet(payload.messages);
    codec.encode(innerSet, function (err, message) {
      if (err) return cb(err);
      payload.messages = [ new Message(0, attributes, &#x27;&#x27;, message) ];
      cb();
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendSyncGroupRequest" id="apidoc.element.kafka-node.Client.prototype.sendSyncGroupRequest">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendSyncGroupRequest
        <span class="apidocSignatureSpan">(groupId, generationId, memberId, groupAssignment, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendSyncGroupRequest = function (groupId, generationId, memberId, groupAssignment, cb) {
  this.sendGroupRequest(protocol.encodeSyncGroupRequest, protocol.decodeSyncGroupResponse, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendToBroker" id="apidoc.element.kafka-node.Client.prototype.sendToBroker">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendToBroker
        <span class="apidocSignatureSpan">(payloads, encoder, decoder, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendToBroker = function (payloads, encoder, decoder, cb) {
  var longpolling = encoder.name === &#x27;encodeFetchRequest&#x27;;
  payloads = this.payloadsByLeader(payloads);
  if (!longpolling) {
    cb = wrap(payloads, cb);
  }
  for (var leader in payloads) {
    if (!payloads.hasOwnProperty(leader)) {
      continue;
    }
    var correlationId = this.nextId();
    var request = encoder(this.clientId, correlationId, payloads[leader]);
    var broker = this.brokerForLeader(leader, longpolling);
    if (!broker || !broker.socket || broker.socket.error || broker.socket.closing || broker.socket.destroyed) {
      return cb(new errors.BrokerNotAvailableError(&#x27;Could not find the leader&#x27;), payloads[leader]);
    }

    if (longpolling) {
      if (broker.socket.waiting) continue;
      broker.socket.waiting = true;
    }

    if (decoder.requireAcks === 0) {
      broker.writeAsync(request);
      cb(null, { result: &#x27;no ack&#x27; });
    } else {
      this.queueCallback(broker.socket, correlationId, [decoder, cb]);
      broker.write(request);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.setupBroker" id="apidoc.element.kafka-node.Client.prototype.setupBroker">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>setupBroker
        <span class="apidocSignatureSpan">(host, port, longpolling, brokers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setupBroker = function (host, port, longpolling, brokers) {
  var brokerKey = host + &#x27;:&#x27; + port;
  brokers[brokerKey] = this.createBroker(host, port, longpolling);
  return brokers[brokerKey];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.setupBrokerProfiles" id="apidoc.element.kafka-node.Client.prototype.setupBrokerProfiles">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>setupBrokerProfiles
        <span class="apidocSignatureSpan">(brokers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setupBrokerProfiles = function (brokers) {
  this.brokerProfiles = Object.create(null);
  var self = this;
  var protocol = self.ssl ? &#x27;ssl:&#x27; : &#x27;plaintext:&#x27;;

  Object.keys(brokers).forEach(function (key) {
    var brokerProfile = brokers[key];
    var addr;

    if (brokerProfile.endpoints &#x26;&#x26; brokerProfile.endpoints.length) {
      var endpoint = _.find(brokerProfile.endpoints, function (endpoint) {
        return url.parse(endpoint).protocol === protocol;
      });

      if (endpoint == null) {
        throw new Error([&#x27;No kafka endpoint found for broker: &#x27;, key, &#x27; with protocol &#x27;, protocol].join(&#x27;&#x27;));
      }

      var endpointUrl = url.parse(endpoint);

      addr = endpointUrl.hostname + &#x27;:&#x27; + endpointUrl.port;

      brokerProfile.host = endpointUrl.hostname;
      brokerProfile.port = endpointUrl.port;
    } else {
      addr = brokerProfile.host + &#x27;:&#x27; + brokerProfile.port;
    }
    assert(brokerProfile.host &#x26;&#x26; brokerProfile.port, &#x27;kafka host or port is empty&#x27;);

    self.brokerProfiles[addr] = brokerProfile;
    self.brokerProfiles[addr].id = key;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.topicExists" id="apidoc.element.kafka-node.Client.prototype.topicExists">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>topicExists
        <span class="apidocSignatureSpan">(topics, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">topicExists = function (topics, cb) {
  var notExistsTopics = [];
  var self = this;

  async.each(topics, checkZK, function (err) {
    if (err) return cb(err);
    if (notExistsTopics.length) return cb(new errors.TopicsNotExistError(notExistsTopics));
    cb();
  });

  function checkZK (topic, cb) {
    self.zk.topicExists(topic, function (err, existed, topic) {
      if (err) return cb(err);
      if (!existed) notExistsTopics.push(topic);
      cb();
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var path = &#x27;/brokers/topics/&#x27; + topic;
var self = this;
this.client.exists(
  path,
  function (event) {
    logger.debug(&#x27;Got event: %s.&#x27;, event);
    if (watch) {
      self.<span class="apidocCodeKeywordSpan">topicExists</span>(topic, cb);
    }
  },
  function (error, stat) {
    if (error) return cb(error);
    cb(null, !!stat, topic);
  }
);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.unqueueCallback" id="apidoc.element.kafka-node.Client.prototype.unqueueCallback">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>unqueueCallback
        <span class="apidocSignatureSpan">(socket, id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unqueueCallback = function (socket, id) {
  var socketId = socket.socketId;

  if (!this.cbqueue.hasOwnProperty(socketId)) {
    return null;
  }

  var queue = this.cbqueue[socketId];
  if (!queue.hasOwnProperty(id)) {
    return null;
  }

  var result = queue[id];

  // cleanup socket queue
  delete queue[id];
  if (!Object.keys(queue).length) {
    delete this.cbqueue[socketId];
  }

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.updateMetadatas" id="apidoc.element.kafka-node.Client.prototype.updateMetadatas">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>updateMetadatas
        <span class="apidocSignatureSpan">(metadatas)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateMetadatas = function (metadatas) {
  // _.extend(this.brokerMetadata, metadatas[0])
  _.extend(this.topicMetadata, metadatas[1].metadata);
  for (var topic in this.topicMetadata) {
    if (!this.topicMetadata.hasOwnProperty(topic)) {
      continue;
    }
    this.topicPartitions[topic] = Object.keys(this.topicMetadata[topic]).map(function (val) {
      return parseInt(val, 10);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Consumer" id="apidoc.module.kafka-node.Consumer">module kafka-node.Consumer</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.Consumer" id="apidoc.element.kafka-node.Consumer.Consumer">
        function <span class="apidocSignatureSpan">kafka-node.</span>Consumer
        <span class="apidocSignatureSpan">(client, topics, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Consumer = function (client, topics, options) {
  if (!topics) {
    throw new Error(&#x27;Must have payloads&#x27;);
  }

  utils.validateTopics(topics);

  this.fetchCount = 0;
  this.client = client;
  this.options = _.defaults((options || {}), DEFAULTS);
  this.ready = false;
  this.paused = this.options.paused;
  this.id = nextId();
  this.payloads = this.buildPayloads(topics);
  this.connect();
  this.encoding = this.options.encoding;

  if (this.options.groupId) {
    utils.validateConfig(&#x27;options.groupId&#x27;, this.options.groupId);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.super_" id="apidoc.element.kafka-node.Consumer.super_">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Consumer.prototype" id="apidoc.module.kafka-node.Consumer.prototype">module kafka-node.Consumer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.addTopics" id="apidoc.element.kafka-node.Consumer.prototype.addTopics">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>addTopics
        <span class="apidocSignatureSpan">(topics, cb, fromOffset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addTopics = function (topics, cb, fromOffset) {
  fromOffset = !!fromOffset;
  var self = this;
  if (!this.ready) {
    setTimeout(function () {
      self.addTopics(topics, cb, fromOffset);
    }
    , 100);
    return;
  }

  // The default is that the topics is a string array of topic names
  var topicNames = topics;

  // If the topics is actually an object and not string we assume it is an array of payloads
  if (typeof topics[0] === &#x27;object&#x27;) {
    topicNames = topics.map(function (p) { return p.topic; });
  }

  this.client.addTopics(
    topicNames,
    function (err, added) {
      if (err) return cb &#x26;&#x26; cb(err, added);

      var payloads = self.buildPayloads(topics);
      var reFetch = !self.payloads.length;

      if (fromOffset) {
        payloads.forEach(function (p) {
          self.payloads.push(p);
        });
        if (reFetch) self.fetch();
        cb &#x26;&#x26; cb(null, added);
        return;
      }

      // update offset of topics that will be added
      self.fetchOffset(payloads, function (err, offsets) {
        if (err) return cb(err);
        payloads.forEach(function (p) {
          var offset = offsets[p.topic][p.partition];
          if (offset === -1) offset = 0;
          p.offset = offset;
          self.payloads.push(p);
        });
        if (reFetch) self.fetch();
        cb &#x26;&#x26; cb(null, added);
      });
    }
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `topics`: **Array**, array of topics to add
* `cb`: **Function**,the callback
* `fromOffset`: **Boolean**, if true, the consumer will fetch message from the specified offset, otherwise it will fetch message
 from the last commited offset of the topic.

Example:

``` js
consumer.<span class="apidocCodeKeywordSpan">addTopics</span>([&#x27;t1&#x27;, &#x27;t2&#x27;], function (err, added) {
});

or

consumer.addTopics([{ topic: &#x27;t1&#x27;, offset: 10 }], function (err, added) {
}, true);
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.autoCommit" id="apidoc.element.kafka-node.Consumer.prototype.autoCommit">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>autoCommit
        <span class="apidocSignatureSpan">(force, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function autoCommit(force, cb) {
  if (arguments.length === 1) {
    cb = force;
    force = false;
  }

  if (this.committing &#x26;&#x26; !force) return cb(null, &#x27;Offset committing&#x27;);

  this.committing = true;
  setTimeout(function () {
    this.committing = false;
  }.bind(this), this.options.autoCommitIntervalMs);

  var payloads = this.payloads;
  if (this.pausedPayloads) payloads = payloads.concat(this.pausedPayloads);

  var commits = payloads.filter(function (p) { return p.offset !== 0; });
  if (commits.length) {
    this.client.sendOffsetCommitRequest(this.options.groupId, commits, cb);
  } else {
    cb(null, &#x27;Nothing to be committed&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.buildPayloads" id="apidoc.element.kafka-node.Consumer.prototype.buildPayloads">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>buildPayloads
        <span class="apidocSignatureSpan">(payloads)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildPayloads = function (payloads) {
  var self = this;
  return payloads.map(function (p) {
    if (typeof p !== &#x27;object&#x27;) p = { topic: p };
    p.partition = p.partition || 0;
    p.offset = p.offset || 0;
    p.maxBytes = self.options.fetchMaxBytes;
    p.metadata = &#x27;m&#x27;; // metadata can be arbitrary
    return p;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.close" id="apidoc.element.kafka-node.Consumer.prototype.close">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>close
        <span class="apidocSignatureSpan">(force, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (force, cb) {
  this.ready = false;
  if (typeof force === &#x27;function&#x27;) {
    cb = force;
    force = false;
  }

  if (force) {
    this.commit(force, function (err) {
      if (err) {
        return cb(err);
      }
      this.client.close(cb);
    }.bind(this));
  } else {
    this.client.close(cb);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### close(force, cb)
* `force`: **Boolean**, if set to true, it forces the consumer to commit the current offset before closing, default `false`

Example

```js
consumer.<span class="apidocCodeKeywordSpan">close</span>(true, cb);
consumer.close(cb); //force is disabled
```

## HighLevelConsumer
⚠️ ***This consumer has been deprecated in the latest version of Kafka (0.10.1) and is likely to be removed in the future. Please
 use the ConsumerGroup instead.***

### HighLevelConsumer(client, payloads, options)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.commit" id="apidoc.element.kafka-node.Consumer.prototype.commit">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>commit
        <span class="apidocSignatureSpan">(force, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function autoCommit(force, cb) {
  if (arguments.length === 1) {
    cb = force;
    force = false;
  }

  if (this.committing &#x26;&#x26; !force) return cb(null, &#x27;Offset committing&#x27;);

  this.committing = true;
  setTimeout(function () {
    this.committing = false;
  }.bind(this), this.options.autoCommitIntervalMs);

  var payloads = this.payloads;
  if (this.pausedPayloads) payloads = payloads.concat(this.pausedPayloads);

  var commits = payloads.filter(function (p) { return p.offset !== 0; });
  if (commits.length) {
    this.client.sendOffsetCommitRequest(this.options.groupId, commits, cb);
  } else {
    cb(null, &#x27;Nothing to be committed&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Commit offset of the current topics manually, this method should be called when a consumer leaves

* `cb`: **Function**, the callback

Example:

``` js
consumer.<span class="apidocCodeKeywordSpan">commit</span>(function(err, data) {
});
```

### setOffset(topic, partition, offset)
Set offset of the given topic

* `topic`: **String**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.connect" id="apidoc.element.kafka-node.Consumer.prototype.connect">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>connect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connect = function () {
  var self = this;
  // Client already exists
  this.ready = this.client.ready;
  if (this.ready) this.init();

  this.client.on(&#x27;ready&#x27;, function () {
    logger.debug(&#x27;consumer ready&#x27;);
    if (!self.ready) self.init();
    self.ready = true;
  });

  this.client.on(&#x27;error&#x27;, function (err) {
    logger.error(&#x27;client error %s&#x27;, err.message);
    self.emit(&#x27;error&#x27;, err);
  });

  this.client.on(&#x27;close&#x27;, function () {
    logger.debug(&#x27;connection closed&#x27;);
  });

  this.client.on(&#x27;brokersChanged&#x27;, function () {
    var topicNames = self.payloads.map(function (p) {
      return p.topic;
    });

    this.refreshMetadata(topicNames, function (err) {
      if (err) return self.emit(&#x27;error&#x27;, err);
      self.fetch();
    });
  });
  // &#x27;done&#x27; will be emit when a message fetch request complete
  this.on(&#x27;done&#x27;, function (topics) {
    self.updateOffsets(topics);
    setImmediate(function () {
      self.fetch();
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    });

    this.on(&#x27;topicOwnerChange&#x27;, _.debounce(function (topics) {
      verified = 0;
      self.checkForOwnersAndListenForChange(topics);
    }, 250));

    this.zk.<span class="apidocCodeKeywordSpan">connect</span>();
  } else {
    this.connectConsumerGroup();
  }
}

util.inherits(ConsumerGroupMigrator, EventEmitter);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.fetch" id="apidoc.element.kafka-node.Consumer.prototype.fetch">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>fetch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetch = function () {
  if (!this.ready || this.paused) return;
  this.client.sendFetchRequest(this, this.payloads, this.options.fetchMaxWaitMs, this.options.fetchMinBytes);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Example

```js
var kafka = require(&#x27;kafka-node&#x27;),
    client = new kafka.Client(),
    offset = new kafka.Offset(client);
    offset.<span class="apidocCodeKeywordSpan">fetch</span>([
        { topic: &#x27;t&#x27;, partition: 0, time: Date.now(), maxNum: 1 }
    ], function (err, data) {
        // data
        // { &#x27;t&#x27;: { &#x27;0&#x27;: [999] } }
    });
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.fetchOffset" id="apidoc.element.kafka-node.Consumer.prototype.fetchOffset">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>fetchOffset
        <span class="apidocSignatureSpan">(payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetchOffset = function (payloads, cb) {
  this.client.sendOffsetFetchRequest(this.options.groupId, payloads, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.init" id="apidoc.element.kafka-node.Consumer.prototype.init">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>init
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init = function () {
  if (!this.payloads.length) {
    return;
  }

  var self = this;
  var topics = self.payloads.map(function (p) { return p.topic; });

  self.client.topicExists(topics, function (err) {
    if (err) {
      return self.emit(&#x27;error&#x27;, err);
    }

    if (self.options.fromOffset) {
      return self.fetch();
    }

    self.fetchOffset(self.payloads, function (err, topics) {
      if (err) {
        return self.emit(&#x27;error&#x27;, err);
      }

      self.updateOffsets(topics, true);
      self.fetch();
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.pause" id="apidoc.element.kafka-node.Consumer.prototype.pause">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>pause
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pause = function () {
  this.paused = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.pauseTopics" id="apidoc.element.kafka-node.Consumer.prototype.pauseTopics">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>pauseTopics
        <span class="apidocSignatureSpan">(topics)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pauseTopics = function (topics) {
  if (!this.pausedPayloads) this.pausedPayloads = [];
  pauseOrResume(this.payloads, this.pausedPayloads, topics);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### resume()
Resume the consumer. Resumes the fetch loop.

### pauseTopics(topics)
Pause specify topics

```
consumer.<span class="apidocCodeKeywordSpan">pauseTopics</span>([
    &#x27;topic1&#x27;,
    { topic: &#x27;topic2&#x27;, partition: 0 }
]);
```

### resumeTopics(topics)
Resume specify topics
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.removeTopics" id="apidoc.element.kafka-node.Consumer.prototype.removeTopics">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>removeTopics
        <span class="apidocSignatureSpan">(topics, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeTopics = function (topics, cb) {
  topics = typeof topics === &#x27;string&#x27; ? [topics] : topics;
  this.payloads = this.payloads.filter(function (p) {
    return !~topics.indexOf(p.topic);
  });

  this.client.removeTopicMetadata(topics, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### removeTopics(topics, cb)
* `topics`: **Array**, array of topics to remove
* `cb`: **Function**, the callback

Example:

``` js
consumer.<span class="apidocCodeKeywordSpan">removeTopics</span>([&#x27;t1&#x27;, &#x27;t2&#x27;], function (err, removed) {
});
```

### commit(cb)
Commit offset of the current topics manually, this method should be called when a consumer leaves

* `cb`: **Function**, the callback
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.resume" id="apidoc.element.kafka-node.Consumer.prototype.resume">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>resume
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resume = function () {
  this.paused = false;
  this.fetch();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.resumeTopics" id="apidoc.element.kafka-node.Consumer.prototype.resumeTopics">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>resumeTopics
        <span class="apidocSignatureSpan">(topics)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resumeTopics = function (topics) {
  if (!this.pausedPayloads) this.pausedPayloads = [];
  var reFetch = !this.payloads.length;
  pauseOrResume(this.pausedPayloads, this.payloads, topics);
  reFetch = reFetch &#x26;&#x26; this.payloads.length;
  if (reFetch) this.fetch();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
]);
```

### resumeTopics(topics)
Resume specify topics

```
consumer.<span class="apidocCodeKeywordSpan">resumeTopics</span>([
    &#x27;topic1&#x27;,
    { topic: &#x27;topic2&#x27;, partition: 0 }
]);
```

### close(force, cb)
* `force`: **Boolean**, if set to true, it forces the consumer to commit the current offset before closing, default `false`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.setOffset" id="apidoc.element.kafka-node.Consumer.prototype.setOffset">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>setOffset
        <span class="apidocSignatureSpan">(topic, partition, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setOffset = function (topic, partition, offset) {
  this.payloads.every(function (p) {
    if (p.topic === topic &#x26;&#x26; p.partition == partition) { // eslint-disable-line eqeqeq
      p.offset = offset;
      return false;
    }
    return true;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `partition`: **Number**

* `offset`: **Number**

Example:

``` js
consumer.<span class="apidocCodeKeywordSpan">setOffset</span>(&#x27;topic&#x27;, 0, 0);
```

### pause()
Pause the consumer. ***Calling `pause` does not automatically stop messages from being emitted.*** This is because pause just stops
 the kafka consumer fetch loop. Each iteration of the fetch loop can obtain a batch of messages (limited by `fetchMaxBytes`).

### resume()
Resume the consumer. Resumes the fetch loop.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.updateOffsets" id="apidoc.element.kafka-node.Consumer.prototype.updateOffsets">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>updateOffsets
        <span class="apidocSignatureSpan">(topics, initing)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateOffsets = function (topics, initing) {
  this.payloads.forEach(function (p) {
    if (!_.isEmpty(topics[p.topic]) &#x26;&#x26; topics[p.topic][p.partition] !== undefined) {
      var offset = topics[p.topic][p.partition];
      if (offset === -1) offset = 0;
      if (!initing) p.offset = offset + 1;
      else p.offset = offset;
    }
  });

  if (this.options.autoCommit &#x26;&#x26; !initing) {
    this.autoCommit(false, function (err) {
      err &#x26;&#x26; logger.debug(&#x27;auto commit offset&#x27;, err);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.ConsumerGroup" id="apidoc.module.kafka-node.ConsumerGroup">module kafka-node.ConsumerGroup</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.ConsumerGroup" id="apidoc.element.kafka-node.ConsumerGroup.ConsumerGroup">
        function <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup
        <span class="apidocSignatureSpan">(memberOptions, topics)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ConsumerGroup(memberOptions, topics) {
  EventEmitter.call(this);
  const self = this;
  this.options = _.defaults((memberOptions || {}), DEFAULTS);

  if (!this.options.heartbeatInterval) {
    this.options.heartbeatInterval = Math.floor(this.options.sessionTimeout / 3);
  }

  if (memberOptions.ssl === true) {
    memberOptions.ssl = {};
  }

  if (!(this.options.fromOffset in ACCEPTED_FROM_OFFSET)) {
    throw new Error(`fromOffset ${this.options.fromOffset} should be either: ${Object.keys(ACCEPTED_FROM_OFFSET).join(&#x27;, &#x27;)}`);
  }

  if (!(this.options.outOfRangeOffset in ACCEPTED_FROM_OFFSET)) {
    throw new Error(`outOfRangeOffset ${this.options.outOfRangeOffset} should be either: ${Object.keys(ACCEPTED_FROM_OFFSET).join
(&#x27;, &#x27;)}`);
  }

  this.client = new Client(memberOptions.host, memberOptions.id, memberOptions.zk,
    memberOptions.batch, memberOptions.ssl);

  if (_.isString(topics)) {
    topics = [topics];
  }

  assert(Array.isArray(topics), &#x27;Array of topics is required&#x27;);

  this.topics = topics;

  this.recovery = new ConsumerGroupRecovery(this);

  this.setupProtocols(this.options.protocol);

  if (this.options.connectOnReady &#x26;&#x26; !this.options.migrateHLC) {
    this.client.once(&#x27;ready&#x27;, this.connect.bind(this));
  }

  if (this.options.migrateHLC) {
    const ConsumerGroupMigrator = require(&#x27;./consumerGroupMigrator&#x27;);
    this.migrator = new ConsumerGroupMigrator(this);
    this.migrator.on(&#x27;error&#x27;, function (error) {
      self.emit(&#x27;error&#x27;, error);
    });
  }

  this.client.on(&#x27;error&#x27;, function (err) {
    logger.error(&#x27;Error from %s&#x27;, self.client.clientId, err);
    self.emit(&#x27;error&#x27;, err);
  });

  const recoverFromBrokerChange = _.debounce(function () {
    logger.debug(&#x27;brokersChanged refreshing metadata&#x27;);
    self.client.refreshMetadata(self.topics, function (error) {
      if (error) {
        self.emit(error);
        return;
      }
      self.paused = false;
      if (!self.ready &#x26;&#x26; !self.connecting) {
        if (self.reconnectTimer) {
          // brokers changed so bypass backoff retry and reconnect now
          clearTimeout(self.reconnectTimer);
          self.reconnectTimer = null;
        }
        self.connect();
      } else if (!self.connecting) {
        self.fetch();
      }
    });
  }, 200);

  this.client.on(&#x27;brokersChanged&#x27;, function () {
    self.pause();
    recoverFromBrokerChange();
  });

  this.client.on(&#x27;reconnect&#x27;, function (lastError) {
    self.fetch();
  });

  this.on(&#x27;offsetOutOfRange&#x27;, topic =&#x3e; {
    this.pause();
    if (this.options.outOfRangeOffset === &#x27;none&#x27;) {
      this.emit(&#x27;error&#x27;, new errors.InvalidConsumerOffsetError(`Offset out of range for topic &#x22;${topic.topic}&#x22; partition ${topic
.partition}`));
      return;
    }

    topic.time = ACCEPTED_FROM_OFFSET[this.options.outOfRangeOffset];

    this.getOffset().fetch([topic], (error, result) =&#x3e; {
      if (error) {
        this.emit(&#x27;error&#x27;, new errors.InvalidConsumerOffsetError(`Fetching ${this.options.outOfRangeOffset} offset failed`, error
));
        return;
      }
      const offset = _.head(result[topic.topic][topic.partition]);
      const oldOffset = _.find(this.topicPayloads, {topic: topic.topic, partition: topic.partition}).offset;

      logger.debug(&#x27;replacing %s-%s stale offset of %d with %d&#x27;, topic.topic, topic.partition, oldOffset, offset);

      this.setOffset(topic.topic, topic.partition, offset);
      this.resume();
    });
  });

  // &#x27;done&#x27; will be emit when a message fetch request complete
  this.on(&#x27;done&#x27;, function (topics) {
    self.updateOffsets(topics);
    if (!self.paused) {
      setImmediate(function () {
        self.fetch();
      });
    }
  });

  if (this.options.groupId) {
    validateConfig(&#x27;options.groupId&#x27;, this.options.groupId);
  }

  this.isLeader = false;
  this.coordinatorId = null;
  this.generationId = null;
  this.ready = false;
  this.topicPayloads = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.super_" id="apidoc.element.kafka-node.ConsumerGroup.super_">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.</span>super_
        <span class="apidocSignatureSpan">(client, topics, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function (client, topics, options) {
  if (!topics) {
    throw new Error(&#x27;Must have payloads&#x27;);
  }
  this.fetchCount = 0;
  this.client = client;
  this.options = _.defaults((options || {}), DEFAULTS);
  this.initialised = false;
  this.ready = false;
  this.closing = false;
  this.paused = this.options.paused;
  this.rebalancing = false;
  this.pendingRebalances = 0;
  this.committing = false;
  this.needToCommit = false;
  this.id = this.options.id || this.options.groupId + &#x27;_&#x27; + uuid.v4();
  this.payloads = this.buildPayloads(topics);
  this.topicPayloads = this.buildTopicPayloads(topics);
  this.connect();

  if (this.options.groupId) {
    validateConfig(&#x27;options.groupId&#x27;, this.options.groupId);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.ConsumerGroup.prototype" id="apidoc.module.kafka-node.ConsumerGroup.prototype">module kafka-node.ConsumerGroup.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.assignPartitions" id="apidoc.element.kafka-node.ConsumerGroup.prototype.assignPartitions">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>assignPartitions
        <span class="apidocSignatureSpan">(protocol, groupMembers, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assignPartitions = function (protocol, groupMembers, callback) {
  logger.debug(&#x27;Assigning Partitions to members&#x27;, groupMembers);
  logger.debug(&#x27;Using group protocol&#x27;, protocol);

  protocol = _.find(this.protocols, {name: protocol});

  var self = this;
  var topics = _(groupMembers).map(&#x27;subscription&#x27;).flatten().uniq().value();

  async.waterfall([
    function (callback) {
      logger.debug(&#x27;loadingMetadata for topics:&#x27;, topics);
      self.client.loadMetadataForTopics(topics, callback);
    },

    function (metadataResponse, callback) {
      var metadata = mapTopicToPartitions(metadataResponse[1].metadata);
      logger.debug(&#x27;mapTopicToPartitions&#x27;, metadata);
      protocol.assign(metadata, groupMembers, callback);
    }
  ], callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.close" id="apidoc.element.kafka-node.ConsumerGroup.prototype.close">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>close
        <span class="apidocSignatureSpan">(force, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (force, cb) {
  var self = this;
  this.ready = false;

  this.stopHeartbeats();

  if (typeof force === &#x27;function&#x27;) {
    cb = force;
    force = false;
  }

  async.series([
    function (callback) {
      if (force) {
        self.commit(true, callback);
        return;
      }
      callback(null);
    },
    function (callback) {
      self.leaveGroup(function (error) {
        if (error) {
          logger.error(&#x27;Leave group failed with&#x27;, error);
        }
        callback(null);
      });
    },
    function (callback) {
      self.client.close(callback);
    }
  ], cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### close(force, cb)
* `force`: **Boolean**, if set to true, it forces the consumer to commit the current offset before closing, default `false`

Example

```js
consumer.<span class="apidocCodeKeywordSpan">close</span>(true, cb);
consumer.close(cb); //force is disabled
```

## HighLevelConsumer
⚠️ ***This consumer has been deprecated in the latest version of Kafka (0.10.1) and is likely to be removed in the future. Please
 use the ConsumerGroup instead.***

### HighLevelConsumer(client, payloads, options)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.connect" id="apidoc.element.kafka-node.ConsumerGroup.prototype.connect">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>connect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connect = function () {
  if (this.connecting) {
    logger.warn(&#x27;Connect ignored. Currently connecting.&#x27;);
    return;
  }

  logger.debug(&#x27;Connecting %s&#x27;, this.client.clientId);
  var self = this;

  this.connecting = true;
  this.emit(&#x27;rebalancing&#x27;);

  async.waterfall([
    function (callback) {
      if (self.client.coordinatorId) {
        return callback(null, null);
      }
      self.client.sendGroupCoordinatorRequest(self.options.groupId, callback);
    },

    function (coordinatorInfo, callback) {
      logger.debug(&#x27;GroupCoordinator Response:&#x27;, coordinatorInfo);
      if (coordinatorInfo) {
        self.setCoordinatorId(coordinatorInfo.coordinatorId);
      }
      self.client.sendJoinGroupRequest(self.options.groupId, emptyStrIfNull(self.memberId), self.options.sessionTimeout, self.protocols
, callback);
    },

    function (joinGroupResponse, callback) {
      self.handleJoinGroup(joinGroupResponse, callback);
    },

    function (groupAssignment, callback) {
      logger.debug(&#x27;SyncGroup Request from %s&#x27;, self.memberId);
      self.client.sendSyncGroupRequest(self.options.groupId, self.generationId, self.memberId, groupAssignment, callback);
    },

    function (syncGroupResponse, callback) {
      self.handleSyncGroup(syncGroupResponse, callback);
    }
  ], function (error, startFetch) {
    self.connecting = false;
    self.rebalancing = false;
    if (error) {
      return self.recovery.tryToRecoverFrom(error, &#x27;connect&#x27;);
    }

    self.ready = true;
    self.recovery.clearError();

    logger.debug(&#x27;generationId&#x27;, self.generationId);

    if (startFetch) {
      self.fetch();
    }
    self.startHeartbeats();
    self.emit(&#x27;connect&#x27;);
    self.emit(&#x27;rebalanced&#x27;);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    });

    this.on(&#x27;topicOwnerChange&#x27;, _.debounce(function (topics) {
      verified = 0;
      self.checkForOwnersAndListenForChange(topics);
    }, 250));

    this.zk.<span class="apidocCodeKeywordSpan">connect</span>();
  } else {
    this.connectConsumerGroup();
  }
}

util.inherits(ConsumerGroupMigrator, EventEmitter);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.fetchOffset" id="apidoc.element.kafka-node.ConsumerGroup.prototype.fetchOffset">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>fetchOffset
        <span class="apidocSignatureSpan">(payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetchOffset = function (payloads, cb) {
  this.client.sendOffsetFetchV1Request(this.options.groupId, payloads, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.getDefaultOffset" id="apidoc.element.kafka-node.ConsumerGroup.prototype.getDefaultOffset">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>getDefaultOffset
        <span class="apidocSignatureSpan">(tp, defaultOffset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDefaultOffset = function (tp, defaultOffset) {
  return _.get(this.defaultOffsets, [tp.topic, tp.partition], defaultOffset);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.getOffset" id="apidoc.element.kafka-node.ConsumerGroup.prototype.getOffset">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>getOffset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOffset = function () {
  if (this.offset) {
    return this.offset;
  }
  this.offset = new Offset(this.client);
  // we can ignore this since we are already forwarding error event emitted from client
  this.offset.on(&#x27;error&#x27;, _.noop);
  return this.offset;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.handleJoinGroup" id="apidoc.element.kafka-node.ConsumerGroup.prototype.handleJoinGroup">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>handleJoinGroup
        <span class="apidocSignatureSpan">(joinGroupResponse, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleJoinGroup = function (joinGroupResponse, callback) {
  logger.debug(&#x27;joinGroupResponse %j from %s&#x27;, joinGroupResponse, this.client.clientId);

  this.isLeader = (joinGroupResponse.leaderId === joinGroupResponse.memberId);
  this.generationId = joinGroupResponse.generationId;
  this.memberId = joinGroupResponse.memberId;

  var groupAssignment;
  if (this.isLeader) {
    // assign partitions
    return this.assignPartitions(joinGroupResponse.groupProtocol, joinGroupResponse.members, callback);
  }
  callback(null, groupAssignment);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.handleSyncGroup" id="apidoc.element.kafka-node.ConsumerGroup.prototype.handleSyncGroup">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>handleSyncGroup
        <span class="apidocSignatureSpan">(syncGroupResponse, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleSyncGroup = function (syncGroupResponse, callback) {
  logger.debug(&#x27;SyncGroup Response&#x27;);
  var self = this;
  var ownedTopics = Object.keys(syncGroupResponse.partitions);
  if (ownedTopics.length) {
    logger.debug(&#x27;%s owns topics: &#x27;, self.client.clientId, syncGroupResponse.partitions);

    const topicPartitionList = createTopicPartitionList(syncGroupResponse.partitions);
    const useDefaultOffsets = self.options.fromOffset in ACCEPTED_FROM_OFFSET;

    async.waterfall([
      function (callback) {
        self.fetchOffset(syncGroupResponse.partitions, callback);
      },
      function (offsets, callback) {
        logger.debug(&#x27;%s fetchOffset Response: %j&#x27;, self.client.clientId, offsets);

        var noOffset = topicPartitionList.some(function (tp) {
          return offsets[tp.topic][tp.partition] === -1;
        });

        if (noOffset) {
          logger.debug(&#x27;No saved offsets&#x27;);

          if (self.options.fromOffset === &#x27;none&#x27;) {
            return callback(new Error(`${self.client.clientId} owns topics and partitions which contains no saved offsets for group
 &#x27;${self.options.groupId}&#x27;`));
          }

          async.parallel([
            function (callback) {
              if (self.migrator) {
                return self.migrator.saveHighLevelConsumerOffsets(topicPartitionList, callback);
              }
              callback(null);
            },
            function (callback) {
              if (useDefaultOffsets) {
                return self.saveDefaultOffsets(topicPartitionList, callback);
              }
              callback(null);
            }
          ], function (error) {
            if (error) {
              return callback(error);
            }
            logger.debug(&#x27;%s defaultOffset Response for %s: %j&#x27;, self.client.clientId, self.options.fromOffset, self.defaultOffsets
);
            callback(null, offsets);
          });
        } else {
          logger.debug(&#x27;Has saved offsets&#x27;);
          callback(null, offsets);
        }
      },
      function (offsets, callback) {
        self.topicPayloads = self.buildPayloads(topicPartitionList).map(function (p) {
          var offset = offsets[p.topic][p.partition];
          if (offset === -1) { // -1 means no offset was saved for this topic/partition combo
            offset = useDefaultOffsets ? self.getDefaultOffset(p, 0) : 0;
            if (self.migrator) {
              offset = self.migrator.getOffset(p, offset);
            }
          }
          p.offset = offset;
          return p;
        });
        callback(null, true);
      }
    ], callback);
  } else { // no partitions assigned
    callback(null, false);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.leaveGroup" id="apidoc.element.kafka-node.ConsumerGroup.prototype.leaveGroup">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>leaveGroup
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">leaveGroup = function (callback) {
  logger.debug(&#x27;%s leaving group&#x27;, this.client.clientId);
  var self = this;
  this.stopHeartbeats();
  if (self.generationId != null &#x26;&#x26; self.memberId) {
    this.client.sendLeaveGroupRequest(this.options.groupId, this.memberId, function (error) {
      self.generationId = null;
      callback(error);
    });
  } else {
    callback(null);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.saveDefaultOffsets" id="apidoc.element.kafka-node.ConsumerGroup.prototype.saveDefaultOffsets">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>saveDefaultOffsets
        <span class="apidocSignatureSpan">(topicPartitionList, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">saveDefaultOffsets = function (topicPartitionList, callback) {
  var self = this;
  const offsetPayload = _(topicPartitionList).cloneDeep().map(tp =&#x3e; {
    tp.time = ACCEPTED_FROM_OFFSET[this.options.fromOffset];
    return tp;
  });

  self.getOffset().fetch(offsetPayload, function (error, result) {
    if (error) {
      return callback(error);
    }
    self.defaultOffsets = _.mapValues(result, function (partitionOffsets) {
      return _.mapValues(partitionOffsets, _.head);
    });
    callback(null);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.scheduleReconnect" id="apidoc.element.kafka-node.ConsumerGroup.prototype.scheduleReconnect">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>scheduleReconnect
        <span class="apidocSignatureSpan">(timeout)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scheduleReconnect = function (timeout) {
  assert(timeout);
  this.rebalancing = true;

  if (this.reconnectTimer) {
    clearTimeout(this.reconnectTimer);
  }

  var self = this;
  this.reconnectTimer = setTimeout(function () {
    self.reconnectTimer = null;
    self.connect();
  }, timeout);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  if (retry) {
    retryTimeout = this.getRetryTimeout(error);
  }

  if (retry &#x26;&#x26; retryTimeout) {
    logger.debug(&#x27;RECOVERY from %s: %s retrying in %s ms&#x27;, source, this.consumerGroup.client.clientId, retryTimeout, error
);
    this.consumerGroup.<span class="apidocCodeKeywordSpan">scheduleReconnect</span>(retryTimeout);
  } else {
    this.consumerGroup.emit(&#x27;error&#x27;, error);
  }
  this.lastError = error;
};

ConsumerGroupRecovery.prototype.clearError = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.sendHeartbeat" id="apidoc.element.kafka-node.ConsumerGroup.prototype.sendHeartbeat">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>sendHeartbeat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendHeartbeat = function () {
  assert(this.memberId, &#x27;invalid memberId&#x27;);
  assert(this.generationId &#x3e;= 0, &#x27;invalid generationId&#x27;);
  // logger.debug(&#x27;%s ❤️  -&#x3e;&#x27;, this.client.clientId);
  var self = this;

  function heartbeatCallback (error) {
    if (error) {
      logger.warn(&#x27;%s Heartbeat error:&#x27;, self.client.clientId, error);
      self.recovery.tryToRecoverFrom(error, &#x27;heartbeat&#x27;);
    }
    // logger.debug(&#x27;%s 💚 &#x3c;-&#x27;, self.client.clientId, error);
  }

  const heartbeat = new Heartbeat(this.client, heartbeatCallback);
  heartbeat.send(this.options.groupId, this.generationId, this.memberId);

  return heartbeat;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.sendOffsetCommitRequest" id="apidoc.element.kafka-node.ConsumerGroup.prototype.sendOffsetCommitRequest">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>sendOffsetCommitRequest
        <span class="apidocSignatureSpan">(commits, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendOffsetCommitRequest = function (commits, cb) {
  if (this.generationId &#x26;&#x26; this.memberId) {
    this.client.sendOffsetCommitV2Request(this.options.groupId, this.generationId, this.memberId, commits, cb);
  } else {
    cb(null, &#x27;Nothing to be committed&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.setCoordinatorId" id="apidoc.element.kafka-node.ConsumerGroup.prototype.setCoordinatorId">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>setCoordinatorId
        <span class="apidocSignatureSpan">(coordinatorId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setCoordinatorId = function (coordinatorId) {
  this.client.coordinatorId = String(coordinatorId);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.setupProtocols" id="apidoc.element.kafka-node.ConsumerGroup.prototype.setupProtocols">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>setupProtocols
        <span class="apidocSignatureSpan">(protocols)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setupProtocols = function (protocols) {
  if (!Array.isArray(protocols)) {
    protocols = [protocols];
  }

  this.protocols = protocols.map(function (protocol) {
    if (typeof protocol === &#x27;string&#x27;) {
      if (!(protocol in builtInProtocols)) {
        throw new Error(&#x27;Unknown built in assignment protocol &#x27; + protocol);
      }
      protocol = _.assign({}, builtInProtocols[protocol]);
    } else {
      checkProtocol(protocol);
    }

    protocol.subscription = this.topics;
    return protocol;
  }, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.startHeartbeats" id="apidoc.element.kafka-node.ConsumerGroup.prototype.startHeartbeats">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>startHeartbeats
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">startHeartbeats = function () {
  assert(this.options.sessionTimeout &#x3e; 0);
  assert(this.ready, &#x27;consumerGroup is not ready&#x27;);

  const heartbeatIntervalMs = this.options.heartbeatInterval || (Math.floor(this.options.sessionTimeout / 3));

  logger.debug(&#x27;%s started heartbeats at every %d ms&#x27;, this.client.clientId, heartbeatIntervalMs);
  this.stopHeartbeats();

  let heartbeat = this.sendHeartbeat();

  this.heartbeatInterval = setInterval(() =&#x3e; {
    // only send another heartbeat if we got a response from the last one
    if (heartbeat.verifyResolved()) {
      heartbeat = this.sendHeartbeat();
    }
  }, heartbeatIntervalMs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.stopHeartbeats" id="apidoc.element.kafka-node.ConsumerGroup.prototype.stopHeartbeats">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>stopHeartbeats
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stopHeartbeats = function () {
  this.heartbeatInterval &#x26;&#x26; clearInterval(this.heartbeatInterval);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function ConsumerGroupRecovery (consumerGroup) {
this.consumerGroup = consumerGroup;
this.options = consumerGroup.options;
}

ConsumerGroupRecovery.prototype.tryToRecoverFrom = function (error, source) {
this.consumerGroup.ready = false;
this.consumerGroup.<span class="apidocCodeKeywordSpan">stopHeartbeats</span>();

var retryTimeout = false;
var retry = recoverableErrors.some(function (recoverableItem) {
  if (isErrorInstanceOf(error, recoverableItem.errors)) {
    recoverableItem.handler &#x26;&#x26; recoverableItem.handler.call(this.consumerGroup, error);
    return true;
  }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.CustomPartitioner" id="apidoc.module.kafka-node.CustomPartitioner">module kafka-node.CustomPartitioner</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.CustomPartitioner.CustomPartitioner" id="apidoc.element.kafka-node.CustomPartitioner.CustomPartitioner">
        function <span class="apidocSignatureSpan">kafka-node.</span>CustomPartitioner
        <span class="apidocSignatureSpan">(partitioner)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CustomPartitioner = function (partitioner) {
  this.getPartition = partitioner;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.CustomPartitioner.super_" id="apidoc.element.kafka-node.CustomPartitioner.super_">
        function <span class="apidocSignatureSpan">kafka-node.CustomPartitioner.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.CyclicPartitioner" id="apidoc.module.kafka-node.CyclicPartitioner">module kafka-node.CyclicPartitioner</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.CyclicPartitioner.CyclicPartitioner" id="apidoc.element.kafka-node.CyclicPartitioner.CyclicPartitioner">
        function <span class="apidocSignatureSpan">kafka-node.</span>CyclicPartitioner
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CyclicPartitioner = function () {
  this.c = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.CyclicPartitioner.super_" id="apidoc.element.kafka-node.CyclicPartitioner.super_">
        function <span class="apidocSignatureSpan">kafka-node.CyclicPartitioner.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.CyclicPartitioner.prototype" id="apidoc.module.kafka-node.CyclicPartitioner.prototype">module kafka-node.CyclicPartitioner.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.CyclicPartitioner.prototype.getPartition" id="apidoc.element.kafka-node.CyclicPartitioner.prototype.getPartition">
        function <span class="apidocSignatureSpan">kafka-node.CyclicPartitioner.prototype.</span>getPartition
        <span class="apidocSignatureSpan">(partitions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPartition = function (partitions) {
  if (_.isEmpty(partitions)) return 0;
  return partitions[ this.c++ % partitions.length ];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.DefaultPartitioner" id="apidoc.module.kafka-node.DefaultPartitioner">module kafka-node.DefaultPartitioner</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.DefaultPartitioner.DefaultPartitioner" id="apidoc.element.kafka-node.DefaultPartitioner.DefaultPartitioner">
        function <span class="apidocSignatureSpan">kafka-node.</span>DefaultPartitioner
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">DefaultPartitioner = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.DefaultPartitioner.super_" id="apidoc.element.kafka-node.DefaultPartitioner.super_">
        function <span class="apidocSignatureSpan">kafka-node.DefaultPartitioner.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.DefaultPartitioner.prototype" id="apidoc.module.kafka-node.DefaultPartitioner.prototype">module kafka-node.DefaultPartitioner.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.DefaultPartitioner.prototype.getPartition" id="apidoc.element.kafka-node.DefaultPartitioner.prototype.getPartition">
        function <span class="apidocSignatureSpan">kafka-node.DefaultPartitioner.prototype.</span>getPartition
        <span class="apidocSignatureSpan">(partitions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPartition = function (partitions) {
  if (partitions &#x26;&#x26; _.isArray(partitions) &#x26;&#x26; partitions.length &#x3e; 0) {
    return partitions[0];
  } else {
    return 0;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.HighLevelConsumer" id="apidoc.module.kafka-node.HighLevelConsumer">module kafka-node.HighLevelConsumer</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.HighLevelConsumer" id="apidoc.element.kafka-node.HighLevelConsumer.HighLevelConsumer">
        function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer
        <span class="apidocSignatureSpan">(client, topics, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">HighLevelConsumer = function (client, topics, options) {
  if (!topics) {
    throw new Error(&#x27;Must have payloads&#x27;);
  }
  this.fetchCount = 0;
  this.client = client;
  this.options = _.defaults((options || {}), DEFAULTS);
  this.initialised = false;
  this.ready = false;
  this.closing = false;
  this.paused = this.options.paused;
  this.rebalancing = false;
  this.pendingRebalances = 0;
  this.committing = false;
  this.needToCommit = false;
  this.id = this.options.id || this.options.groupId + &#x27;_&#x27; + uuid.v4();
  this.payloads = this.buildPayloads(topics);
  this.topicPayloads = this.buildTopicPayloads(topics);
  this.connect();

  if (this.options.groupId) {
    validateConfig(&#x27;options.groupId&#x27;, this.options.groupId);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.super_" id="apidoc.element.kafka-node.HighLevelConsumer.super_">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype" id="apidoc.module.kafka-node.HighLevelConsumer.prototype">module kafka-node.HighLevelConsumer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype._releasePartitions" id="apidoc.element.kafka-node.HighLevelConsumer.prototype._releasePartitions">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>_releasePartitions
        <span class="apidocSignatureSpan">(topicPayloads, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_releasePartitions = function (topicPayloads, callback) {
  var self = this;
  async.each(topicPayloads, function (tp, cbb) {
    if (tp.partition !== undefined) {
      async.series([
        function (delcbb) {
          self.client.zk.checkPartitionOwnership(self.id, self.options.groupId, tp.topic, tp.partition, function (err) {
            if (err) {
              // Partition doesn&#x27;t exist simply carry on
              cbb();
            } else delcbb();
          });
        },
        function (delcbb) {
          self.client.zk.deletePartitionOwnership(self.options.groupId, tp.topic, tp.partition, delcbb);
        },
        function (delcbb) {
          self.client.zk.checkPartitionOwnership(self.id, self.options.groupId, tp.topic, tp.partition, function (err) {
            if (err) {
              delcbb();
            } else {
              delcbb(&#x27;Partition should not exist&#x27;);
            }
          });
        }],
      cbb);
    } else {
      cbb();
    }
  }, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.addTopics" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.addTopics">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>addTopics
        <span class="apidocSignatureSpan">(topics, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addTopics = function (topics, cb) {
  var self = this;
  if (!this.ready) {
    setTimeout(function () {
      self.addTopics(topics, cb);
    }, 100);
    return;
  }
  this.client.addTopics(
    topics,
    function (err, added) {
      if (err) return cb &#x26;&#x26; cb(err, added);

      var payloads = self.buildPayloads(topics);
      // update offset of topics that will be added
      self.fetchOffset(payloads, function (err, offsets) {
        if (err) return cb(err);
        payloads.forEach(function (p) {
          var offset = offsets[p.topic][p.partition];
          if (offset === -1) offset = 0;
          p.offset = offset;
          self.topicPayloads.push(p);
        });
        // TODO: rebalance consumer
        cb &#x26;&#x26; cb(null, added);
      });
    }
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `topics`: **Array**, array of topics to add
* `cb`: **Function**,the callback
* `fromOffset`: **Boolean**, if true, the consumer will fetch message from the specified offset, otherwise it will fetch message
 from the last commited offset of the topic.

Example:

``` js
consumer.<span class="apidocCodeKeywordSpan">addTopics</span>([&#x27;t1&#x27;, &#x27;t2&#x27;], function (err, added) {
});

or

consumer.addTopics([{ topic: &#x27;t1&#x27;, offset: 10 }], function (err, added) {
}, true);
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.autoCommit" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.autoCommit">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>autoCommit
        <span class="apidocSignatureSpan">(force, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function autoCommit(force, cb) {
  if (arguments.length === 1) {
    cb = force;
    force = false;
  }

  if (!force) {
    if (this.committing) return cb(null, &#x27;Offset committing&#x27;);
    if (!this.needToCommit) return cb(null, &#x27;Commit not needed&#x27;);
  }

  this.needToCommit = false;
  this.committing = true;
  setTimeout(function () {
    this.committing = false;
  }.bind(this), this.options.autoCommitIntervalMs);

  var commits = this.topicPayloads.filter(function (p) { return p.offset !== -1; });

  if (commits.length) {
    this.sendOffsetCommitRequest(commits, cb);
  } else {
    cb(null, &#x27;Nothing to be committed&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.buildPayloads" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.buildPayloads">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>buildPayloads
        <span class="apidocSignatureSpan">(payloads)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildPayloads = function (payloads) {
  var self = this;
  return payloads.map(function (p) {
    if (typeof p !== &#x27;object&#x27;) p = { topic: p };
    p.partition = p.partition || 0;
    p.offset = p.offset || 0;
    p.maxBytes = self.options.fetchMaxBytes;
    p.metadata = &#x27;m&#x27;; // metadata can be arbitrary
    return p;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.buildTopicPayloads" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.buildTopicPayloads">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>buildTopicPayloads
        <span class="apidocSignatureSpan">(topics)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildTopicPayloads = function (topics) {
  return topics.map(function (j) {
    var k = { topic: j.topic };
    return k;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.close" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.close">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>close
        <span class="apidocSignatureSpan">(force, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (force, cb) {
  var self = this;
  this.ready = false;
  this.closing = true;
  clearInterval(this.checkPartitionOwnershipInterval);

  if (typeof force === &#x27;function&#x27;) {
    cb = force;
    force = false;
  }

  async.series([
    function (callback) {
      self.leaveGroup(callback);
    },
    function (callback) {
      if (force) {
        async.series([
          function (callback) {
            self.commit(true, callback);
          },
          function (callback) {
            self.client.close(callback);
          }
        ], callback);
        return;
      }
      self.client.close(callback);
    }
  ], cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### close(force, cb)
* `force`: **Boolean**, if set to true, it forces the consumer to commit the current offset before closing, default `false`

Example

```js
consumer.<span class="apidocCodeKeywordSpan">close</span>(true, cb);
consumer.close(cb); //force is disabled
```

## HighLevelConsumer
⚠️ ***This consumer has been deprecated in the latest version of Kafka (0.10.1) and is likely to be removed in the future. Please
 use the ConsumerGroup instead.***

### HighLevelConsumer(client, payloads, options)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.commit" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.commit">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>commit
        <span class="apidocSignatureSpan">(force, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function autoCommit(force, cb) {
  if (arguments.length === 1) {
    cb = force;
    force = false;
  }

  if (!force) {
    if (this.committing) return cb(null, &#x27;Offset committing&#x27;);
    if (!this.needToCommit) return cb(null, &#x27;Commit not needed&#x27;);
  }

  this.needToCommit = false;
  this.committing = true;
  setTimeout(function () {
    this.committing = false;
  }.bind(this), this.options.autoCommitIntervalMs);

  var commits = this.topicPayloads.filter(function (p) { return p.offset !== -1; });

  if (commits.length) {
    this.sendOffsetCommitRequest(commits, cb);
  } else {
    cb(null, &#x27;Nothing to be committed&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Commit offset of the current topics manually, this method should be called when a consumer leaves

* `cb`: **Function**, the callback

Example:

``` js
consumer.<span class="apidocCodeKeywordSpan">commit</span>(function(err, data) {
});
```

### setOffset(topic, partition, offset)
Set offset of the given topic

* `topic`: **String**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.connect" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.connect">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>connect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connect = function () {
  var self = this;
  // Client alreadyexists
  if (this.client.ready) {
    this.init();
  }

  this.client.on(&#x27;ready&#x27;, function () {
    if (!self.initialised) self.init();

    // Check the topics exist and create a watcher on them
    var topics = self.payloads.map(function (p) {
      return p.topic;
    });

    self.client.topicExists(topics, function (err) {
      if (err) {
        return self.emit(&#x27;error&#x27;, err);
      }
      self.initialised = true;
    });
  });

  function checkPartitionOwnership (callback) {
    async.each(self.topicPayloads, function (tp, cbb) {
      if (tp.partition !== undefined) {
        self.client.zk.checkPartitionOwnership(self.id, self.options.groupId, tp.topic, tp.partition, function (err) {
          if (err) {
            cbb(err);
          } else {
            cbb();
          }
        });
      } else {
        cbb();
      }
    }, callback);
  }

  // Check partition ownership and registration
  this.checkPartitionOwnershipInterval = setInterval(function () {
    if (!self.rebalancing) {
      async.parallel([
        checkPartitionOwnership,
        function (callback) {
          self.client.zk.isConsumerRegistered(self.options.groupId, self.id, function (error, registered) {
            if (error) {
              return callback(error);
            }
            if (registered) {
              callback();
            } else {
              callback(new Error(util.format(&#x27;Consumer %s is not registered in group %s&#x27;, self.id, self.options.groupId)));
            }
          });
        }
      ], function (error) {
        if (error) {
          self.emit(&#x27;error&#x27;, new errors.FailedToRegisterConsumerError(error.toString(), error));
        }
      });
    }
  }, 20000);

  function fetchAndUpdateOffsets (cb) {
    self.fetchOffset(self.topicPayloads, function (err, topics) {
      if (err) {
        return cb(err);
      }

      self.ready = true;
      self.updateOffsets(topics, true);

      return cb();
    });
  }

  function rebalance () {
    logger.debug(&#x27;rebalance() %s is rebalancing: %s ready: %s&#x27;, self.id, self.rebalancing, self.ready);
    if (!self.rebalancing &#x26;&#x26; !self.closing) {
      deregister();

      self.emit(&#x27;rebalancing&#x27;);

      self.rebalancing = true;
      logger.debug(&#x27;HighLevelConsumer rebalance retry config: %s&#x27;, JSON.stringify(self.options.rebalanceRetry));
      var oldTopicPayloads = self.topicPayloads;
      var operation = retry.operation(self.options.rebalanceRetry);

      operation.attempt(function (currentAttempt) {
        self.rebalanceAttempt(oldTopicPayloads, function (err) {
          if (operation.retry(err)) {
            return;
          }
          if (err) {
            self.rebalancing = false;
            return self.emit(&#x27;error&#x27;, new errors.FailedToRebalanceConsumerError(operation.mainError().toString()));
          } else {
            var topicNames = self.topicPayloads.map(function (p) {
              return p.topic;
            });
            self.client.refreshMetadata(topicNames, function (err) {
              register();
              if (err) {
                self.rebalancing = false;
                self.emit(&#x27;error&#x27;, err);
                return;
              }

              if (self.topicPayloads.length) {
                fetchAndUpdateOffsets(function (err) {
                  self.rebalancing = false;
                  if (err) {
                    self.emit(&#x27;error&#x27;, new errors.FailedToRebalanceConsumerError(err.message));
                    return;
                  }
                  self.fetch();
                  self.emit(&#x27;rebalanced&#x27;);
                });
              } else { // was not assigned any partitions during rebalance
                self.rebalancing = false;
                self.emit(&#x27;rebalanced&#x27;);
              }
            });
          }
        });
      });
    }
  }

  // Wait for the consumer to be ready
  this.on(&#x27;registered&#x27;, rebalance);

  function register (fn) {
    logger.debug(&#x27;Registered listeners %s&#x27;, self.id);
    self.client.zk.on(&#x27;consumersChanged&#x27;, fn ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    });

    this.on(&#x27;topicOwnerChange&#x27;, _.debounce(function (topics) {
      verified = 0;
      self.checkForOwnersAndListenForChange(topics);
    }, 250));

    this.zk.<span class="apidocCodeKeywordSpan">connect</span>();
  } else {
    this.connectConsumerGroup();
  }
}

util.inherits(ConsumerGroupMigrator, EventEmitter);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.fetch" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.fetch">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>fetch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetch = function () {
  if (!this.ready || this.rebalancing || this.paused) {
    return;
  }

  this.client.sendFetchRequest(this, this.topicPayloads, this.options.fetchMaxWaitMs, this.options.fetchMinBytes, this.options.maxTickMessages
);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Example

```js
var kafka = require(&#x27;kafka-node&#x27;),
    client = new kafka.Client(),
    offset = new kafka.Offset(client);
    offset.<span class="apidocCodeKeywordSpan">fetch</span>([
        { topic: &#x27;t&#x27;, partition: 0, time: Date.now(), maxNum: 1 }
    ], function (err, data) {
        // data
        // { &#x27;t&#x27;: { &#x27;0&#x27;: [999] } }
    });
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.fetchOffset" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.fetchOffset">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>fetchOffset
        <span class="apidocSignatureSpan">(payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetchOffset = function (payloads, cb) {
  logger.debug(&#x27;in fetchOffset %s payloads: %j&#x27;, this.id, payloads);
  this.client.sendOffsetFetchRequest(this.options.groupId, payloads, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.getTopicPayloads" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.getTopicPayloads">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>getTopicPayloads
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTopicPayloads = function () {
  if (!this.rebalancing) return this.topicPayloads;
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.init" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.init">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>init
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init = function () {
  var self = this;

  if (!self.topicPayloads.length) {
    return;
  }

  self.registerConsumer(function (err) {
    if (err) {
      return self.emit(&#x27;error&#x27;, new errors.FailedToRegisterConsumerError(err.toString()));
    }

    // Close the
    return self.emit(&#x27;registered&#x27;);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.leaveGroup" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.leaveGroup">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>leaveGroup
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">leaveGroup = function (cb) {
  var self = this;
  async.parallel([
    function (callback) {
      if (self.topicPayloads.length) {
        self._releasePartitions(self.topicPayloads, callback);
      } else {
        callback(null);
      }
    },
    function (callback) {
      self.client.zk.unregisterConsumer(self.options.groupId, self.id, callback);
    }
  ], cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.offsetRequest" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.offsetRequest">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>offsetRequest
        <span class="apidocSignatureSpan">(payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">offsetRequest = function (payloads, cb) {
  this.client.sendOffsetRequest(payloads, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.pause" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.pause">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>pause
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pause = function () {
  this.paused = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.rebalanceAttempt" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.rebalanceAttempt">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>rebalanceAttempt
        <span class="apidocSignatureSpan">(oldTopicPayloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rebalanceAttempt = function (oldTopicPayloads, cb) {
  var self = this;
  // Do the rebalance.....
  var consumerPerTopicMap;
  var newTopicPayloads = [];
  logger.debug(&#x27;HighLevelConsumer %s is attempting to rebalance&#x27;, self.id);
  async.series([

    // Stop fetching data and commit offsets
    function (callback) {
      logger.debug(&#x27;HighLevelConsumer %s stopping data read during rebalance&#x27;, self.id);
      self.stop(function () {
        callback();
      });
    },

    // Assemble the data
    function (callback) {
      logger.debug(&#x27;HighLevelConsumer %s assembling data for rebalance&#x27;, self.id);
      self.client.zk.getConsumersPerTopic(self.options.groupId, function (err, obj) {
        if (err) {
          callback(err);
        } else {
          consumerPerTopicMap = obj;
          callback();
        }
      });
    },

    // Release current partitions
    function (callback) {
      logger.debug(&#x27;HighLevelConsumer %s releasing current partitions during rebalance&#x27;, self.id);
      self._releasePartitions(oldTopicPayloads, callback);
    },

    // Rebalance
    function (callback) {
      logger.debug(&#x27;HighLevelConsumer %s determining the partitions to own during rebalance&#x27;, self.id);
      logger.debug(&#x27;consumerPerTopicMap.consumerTopicMap %j&#x27;, consumerPerTopicMap.consumerTopicMap);
      for (var topic in consumerPerTopicMap.consumerTopicMap[self.id]) {
        if (!consumerPerTopicMap.consumerTopicMap[self.id].hasOwnProperty(topic)) {
          continue;
        }
        var topicToAdd = consumerPerTopicMap.consumerTopicMap[self.id][topic];
        var numberOfConsumers = consumerPerTopicMap.topicConsumerMap[topicToAdd].length;
        var numberOfPartition = consumerPerTopicMap.topicPartitionMap[topicToAdd].length;
        var partitionsPerConsumer = Math.floor(numberOfPartition / numberOfConsumers);
        var extraPartitions = numberOfPartition % numberOfConsumers;
        var currentConsumerIndex;
        for (var index in consumerPerTopicMap.topicConsumerMap[topicToAdd]) {
          if (!consumerPerTopicMap.topicConsumerMap[topicToAdd].hasOwnProperty(index)) {
            continue;
          }
          if (consumerPerTopicMap.topicConsumerMap[topicToAdd][index] === self.id) {
            currentConsumerIndex = parseInt(index);
            break;
          }
        }
        var extraBit = currentConsumerIndex;
        if (currentConsumerIndex &#x3e; extraPartitions) extraBit = extraPartitions;
        var startPart = partitionsPerConsumer * currentConsumerIndex + extraBit;
        var extraNParts = 1;
        if (currentConsumerIndex + 1 &#x3e; extraPartitions) extraNParts = 0;
        var nParts = partitionsPerConsumer + extraNParts;

        for (var i = startPart; i &#x3c; startPart + nParts; i++) {
          newTopicPayloads.push({
            topic: topicToAdd,
            partition: consumerPerTopicMap.topicPartitionMap[topicToAdd][i],
            offset: 0,
            maxBytes: self.options.fetchMaxBytes,
            metadata: &#x27;m&#x27;
          });
        }
      }
      logger.debug(&#x27;newTopicPayloads %j&#x27;, newTopicPayloads);
      callback();
    },

    // Update ZK with new ownership
    function (callback) {
      if (newTopicPayloads.length) {
        logger.debug(&#x27;HighLevelConsumer %s gaining ownership of partitions during rebalance&#x27;, self.id);
        async.eachSeries(newTopicPayloads, function (tp, cbb) {
          if (tp.partition !== undefined) {
            async.series([
              function (addcbb) {
                self.client.zk.checkPartitionOwnership(self.id, self.options.groupId, tp.topic, tp.partition, function (err) {
                  if (err) {
                    // Partition doesn&#x27;t exist simply carry on
                    addcbb();
                  } else cbb(); // Partition exists simply carry on
                });
              },
              function (addcbb) {
                self.client.zk.addPartitionOwnership(self.id, self.options.groupId, tp.topic, tp.partition, function (err) {
                  if (err) {
                    addcbb(err);
                  } else addcbb(); ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.registerConsumer" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.registerConsumer">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>registerConsumer
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerConsumer = function (cb) {
  var self = this;
  var groupId = this.options.groupId;
  this.client.zk.registerConsumer(groupId, this.id, this.payloads, function (err) {
    if (err) return cb(err);
    self.client.zk.listConsumers(self.options.groupId);
    var topics = self.topicPayloads.reduce(function (ret, topicPayload) {
      if (ret.indexOf(topicPayload.topic) === -1) {
        ret.push(topicPayload.topic);
      }
      return ret;
    }, []);
    topics.forEach(function (topic) {
      self.client.zk.listPartitions(topic);
    });
    cb();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.removeTopics" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.removeTopics">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>removeTopics
        <span class="apidocSignatureSpan">(topics, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeTopics = function (topics, cb) {
  topics = typeof topics === &#x27;string&#x27; ? [topics] : topics;
  this.payloads = this.payloads.filter(function (p) {
    return !~topics.indexOf(p.topic);
  });

  this.client.removeTopicMetadata(topics, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### removeTopics(topics, cb)
* `topics`: **Array**, array of topics to remove
* `cb`: **Function**, the callback

Example:

``` js
consumer.<span class="apidocCodeKeywordSpan">removeTopics</span>([&#x27;t1&#x27;, &#x27;t2&#x27;], function (err, removed) {
});
```

### commit(cb)
Commit offset of the current topics manually, this method should be called when a consumer leaves

* `cb`: **Function**, the callback
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.resume" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.resume">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>resume
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resume = function () {
  this.paused = false;
  this.fetch();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.sendOffsetCommitRequest" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.sendOffsetCommitRequest">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>sendOffsetCommitRequest
        <span class="apidocSignatureSpan">(commits, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendOffsetCommitRequest = function (commits, cb) {
  this.client.sendOffsetCommitRequest(this.options.groupId, commits, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.setOffset" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.setOffset">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>setOffset
        <span class="apidocSignatureSpan">(topic, partition, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setOffset = function (topic, partition, offset) {
  this.topicPayloads.every(function (p) {
    if (p.topic === topic &#x26;&#x26; p.partition == partition) { // eslint-disable-line eqeqeq
      p.offset = offset;
      return false;
    }
    return true;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `partition`: **Number**

* `offset`: **Number**

Example:

``` js
consumer.<span class="apidocCodeKeywordSpan">setOffset</span>(&#x27;topic&#x27;, 0, 0);
```

### pause()
Pause the consumer. ***Calling `pause` does not automatically stop messages from being emitted.*** This is because pause just stops
 the kafka consumer fetch loop. Each iteration of the fetch loop can obtain a batch of messages (limited by `fetchMaxBytes`).

### resume()
Resume the consumer. Resumes the fetch loop.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.stop" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.stop">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>stop
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stop = function (cb) {
  if (!this.options.autoCommit) return cb &#x26;&#x26; cb();
  this.commit(true, function (err) {
    cb &#x26;&#x26; cb(err);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.updateOffsets" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.updateOffsets">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>updateOffsets
        <span class="apidocSignatureSpan">(topics, initing)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateOffsets = function (topics, initing) {
  this.topicPayloads.forEach(p =&#x3e; {
    if (!_.isEmpty(topics[p.topic]) &#x26;&#x26; topics[p.topic][p.partition] !== undefined) {
      var offset = topics[p.topic][p.partition];
      if (offset === -1) offset = 0;
      if (!initing) p.offset = offset + 1;
      else p.offset = offset;
      this.needToCommit = true;
    }
  });

  if (this.options.autoCommit &#x26;&#x26; !initing) {
    this.autoCommit(false, function (err) {
      err &#x26;&#x26; logger.debug(&#x27;auto commit offset&#x27;, err);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.HighLevelProducer" id="apidoc.module.kafka-node.HighLevelProducer">module kafka-node.HighLevelProducer</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelProducer.HighLevelProducer" id="apidoc.element.kafka-node.HighLevelProducer.HighLevelProducer">
        function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelProducer
        <span class="apidocSignatureSpan">(client, options, customPartitioner)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HighLevelProducer(client, options, customPartitioner) {
  BaseProducer.call(this, client, options, BaseProducer.PARTITIONER_TYPES.cyclic, customPartitioner);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelProducer.super_" id="apidoc.element.kafka-node.HighLevelProducer.super_">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.</span>super_
        <span class="apidocSignatureSpan">(client, options, defaultPartitionerType, customPartitioner)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BaseProducer(client, options, defaultPartitionerType, customPartitioner) {
  options = options || {};

  this.ready = false;
  this.client = client;

  this.requireAcks = options.requireAcks === undefined
    ? DEFAULTS.requireAcks
    : options.requireAcks;
  this.ackTimeoutMs = options.ackTimeoutMs === undefined
    ? DEFAULTS.ackTimeoutMs
    : options.ackTimeoutMs;

  if (customPartitioner !== undefined &#x26;&#x26; options.partitionerType !== PARTITIONER_TYPES.custom) {
    throw new Error(&#x27;Partitioner Type must be custom if providing a customPartitioner.&#x27;);
  } else if (customPartitioner === undefined &#x26;&#x26; options.partitionerType === PARTITIONER_TYPES.custom) {
    throw new Error(&#x27;No customer partitioner defined&#x27;);
  }

  var partitionerType = PARTITIONER_MAP[options.partitionerType] || PARTITIONER_MAP[defaultPartitionerType];

  // eslint-disable-next-line
  this.partitioner = new partitionerType(customPartitioner);

  this.connect();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.HighLevelProducer.super_" id="apidoc.module.kafka-node.HighLevelProducer.super_">module kafka-node.HighLevelProducer.super_</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelProducer.super_.super_" id="apidoc.element.kafka-node.HighLevelProducer.super_.super_">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.HighLevelProducer.super_.prototype" id="apidoc.module.kafka-node.HighLevelProducer.super_.prototype">module kafka-node.HighLevelProducer.super_.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.buildPayloads" id="apidoc.element.kafka-node.HighLevelProducer.super_.prototype.buildPayloads">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.super_.prototype.</span>buildPayloads
        <span class="apidocSignatureSpan">(payloads, topicMetadata)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildPayloads = function (payloads, topicMetadata) {
  const topicPartitionRequests = Object.create(null);
  payloads.forEach((p) =&#x3e; {
    p.partition = p.hasOwnProperty(&#x27;partition&#x27;) ? p.partition : this.partitioner.getPartition(_.map(topicMetadata[p.topic], &#x27;partition
&#x27;), p.key);
    p.attributes = p.hasOwnProperty(&#x27;attributes&#x27;) ? p.attributes : 0;
    let messages = _.isArray(p.messages) ? p.messages : [p.messages];

    messages = messages.map(function (message) {
      if (message instanceof KeyedMessage) {
        return message;
      }
      return new Message(0, 0, &#x27;&#x27;, message);
    });

    let key = p.topic + p.partition;
    let request = topicPartitionRequests[key];

    if (request == null) {
      topicPartitionRequests[key] = new ProduceRequest(p.topic, p.partition, messages, p.attributes);
    } else {
      assert(request.attributes === p.attributes);
      Array.prototype.push.apply(request.messages, messages);
    }
  });
  return _.values(topicPartitionRequests);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.close" id="apidoc.element.kafka-node.HighLevelProducer.super_.prototype.close">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.super_.prototype.</span>close
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (cb) {
  this.client.close(cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### close(force, cb)
* `force`: **Boolean**, if set to true, it forces the consumer to commit the current offset before closing, default `false`

Example

```js
consumer.<span class="apidocCodeKeywordSpan">close</span>(true, cb);
consumer.close(cb); //force is disabled
```

## HighLevelConsumer
⚠️ ***This consumer has been deprecated in the latest version of Kafka (0.10.1) and is likely to be removed in the future. Please
 use the ConsumerGroup instead.***

### HighLevelConsumer(client, payloads, options)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.connect" id="apidoc.element.kafka-node.HighLevelProducer.super_.prototype.connect">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.super_.prototype.</span>connect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connect = function () {
  // emiter...
  var self = this;
  this.ready = this.client.ready;
  if (this.ready) self.emit(&#x27;ready&#x27;);
  this.client.on(&#x27;ready&#x27;, function () {
    if (!self.ready) {
      self.ready = true;
      self.emit(&#x27;ready&#x27;);
    }
  });
  this.client.on(&#x27;brokersChanged&#x27;, function () {
    let topics = Object.keys(this.topicMetadata);
    this.refreshMetadata(topics, function (error) {
      if (error) {
        self.emit(&#x27;error&#x27;, error);
      }
    });
  });
  this.client.on(&#x27;error&#x27;, function (err) {
    self.emit(&#x27;error&#x27;, err);
  });
  this.client.on(&#x27;close&#x27;, function () {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    });

    this.on(&#x27;topicOwnerChange&#x27;, _.debounce(function (topics) {
      verified = 0;
      self.checkForOwnersAndListenForChange(topics);
    }, 250));

    this.zk.<span class="apidocCodeKeywordSpan">connect</span>();
  } else {
    this.connectConsumerGroup();
  }
}

util.inherits(ConsumerGroupMigrator, EventEmitter);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.createTopics" id="apidoc.element.kafka-node.HighLevelProducer.super_.prototype.createTopics">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.super_.prototype.</span>createTopics
        <span class="apidocSignatureSpan">(topics, async, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createTopics = function (topics, async, cb) {
  if (!this.ready) {
    return cb(new Error(&#x27;Producer not ready!&#x27;));
  }

  this.client.createTopics(topics, async, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

``` js
var kafka = require(&#x27;kafka-node&#x27;),
    Producer = kafka.Producer,
    client = new kafka.Client(),
    producer = new Producer(client);
// Create topics sync
producer.<span class="apidocCodeKeywordSpan">createTopics</span>([&#x27;t&#x27;,&#x27;t1&#x27;], false, function (err, data) {
    console.log(data);
});
// Create topics async
producer.createTopics([&#x27;t&#x27;], true, function (err, data) {});
producer.createTopics([&#x27;t&#x27;], function (err, data) {});// Simply omit 2nd arg
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.send" id="apidoc.element.kafka-node.HighLevelProducer.super_.prototype.send">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.super_.prototype.</span>send
        <span class="apidocSignatureSpan">(payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">send = function (payloads, cb) {
  var client = this.client;
  var requireAcks = this.requireAcks;
  var ackTimeoutMs = this.ackTimeoutMs;

  client.sendProduceRequest(this.buildPayloads(payloads, client.topicMetadata), requireAcks, ackTimeoutMs, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    producer = new Producer(client),
    km = new KeyedMessage(&#x27;key&#x27;, &#x27;message&#x27;),
    payloads = [
        { topic: &#x27;topic1&#x27;, messages: &#x27;hi&#x27;, partition: 0 },
        { topic: &#x27;topic2&#x27;, messages: [&#x27;hello&#x27;, &#x27;world&#x27;, km] }
    ];
producer.on(&#x27;ready&#x27;, function () {
    producer.<span class="apidocCodeKeywordSpan">send</span>(payloads, function (err, data) {
        console.log(data);
    });
});

producer.on(&#x27;error&#x27;, function (err) {})
```
&#x3e; ⚠️**WARNING**: Batch multiple messages of the same topic/partition together as an array on the `messages` attribute otherwise
 you may lose messages!
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.KeyedPartitioner" id="apidoc.module.kafka-node.KeyedPartitioner">module kafka-node.KeyedPartitioner</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.KeyedPartitioner.KeyedPartitioner" id="apidoc.element.kafka-node.KeyedPartitioner.KeyedPartitioner">
        function <span class="apidocSignatureSpan">kafka-node.</span>KeyedPartitioner
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">KeyedPartitioner = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.KeyedPartitioner.super_" id="apidoc.element.kafka-node.KeyedPartitioner.super_">
        function <span class="apidocSignatureSpan">kafka-node.KeyedPartitioner.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.KeyedPartitioner.prototype" id="apidoc.module.kafka-node.KeyedPartitioner.prototype">module kafka-node.KeyedPartitioner.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.KeyedPartitioner.prototype.getPartition" id="apidoc.element.kafka-node.KeyedPartitioner.prototype.getPartition">
        function <span class="apidocSignatureSpan">kafka-node.KeyedPartitioner.prototype.</span>getPartition
        <span class="apidocSignatureSpan">(partitions, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPartition = function (partitions, key) {
  key = key || &#x27;&#x27;;

  var index = this.hashCode(key) % partitions.length;
  return partitions[index];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.KeyedPartitioner.prototype.hashCode" id="apidoc.element.kafka-node.KeyedPartitioner.prototype.hashCode">
        function <span class="apidocSignatureSpan">kafka-node.KeyedPartitioner.prototype.</span>hashCode
        <span class="apidocSignatureSpan">(string)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hashCode = function (string) {
  var hash = 0;
  var length = string.length;

  for (var i = 0; i &#x3c; length; i++) {
    hash = ((hash * 31) + string.charCodeAt(i)) &#x26; 0x7fffffff;
  }

  return (hash === 0) ? 1 : hash;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  return (hash === 0) ? 1 : hash;
};

KeyedPartitioner.prototype.getPartition = function (partitions, key) {
  key = key || &#x27;&#x27;;

  var index = this.<span class="apidocCodeKeywordSpan">hashCode</span>(key) % partitions.length;
  return partitions[index];
};

var CustomPartitioner = function (partitioner) {
  this.getPartition = partitioner;
};
util.inherits(CustomPartitioner, Partitioner);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Offset" id="apidoc.module.kafka-node.Offset">module kafka-node.Offset</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Offset.Offset" id="apidoc.element.kafka-node.Offset.Offset">
        function <span class="apidocSignatureSpan">kafka-node.</span>Offset
        <span class="apidocSignatureSpan">(client)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Offset = function (client) {
  var self = this;
  this.client = client;
  this.ready = this.client.ready;
  this.client.on(&#x27;ready&#x27;, function () {
    self.ready = true;
    self.emit(&#x27;ready&#x27;);
  });
  this.client.once(&#x27;connect&#x27;, function () {
    self.emit(&#x27;connect&#x27;);
  });
  this.client.on(&#x27;error&#x27;, function (err) {
    self.emit(&#x27;error&#x27;, err);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `cb`: *Function*, the callback

Example

```js
var kafka = require(&#x27;kafka-node&#x27;),
    client = new kafka.Client(),
    offset = new kafka.<span class="apidocCodeKeywordSpan">Offset</span>(client);
    offset.fetch([
        { topic: &#x27;t&#x27;, partition: 0, time: Date.now(), maxNum: 1 }
    ], function (err, data) {
        // data
        // { &#x27;t&#x27;: { &#x27;0&#x27;: [999] } }
    });
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Offset.super_" id="apidoc.element.kafka-node.Offset.super_">
        function <span class="apidocSignatureSpan">kafka-node.Offset.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Offset.prototype" id="apidoc.module.kafka-node.Offset.prototype">module kafka-node.Offset.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Offset.prototype.buildPayloads" id="apidoc.element.kafka-node.Offset.prototype.buildPayloads">
        function <span class="apidocSignatureSpan">kafka-node.Offset.prototype.</span>buildPayloads
        <span class="apidocSignatureSpan">(payloads)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildPayloads = function (payloads) {
  return payloads.map(function (p) {
    p.partition = p.partition || 0;
    p.time = p.time || Date.now();
    p.maxNum = p.maxNum || 1;
    p.metadata = &#x27;m&#x27;; // metadata can be arbitrary
    return p;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Offset.prototype.commit" id="apidoc.element.kafka-node.Offset.prototype.commit">
        function <span class="apidocSignatureSpan">kafka-node.Offset.prototype.</span>commit
        <span class="apidocSignatureSpan">(groupId, payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">commit = function (groupId, payloads, cb) {
  if (!this.ready) {
    this.once(&#x27;ready&#x27;, () =&#x3e; this.commit(groupId, payloads, cb));
    return;
  }
  this.client.sendOffsetCommitRequest(groupId, this.buildPayloads(payloads), cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Commit offset of the current topics manually, this method should be called when a consumer leaves

* `cb`: **Function**, the callback

Example:

``` js
consumer.<span class="apidocCodeKeywordSpan">commit</span>(function(err, data) {
});
```

### setOffset(topic, partition, offset)
Set offset of the given topic

* `topic`: **String**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Offset.prototype.fetch" id="apidoc.element.kafka-node.Offset.prototype.fetch">
        function <span class="apidocSignatureSpan">kafka-node.Offset.prototype.</span>fetch
        <span class="apidocSignatureSpan">(payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetch = function (payloads, cb) {
  if (!this.ready) {
    this.once(&#x27;ready&#x27;, () =&#x3e; this.fetch(payloads, cb));
    return;
  }
  this.client.sendOffsetRequest(this.buildPayloads(payloads), cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Example

```js
var kafka = require(&#x27;kafka-node&#x27;),
    client = new kafka.Client(),
    offset = new kafka.Offset(client);
    offset.<span class="apidocCodeKeywordSpan">fetch</span>([
        { topic: &#x27;t&#x27;, partition: 0, time: Date.now(), maxNum: 1 }
    ], function (err, data) {
        // data
        // { &#x27;t&#x27;: { &#x27;0&#x27;: [999] } }
    });
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Offset.prototype.fetchCommits" id="apidoc.element.kafka-node.Offset.prototype.fetchCommits">
        function <span class="apidocSignatureSpan">kafka-node.Offset.prototype.</span>fetchCommits
        <span class="apidocSignatureSpan">(groupId, payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetchCommits = function (groupId, payloads, cb) {
  if (!this.ready) {
    this.once(&#x27;ready&#x27;, () =&#x3e; this.fetchCommits(groupId, payloads, cb));
    return;
  }
  this.client.sendOffsetFetchRequest(groupId, this.buildPayloads(payloads), cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Example

```js
var kafka = require(&#x27;kafka-node&#x27;),
    client = new kafka.Client(),
    offset = new kafka.Offset(client);
    offset.<span class="apidocCodeKeywordSpan">fetchCommits</span>(&#x27;groupId&#x27;, [
        { topic: &#x27;t&#x27;, partition: 0 }
    ], function (err, data) {
    });
```

### fetchLatestOffsets(topics, cb)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Offset.prototype.fetchEarliestOffsets" id="apidoc.element.kafka-node.Offset.prototype.fetchEarliestOffsets">
        function <span class="apidocSignatureSpan">kafka-node.Offset.prototype.</span>fetchEarliestOffsets
        <span class="apidocSignatureSpan">(topics, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetchEarliestOffsets = function (topics, cb) {
  fetchOffsets(this, topics, cb, -2);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### fetchEarliestOffsets(topics, cb)

Example

```js
	var partition = 0;
	var topic = &#x27;t&#x27;;
	offset.<span class="apidocCodeKeywordSpan">fetchEarliestOffsets</span>([topic], function (error, offsets) {
		if (error)
			return handleError(error);
		console.log(offsets[topic][partition]);
	});
```

# Troubleshooting / FAQ
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Offset.prototype.fetchLatestOffsets" id="apidoc.element.kafka-node.Offset.prototype.fetchLatestOffsets">
        function <span class="apidocSignatureSpan">kafka-node.Offset.prototype.</span>fetchLatestOffsets
        <span class="apidocSignatureSpan">(topics, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetchLatestOffsets = function (topics, cb) {
  fetchOffsets(this, topics, cb, -1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### fetchLatestOffsets(topics, cb)

Example

```js
	var partition = 0;
	var topic = &#x27;t&#x27;;
	offset.<span class="apidocCodeKeywordSpan">fetchLatestOffsets</span>([topic], function (error, offsets) {
		if (error)
			return handleError(error);
		console.log(offsets[topic][partition]);
	});
```

### fetchEarliestOffsets(topics, cb)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Producer" id="apidoc.module.kafka-node.Producer">module kafka-node.Producer</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Producer.Producer" id="apidoc.element.kafka-node.Producer.Producer">
        function <span class="apidocSignatureSpan">kafka-node.</span>Producer
        <span class="apidocSignatureSpan">(client, options, customPartitioner)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Producer(client, options, customPartitioner) {
  BaseProducer.call(this, client, options, BaseProducer.PARTITIONER_TYPES.default, customPartitioner);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Producer.super_" id="apidoc.element.kafka-node.Producer.super_">
        function <span class="apidocSignatureSpan">kafka-node.Producer.</span>super_
        <span class="apidocSignatureSpan">(client, options, defaultPartitionerType, customPartitioner)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BaseProducer(client, options, defaultPartitionerType, customPartitioner) {
  options = options || {};

  this.ready = false;
  this.client = client;

  this.requireAcks = options.requireAcks === undefined
    ? DEFAULTS.requireAcks
    : options.requireAcks;
  this.ackTimeoutMs = options.ackTimeoutMs === undefined
    ? DEFAULTS.ackTimeoutMs
    : options.ackTimeoutMs;

  if (customPartitioner !== undefined &#x26;&#x26; options.partitionerType !== PARTITIONER_TYPES.custom) {
    throw new Error(&#x27;Partitioner Type must be custom if providing a customPartitioner.&#x27;);
  } else if (customPartitioner === undefined &#x26;&#x26; options.partitionerType === PARTITIONER_TYPES.custom) {
    throw new Error(&#x27;No customer partitioner defined&#x27;);
  }

  var partitionerType = PARTITIONER_MAP[options.partitionerType] || PARTITIONER_MAP[defaultPartitionerType];

  // eslint-disable-next-line
  this.partitioner = new partitionerType(customPartitioner);

  this.connect();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.RandomPartitioner" id="apidoc.module.kafka-node.RandomPartitioner">module kafka-node.RandomPartitioner</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.RandomPartitioner.RandomPartitioner" id="apidoc.element.kafka-node.RandomPartitioner.RandomPartitioner">
        function <span class="apidocSignatureSpan">kafka-node.</span>RandomPartitioner
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RandomPartitioner = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.RandomPartitioner.super_" id="apidoc.element.kafka-node.RandomPartitioner.super_">
        function <span class="apidocSignatureSpan">kafka-node.RandomPartitioner.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.RandomPartitioner.prototype" id="apidoc.module.kafka-node.RandomPartitioner.prototype">module kafka-node.RandomPartitioner.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.RandomPartitioner.prototype.getPartition" id="apidoc.element.kafka-node.RandomPartitioner.prototype.getPartition">
        function <span class="apidocSignatureSpan">kafka-node.RandomPartitioner.prototype.</span>getPartition
        <span class="apidocSignatureSpan">(partitions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPartition = function (partitions) {
  return partitions[Math.floor(Math.random() * partitions.length)];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.consumerGroupMigrator" id="apidoc.module.kafka-node.consumerGroupMigrator">module kafka-node.consumerGroupMigrator</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.consumerGroupMigrator.consumerGroupMigrator" id="apidoc.element.kafka-node.consumerGroupMigrator.consumerGroupMigrator">
        function <span class="apidocSignatureSpan">kafka-node.</span>consumerGroupMigrator
        <span class="apidocSignatureSpan">(consumerGroup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ConsumerGroupMigrator(consumerGroup) {
  EventEmitter.call(this);
  assert(consumerGroup);
  const self = this;
  this.consumerGroup = consumerGroup;
  this.client = consumerGroup.client;
  var verified = 0;

  if (consumerGroup.options.migrateRolling) {
    this.zk = zookeeper.createClient(consumerGroup.client.connectionString, {retries: 10});
    this.zk.on(&#x27;connected&#x27;, function () {
      self.filterByExistingZkTopics(function (error, topics) {
        if (error) {
          return self.emit(&#x27;error&#x27;, error);
        }

        if (topics.length) {
          self.checkForOwnersAndListenForChange(topics);
        } else {
          logger.debug(&#x27;No HLC topics exist in zookeeper.&#x27;);
          self.connectConsumerGroup();
        }
      });
    });

    this.on(&#x27;noOwnersForTopics&#x27;, function (topics) {
      logger.debug(&#x27;No owners for topics %s reported.&#x27;, topics);
      if (++verified &#x3c;= NUMER_OF_TIMES_TO_VERIFY) {
        logger.debug(&#x27;%s verify %d of %d HLC has given up ownership by checking again in %d&#x27;, self.client.clientId, verified,
          NUMER_OF_TIMES_TO_VERIFY, VERIFY_WAIT_TIME_MS);

        setTimeout(function () {
          self.checkForOwners(topics);
        }, VERIFY_WAIT_TIME_MS);
      } else {
        self.connectConsumerGroup();
      }
    });

    this.on(&#x27;topicOwnerChange&#x27;, _.debounce(function (topics) {
      verified = 0;
      self.checkForOwnersAndListenForChange(topics);
    }, 250));

    this.zk.connect();
  } else {
    this.connectConsumerGroup();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.consumerGroupMigrator.super_" id="apidoc.element.kafka-node.consumerGroupMigrator.super_">
        function <span class="apidocSignatureSpan">kafka-node.consumerGroupMigrator.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.consumerGroupMigrator.prototype" id="apidoc.module.kafka-node.consumerGroupMigrator.prototype">module kafka-node.consumerGroupMigrator.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.consumerGroupMigrator.prototype.checkForOwners" id="apidoc.element.kafka-node.consumerGroupMigrator.prototype.checkForOwners">
        function <span class="apidocSignatureSpan">kafka-node.consumerGroupMigrator.prototype.</span>checkForOwners
        <span class="apidocSignatureSpan">(topics, listenForChange)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkForOwners = function (topics, listenForChange) {
  const self = this;
  const path = &#x27;/consumers/&#x27; + this.consumerGroup.options.groupId + &#x27;/owners/&#x27;;
  var ownedPartitions = 0;

  function topicWatcher (event) {
    self.emit(&#x27;topicOwnerChange&#x27;, topics);
  }

  async.each(topics,
    function (topic, callback) {
      const args = [path + topic];

      if (listenForChange) {
        logger.debug(&#x27;%s listening for changes in topic %s&#x27;, self.client.clientId, topic);
        args.push(topicWatcher);
      }

      args.push(function (error, children, stats) {
        if (error) {
          return callback(error);
        }
        ownedPartitions += children.length;
        callback(null);
      });

      self.zk.getChildren.apply(self.zk, args);
    },
    function (error) {
      if (error) {
        return self.emit(&#x27;error&#x27;, error);
      }
      if (ownedPartitions === 0) {
        self.emit(&#x27;noOwnersForTopics&#x27;, topics);
      } else {
        logger.debug(&#x27;%s %d partitions are owned by old HLC... waiting...&#x27;, self.client.clientId, ownedPartitions);
      }
    }
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.on(&#x27;noOwnersForTopics&#x27;, function (topics) {
  logger.debug(&#x27;No owners for topics %s reported.&#x27;, topics);
  if (++verified &#x3c;= NUMER_OF_TIMES_TO_VERIFY) {
    logger.debug(&#x27;%s verify %d of %d HLC has given up ownership by checking again in %d&#x27;, self.client.clientId, verified
,
      NUMER_OF_TIMES_TO_VERIFY, VERIFY_WAIT_TIME_MS);

    setTimeout(function () {
      self.<span class="apidocCodeKeywordSpan">checkForOwners</span>(topics);
    }, VERIFY_WAIT_TIME_MS);
  } else {
    self.connectConsumerGroup();
  }
});

this.on(&#x27;topicOwnerChange&#x27;, _.debounce(function (topics) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.consumerGroupMigrator.prototype.checkForOwnersAndListenForChange" id="apidoc.element.kafka-node.consumerGroupMigrator.prototype.checkForOwnersAndListenForChange">
        function <span class="apidocSignatureSpan">kafka-node.consumerGroupMigrator.prototype.</span>checkForOwnersAndListenForChange
        <span class="apidocSignatureSpan">(topics)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkForOwnersAndListenForChange = function (topics) {
  this.checkForOwners(topics, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.zk.on(&#x27;connected&#x27;, function () {
  self.filterByExistingZkTopics(function (error, topics) {
    if (error) {
      return self.emit(&#x27;error&#x27;, error);
    }

    if (topics.length) {
      self.<span class="apidocCodeKeywordSpan">checkForOwnersAndListenForChange</span>(topics);
    } else {
      logger.debug(&#x27;No HLC topics exist in zookeeper.&#x27;);
      self.connectConsumerGroup();
    }
  });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.consumerGroupMigrator.prototype.connectConsumerGroup" id="apidoc.element.kafka-node.consumerGroupMigrator.prototype.connectConsumerGroup">
        function <span class="apidocSignatureSpan">kafka-node.consumerGroupMigrator.prototype.</span>connectConsumerGroup
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connectConsumerGroup = function () {
  logger.debug(&#x27;%s connecting consumer group&#x27;, this.client.clientId);
  const self = this;
  if (this.client.ready) {
    this.consumerGroup.connect();
  } else {
    this.client.once(&#x27;ready&#x27;, function () {
      self.consumerGroup.connect();
    });
  }
  this.zk &#x26;&#x26; this.zk.close();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return self.emit(&#x27;error&#x27;, error);
    }

    if (topics.length) {
      self.checkForOwnersAndListenForChange(topics);
    } else {
      logger.debug(&#x27;No HLC topics exist in zookeeper.&#x27;);
      self.<span class="apidocCodeKeywordSpan">connectConsumerGroup</span>();
    }
  });
});

this.on(&#x27;noOwnersForTopics&#x27;, function (topics) {
  logger.debug(&#x27;No owners for topics %s reported.&#x27;, topics);
  if (++verified &#x3c;= NUMER_OF_TIMES_TO_VERIFY) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.consumerGroupMigrator.prototype.filterByExistingZkTopics" id="apidoc.element.kafka-node.consumerGroupMigrator.prototype.filterByExistingZkTopics">
        function <span class="apidocSignatureSpan">kafka-node.consumerGroupMigrator.prototype.</span>filterByExistingZkTopics
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filterByExistingZkTopics = function (callback) {
  const self = this;
  const path = &#x27;/consumers/&#x27; + this.consumerGroup.options.groupId + &#x27;/owners/&#x27;;

  async.filter(this.consumerGroup.topics, function (topic, cb) {
    const topicPath = path + topic;
    logger.debug(&#x27;%s checking zk path %s&#x27;, self.client.clientId, topicPath);
    self.zk.exists(topicPath, function (error, stat) {
      if (error) {
        return callback(error);
      }
      cb(stat);
    });
  }, function (result) {
    callback(null, result);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.consumerGroup = consumerGroup;
  this.client = consumerGroup.client;
  var verified = 0;

  if (consumerGroup.options.migrateRolling) {
    this.zk = zookeeper.createClient(consumerGroup.client.connectionString, {retries: 10});
    this.zk.on(&#x27;connected&#x27;, function () {
      self.<span class="apidocCodeKeywordSpan">filterByExistingZkTopics</span>(function (error, topics) {
if (error) {
  return self.emit(&#x27;error&#x27;, error);
}

if (topics.length) {
  self.checkForOwnersAndListenForChange(topics);
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.consumerGroupMigrator.prototype.getOffset" id="apidoc.element.kafka-node.consumerGroupMigrator.prototype.getOffset">
        function <span class="apidocSignatureSpan">kafka-node.consumerGroupMigrator.prototype.</span>getOffset
        <span class="apidocSignatureSpan">(tp, defaultOffset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOffset = function (tp, defaultOffset) {
  const offset = _.get(this.offsets, [tp.topic, tp.partition], defaultOffset);
  if (offset === -1) {
    return defaultOffset;
  }
  return offset;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.consumerGroupMigrator.prototype.saveHighLevelConsumerOffsets" id="apidoc.element.kafka-node.consumerGroupMigrator.prototype.saveHighLevelConsumerOffsets">
        function <span class="apidocSignatureSpan">kafka-node.consumerGroupMigrator.prototype.</span>saveHighLevelConsumerOffsets
        <span class="apidocSignatureSpan">(topicPartitionList, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">saveHighLevelConsumerOffsets = function (topicPartitionList, callback) {
  const self = this;
  this.client.sendOffsetFetchRequest(this.consumerGroup.options.groupId, topicPartitionList, function (error, results) {
    logger.debug(&#x27;sendOffsetFetchRequest response:&#x27;, results, error);
    if (error) {
      return callback(error);
    }
    self.offsets = results;
    callback(null);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.consumerGroupRecovery" id="apidoc.module.kafka-node.consumerGroupRecovery">module kafka-node.consumerGroupRecovery</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.consumerGroupRecovery.consumerGroupRecovery" id="apidoc.element.kafka-node.consumerGroupRecovery.consumerGroupRecovery">
        function <span class="apidocSignatureSpan">kafka-node.</span>consumerGroupRecovery
        <span class="apidocSignatureSpan">(consumerGroup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ConsumerGroupRecovery(consumerGroup) {
  this.consumerGroup = consumerGroup;
  this.options = consumerGroup.options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.consumerGroupRecovery.prototype" id="apidoc.module.kafka-node.consumerGroupRecovery.prototype">module kafka-node.consumerGroupRecovery.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.consumerGroupRecovery.prototype.clearError" id="apidoc.element.kafka-node.consumerGroupRecovery.prototype.clearError">
        function <span class="apidocSignatureSpan">kafka-node.consumerGroupRecovery.prototype.</span>clearError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearError = function () {
  this.lastError = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.consumerGroupRecovery.prototype.getRetryTimeout" id="apidoc.element.kafka-node.consumerGroupRecovery.prototype.getRetryTimeout">
        function <span class="apidocSignatureSpan">kafka-node.consumerGroupRecovery.prototype.</span>getRetryTimeout
        <span class="apidocSignatureSpan">(error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getRetryTimeout = function (error) {
  assert(error);
  if (!this._timeouts) {
    this._timeouts = retry.timeouts({
      retries: this.options.retries,
      factor: this.options.retryFactor,
      minTimeout: this.options.retryMinTimeout
    });
  }

  if (this._retryIndex == null || this.lastError == null ||
      error.errorCode !== this.lastError.errorCode) {
    this._retryIndex = 0;
  }

  var index = this._retryIndex++;
  if (index &#x3e;= this._timeouts.length) {
    return false;
  }
  return this._timeouts[index];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    recoverableItem.handler &#x26;&#x26; recoverableItem.handler.call(this.consumerGroup, error);
    return true;
  }
  return false;
}, this);

if (retry) {
  retryTimeout = this.<span class="apidocCodeKeywordSpan">getRetryTimeout</span>(error);
}

if (retry &#x26;&#x26; retryTimeout) {
  logger.debug(&#x27;RECOVERY from %s: %s retrying in %s ms&#x27;, source, this.consumerGroup.client.clientId, retryTimeout, error
);
  this.consumerGroup.scheduleReconnect(retryTimeout);
} else {
  this.consumerGroup.emit(&#x27;error&#x27;, error);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.consumerGroupRecovery.prototype.tryToRecoverFrom" id="apidoc.element.kafka-node.consumerGroupRecovery.prototype.tryToRecoverFrom">
        function <span class="apidocSignatureSpan">kafka-node.consumerGroupRecovery.prototype.</span>tryToRecoverFrom
        <span class="apidocSignatureSpan">(error, source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tryToRecoverFrom = function (error, source) {
  this.consumerGroup.ready = false;
  this.consumerGroup.stopHeartbeats();

  var retryTimeout = false;
  var retry = recoverableErrors.some(function (recoverableItem) {
    if (isErrorInstanceOf(error, recoverableItem.errors)) {
      recoverableItem.handler &#x26;&#x26; recoverableItem.handler.call(this.consumerGroup, error);
      return true;
    }
    return false;
  }, this);

  if (retry) {
    retryTimeout = this.getRetryTimeout(error);
  }

  if (retry &#x26;&#x26; retryTimeout) {
    logger.debug(&#x27;RECOVERY from %s: %s retrying in %s ms&#x27;, source, this.consumerGroup.client.clientId, retryTimeout, error);
    this.consumerGroup.scheduleReconnect(retryTimeout);
  } else {
    this.consumerGroup.emit(&#x27;error&#x27;, error);
  }
  this.lastError = error;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.logging" id="apidoc.module.kafka-node.logging">module kafka-node.logging</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.logging.logging" id="apidoc.element.kafka-node.logging.logging">
        function <span class="apidocSignatureSpan">kafka-node.</span>logging
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getLogger(name) {
  return loggerProvider(name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.logging.setLoggerProvider" id="apidoc.element.kafka-node.logging.setLoggerProvider">
        function <span class="apidocSignatureSpan">kafka-node.logging.</span>setLoggerProvider
        <span class="apidocSignatureSpan">(provider)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setLoggerProvider(provider) {
  loggerProvider = provider;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### How do I set a logger provider?

For performance reasons, initialization of the `kafka-node` module creates all necessary loggers. This means that custom logger
providers need to be set *before requiring the `kafka-node` module*. The following example shows how this can be done:

```javascript
// first configure the logger provider
const kafkaLogging = require(&#x27;kafka-node/logging&#x27;);
kafkaLogging.<span class="apidocCodeKeywordSpan">setLoggerProvider</span>(consoleLoggerProvider);

// then require kafka-node and continue as normal
const kafka = require(&#x27;kafka-node&#x27;);
```

# Running Tests
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.partitioner" id="apidoc.module.kafka-node.partitioner">module kafka-node.partitioner</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.partitioner.CustomPartitioner" id="apidoc.element.kafka-node.partitioner.CustomPartitioner">
        function <span class="apidocSignatureSpan">kafka-node.partitioner.</span>CustomPartitioner
        <span class="apidocSignatureSpan">(partitioner)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CustomPartitioner = function (partitioner) {
  this.getPartition = partitioner;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.partitioner.CyclicPartitioner" id="apidoc.element.kafka-node.partitioner.CyclicPartitioner">
        function <span class="apidocSignatureSpan">kafka-node.partitioner.</span>CyclicPartitioner
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CyclicPartitioner = function () {
  this.c = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.partitioner.DefaultPartitioner" id="apidoc.element.kafka-node.partitioner.DefaultPartitioner">
        function <span class="apidocSignatureSpan">kafka-node.partitioner.</span>DefaultPartitioner
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">DefaultPartitioner = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.partitioner.KeyedPartitioner" id="apidoc.element.kafka-node.partitioner.KeyedPartitioner">
        function <span class="apidocSignatureSpan">kafka-node.partitioner.</span>KeyedPartitioner
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">KeyedPartitioner = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.partitioner.RandomPartitioner" id="apidoc.element.kafka-node.partitioner.RandomPartitioner">
        function <span class="apidocSignatureSpan">kafka-node.partitioner.</span>RandomPartitioner
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RandomPartitioner = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.utils" id="apidoc.module.kafka-node.utils">module kafka-node.utils</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.utils.createTopicPartitionList" id="apidoc.element.kafka-node.utils.createTopicPartitionList">
        function <span class="apidocSignatureSpan">kafka-node.utils.</span>createTopicPartitionList
        <span class="apidocSignatureSpan">(topicPartitions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createTopicPartitionList(topicPartitions) {
  var tpList = [];
  for (var topic in topicPartitions) {
    if (!topicPartitions.hasOwnProperty(topic)) {
      continue;
    }
    topicPartitions[topic].forEach(function (partition) {
      tpList.push({
        topic: topic,
        partition: partition
      });
    });
  }
  return tpList;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.utils.groupPartitionsByTopic" id="apidoc.element.kafka-node.utils.groupPartitionsByTopic">
        function <span class="apidocSignatureSpan">kafka-node.utils.</span>groupPartitionsByTopic
        <span class="apidocSignatureSpan">(topicPartitions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function groupPartitionsByTopic(topicPartitions) {
  assert(Array.isArray(topicPartitions));
  return topicPartitions.reduce(function (result, tp) {
    if (!(tp.topic in result)) {
      result[tp.topic] = [tp.partition];
    } else {
      result[tp.topic].push(tp.partition);
    }
    return result;
  }, {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.utils.validateConfig" id="apidoc.element.kafka-node.utils.validateConfig">
        function <span class="apidocSignatureSpan">kafka-node.utils.</span>validateConfig
        <span class="apidocSignatureSpan">(property, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function validateConfig(property, value) {
  if (!legalChars.test(value)) {
    throw new InvalidConfigError([property, value, &#x22;is illegal, contains a character other than ASCII alphanumerics, &#x27;.&#x27;, &#x27;_&#x27; and
 &#x27;-&#x27;&#x22;].join(&#x27; &#x27;));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.utils.validateTopicNames" id="apidoc.element.kafka-node.utils.validateTopicNames">
        function <span class="apidocSignatureSpan">kafka-node.utils.</span>validateTopicNames
        <span class="apidocSignatureSpan">(topics)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function validateTopicNames(topics) {
  // Rewriting same validations done by Apache Kafka team for topics
  // iterating over topics
  topics.some(function (topic) {
    if (topic.length &#x3c;= 0) {
      throw new InvalidConfigError(&#x27;topic name is illegal, cannot be empty&#x27;);
    }
    if (topic === &#x27;.&#x27; || topic === &#x27;..&#x27;) {
      throw new InvalidConfigError(&#x27;topic name cannot be . or ..&#x27;);
    }
    if (topic.length &#x3e; allowedTopicLength) {
      throw new InvalidConfigError(`topic name is illegal, cannot be longer than ${allowedTopicLength} characters`);
    }
    if (!legalChars.test(topic)) {
      throw new InvalidConfigError(`topic name ${topic} is illegal, contains a character other than ASCII alphanumerics .,_ and -`);
    }
  });
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.utils.validateTopics" id="apidoc.element.kafka-node.utils.validateTopics">
        function <span class="apidocSignatureSpan">kafka-node.utils.</span>validateTopics
        <span class="apidocSignatureSpan">(topics)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function validateTopics(topics) {
  if (topics.some(function (topic) {
    if (&#x27;partition&#x27; in topic) {
      return typeof topic.partition !== &#x27;number&#x27;;
    }
    return false;
  })) {
    throw new InvalidConfigError(&#x27;Offset must be a number and can not contain characters&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.zookeeper" id="apidoc.module.kafka-node.zookeeper">module kafka-node.zookeeper</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.zookeeper.Zookeeper" id="apidoc.element.kafka-node.zookeeper.Zookeeper">
        function <span class="apidocSignatureSpan">kafka-node.zookeeper.</span>Zookeeper
        <span class="apidocSignatureSpan">(connectionString, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Zookeeper = function (connectionString, options) {
  this.client = zookeeper.createClient(connectionString, options);

  var that = this;
  this.client.on(&#x27;connected&#x27;, function () {
    that.listBrokers();
  });
  this.client.on(&#x27;disconnected&#x27;, function () {
    that.emit(&#x27;disconnected&#x27;);
  });
  this.client.connect();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.zookeeper.ZookeeperConsumerMappings" id="apidoc.element.kafka-node.zookeeper.ZookeeperConsumerMappings">
        function <span class="apidocSignatureSpan">kafka-node.zookeeper.</span>ZookeeperConsumerMappings
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ZookeeperConsumerMappings = function () {
  this.consumerTopicMap = {};
  this.topicConsumerMap = {};
  this.topicPartitionMap = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
