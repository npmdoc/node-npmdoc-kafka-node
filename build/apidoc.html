<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/SOHU-Co/kafka-node#readme"

    >kafka-node (v1.6.0)</a>
</h1>
<h4>Client for Apache Kafka v0.8+</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node">module kafka-node</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.BrokerNotAvailableError">
            function <span class="apidocSignatureSpan">kafka-node.</span>BrokerNotAvailableError
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.BrokerReadable">
            function <span class="apidocSignatureSpan">kafka-node.</span>BrokerReadable
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.BrokerTransform">
            function <span class="apidocSignatureSpan">kafka-node.</span>BrokerTransform
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.BrokerWrapper">
            function <span class="apidocSignatureSpan">kafka-node.</span>BrokerWrapper
            <span class="apidocSignatureSpan">(socket, noAckBatchOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client">
            function <span class="apidocSignatureSpan">kafka-node.</span>Client
            <span class="apidocSignatureSpan">(connectionString, clientId, zkOptions, noAckBatchOptions, sslOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer">
            function <span class="apidocSignatureSpan">kafka-node.</span>Consumer
            <span class="apidocSignatureSpan">(client, topics, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup">
            function <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup
            <span class="apidocSignatureSpan">(memberOptions, topics)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.CustomPartitioner">
            function <span class="apidocSignatureSpan">kafka-node.</span>CustomPartitioner
            <span class="apidocSignatureSpan">(partitioner)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.CyclicPartitioner">
            function <span class="apidocSignatureSpan">kafka-node.</span>CyclicPartitioner
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.DefaultPartitioner">
            function <span class="apidocSignatureSpan">kafka-node.</span>DefaultPartitioner
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.FailedToRebalanceConsumerError">
            function <span class="apidocSignatureSpan">kafka-node.</span>FailedToRebalanceConsumerError
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.FailedToRegisterConsumerError">
            function <span class="apidocSignatureSpan">kafka-node.</span>FailedToRegisterConsumerError
            <span class="apidocSignatureSpan">(message, nested)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.GroupCoordinatorNotAvailableError">
            function <span class="apidocSignatureSpan">kafka-node.</span>GroupCoordinatorNotAvailableError
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.GroupLoadInProgressError">
            function <span class="apidocSignatureSpan">kafka-node.</span>GroupLoadInProgressError
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HeartbeatTimeoutError">
            function <span class="apidocSignatureSpan">kafka-node.</span>HeartbeatTimeoutError
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer">
            function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer
            <span class="apidocSignatureSpan">(client, topics, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelProducer">
            function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelProducer
            <span class="apidocSignatureSpan">(client, options, customPartitioner)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelProducer.super_">
            function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelProducer.super_
            <span class="apidocSignatureSpan">(client, options, defaultPartitionerType, customPartitioner)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.IllegalGenerationError">
            function <span class="apidocSignatureSpan">kafka-node.</span>IllegalGenerationError
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.InvalidConfigError">
            function <span class="apidocSignatureSpan">kafka-node.</span>InvalidConfigError
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.InvalidConsumerOffsetError">
            function <span class="apidocSignatureSpan">kafka-node.</span>InvalidConsumerOffsetError
            <span class="apidocSignatureSpan">(message, nested)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.KafkaBuffer">
            function <span class="apidocSignatureSpan">kafka-node.</span>KafkaBuffer
            <span class="apidocSignatureSpan">(batchSize, batchAge)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.KeyedMessage">
            function <span class="apidocSignatureSpan">kafka-node.</span>KeyedMessage
            <span class="apidocSignatureSpan">(key, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.KeyedPartitioner">
            function <span class="apidocSignatureSpan">kafka-node.</span>KeyedPartitioner
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.NotCoordinatorForGroupError">
            function <span class="apidocSignatureSpan">kafka-node.</span>NotCoordinatorForGroupError
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Offset">
            function <span class="apidocSignatureSpan">kafka-node.</span>Offset
            <span class="apidocSignatureSpan">(client)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Producer">
            function <span class="apidocSignatureSpan">kafka-node.</span>Producer
            <span class="apidocSignatureSpan">(client, options, customPartitioner)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.RandomPartitioner">
            function <span class="apidocSignatureSpan">kafka-node.</span>RandomPartitioner
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.RebalanceInProgressError">
            function <span class="apidocSignatureSpan">kafka-node.</span>RebalanceInProgressError
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.TopicsNotExistError">
            function <span class="apidocSignatureSpan">kafka-node.</span>TopicsNotExistError
            <span class="apidocSignatureSpan">(topics)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.UnknownMemberIdError">
            function <span class="apidocSignatureSpan">kafka-node.</span>UnknownMemberIdError
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.consumerGroupMigrator">
            function <span class="apidocSignatureSpan">kafka-node.</span>consumerGroupMigrator
            <span class="apidocSignatureSpan">(consumerGroup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.consumerGroupRecovery">
            function <span class="apidocSignatureSpan">kafka-node.</span>consumerGroupRecovery
            <span class="apidocSignatureSpan">(consumerGroup)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>BrokerReadable.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>BrokerTransform.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>BrokerWrapper.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>Client.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>Consumer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>CyclicPartitioner.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>DefaultPartitioner.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>HighLevelProducer.super_.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>KafkaBuffer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>KeyedPartitioner.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>Offset.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>RandomPartitioner.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>consumerGroupMigrator.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>consumerGroupRecovery.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>logging</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>partitioner</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>protocol</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>protocol_struct</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>range</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>roundrobin</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>snappy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>utils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.</span>zookeeper</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.BrokerNotAvailableError">module kafka-node.BrokerNotAvailableError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.BrokerNotAvailableError.BrokerNotAvailableError">
            function <span class="apidocSignatureSpan">kafka-node.</span>BrokerNotAvailableError
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.BrokerNotAvailableError.super_">
            function <span class="apidocSignatureSpan">kafka-node.BrokerNotAvailableError.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.BrokerReadable">module kafka-node.BrokerReadable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.BrokerReadable.BrokerReadable">
            function <span class="apidocSignatureSpan">kafka-node.</span>BrokerReadable
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.BrokerReadable.super_">
            function <span class="apidocSignatureSpan">kafka-node.BrokerReadable.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.BrokerReadable.prototype">module kafka-node.BrokerReadable.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.BrokerReadable.prototype._read">
            function <span class="apidocSignatureSpan">kafka-node.BrokerReadable.prototype.</span>_read
            <span class="apidocSignatureSpan">(size)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.BrokerTransform">module kafka-node.BrokerTransform</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.BrokerTransform.BrokerTransform">
            function <span class="apidocSignatureSpan">kafka-node.</span>BrokerTransform
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.BrokerTransform.super_">
            function <span class="apidocSignatureSpan">kafka-node.BrokerTransform.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.BrokerTransform.prototype">module kafka-node.BrokerTransform.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.BrokerTransform.prototype._transform">
            function <span class="apidocSignatureSpan">kafka-node.BrokerTransform.prototype.</span>_transform
            <span class="apidocSignatureSpan">(chunk, enc, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.BrokerTransform.prototype._transformNext">
            function <span class="apidocSignatureSpan">kafka-node.BrokerTransform.prototype.</span>_transformNext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.BrokerWrapper">module kafka-node.BrokerWrapper</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.BrokerWrapper.BrokerWrapper">
            function <span class="apidocSignatureSpan">kafka-node.</span>BrokerWrapper
            <span class="apidocSignatureSpan">(socket, noAckBatchOptions)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.BrokerWrapper.prototype">module kafka-node.BrokerWrapper.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.BrokerWrapper.prototype.write">
            function <span class="apidocSignatureSpan">kafka-node.BrokerWrapper.prototype.</span>write
            <span class="apidocSignatureSpan">(buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.BrokerWrapper.prototype.writeAsync">
            function <span class="apidocSignatureSpan">kafka-node.BrokerWrapper.prototype.</span>writeAsync
            <span class="apidocSignatureSpan">(buffer)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Client">module kafka-node.Client</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.Client">
            function <span class="apidocSignatureSpan">kafka-node.</span>Client
            <span class="apidocSignatureSpan">(connectionString, clientId, zkOptions, noAckBatchOptions, sslOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.super_">
            function <span class="apidocSignatureSpan">kafka-node.Client.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Client.prototype">module kafka-node.Client.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.addTopics">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>addTopics
            <span class="apidocSignatureSpan">(topics, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.brokerForLeader">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>brokerForLeader
            <span class="apidocSignatureSpan">(leader, longpolling)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.checkMetadatas">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>checkMetadatas
            <span class="apidocSignatureSpan">(payloads)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.clearCallbackQueue">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>clearCallbackQueue
            <span class="apidocSignatureSpan">(socket, error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.close">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>close
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.closeBrokers">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>closeBrokers
            <span class="apidocSignatureSpan">(brokers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.connect">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>connect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.createBroker">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>createBroker
            <span class="apidocSignatureSpan">(host, port, longpolling)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.createTopics">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>createTopics
            <span class="apidocSignatureSpan">(topics, isAsync, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.getBrokers">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>getBrokers
            <span class="apidocSignatureSpan">(longpolling)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.handleReceivedData">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>handleReceivedData
            <span class="apidocSignatureSpan">(socket)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.hasMetadata">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>hasMetadata
            <span class="apidocSignatureSpan">(topic, partition)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.leaderByPartition">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>leaderByPartition
            <span class="apidocSignatureSpan">(topic, partition)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.loadMetadataForTopics">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>loadMetadataForTopics
            <span class="apidocSignatureSpan">(topics, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.nextId">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>nextId
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.nextSocketId">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>nextSocketId
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.payloadsByLeader">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>payloadsByLeader
            <span class="apidocSignatureSpan">(payloads)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.queueCallback">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>queueCallback
            <span class="apidocSignatureSpan">(socket, id, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.reconnectBroker">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>reconnectBroker
            <span class="apidocSignatureSpan">(oldSocket)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.refreshBrokers">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>refreshBrokers
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.refreshMetadata">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>refreshMetadata
            <span class="apidocSignatureSpan">(topicNames, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.removeTopicMetadata">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>removeTopicMetadata
            <span class="apidocSignatureSpan">(topics, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.send">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>send
            <span class="apidocSignatureSpan">(payloads, encoder, decoder, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendFetchRequest">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendFetchRequest
            <span class="apidocSignatureSpan">(consumer, payloads, fetchMaxWaitMs, fetchMinBytes, maxTickMessages)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendGroupCoordinatorRequest">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendGroupCoordinatorRequest
            <span class="apidocSignatureSpan">(groupId, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendGroupRequest">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendGroupRequest
            <span class="apidocSignatureSpan">(encode, decode, requestArgs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendHeartbeatRequest">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendHeartbeatRequest
            <span class="apidocSignatureSpan">(groupId, generationId, memberId, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendJoinGroupRequest">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendJoinGroupRequest
            <span class="apidocSignatureSpan">(groupId, memberId, sessionTimeout, groupProtocol, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendLeaveGroupRequest">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendLeaveGroupRequest
            <span class="apidocSignatureSpan">(groupId, memberId, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendOffsetCommitRequest">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendOffsetCommitRequest
            <span class="apidocSignatureSpan">(group, payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendOffsetCommitV2Request">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendOffsetCommitV2Request
            <span class="apidocSignatureSpan">(group, generationId, memberId, payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendOffsetFetchRequest">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendOffsetFetchRequest
            <span class="apidocSignatureSpan">(group, payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendOffsetFetchV1Request">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendOffsetFetchV1Request
            <span class="apidocSignatureSpan">(group, payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendOffsetRequest">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendOffsetRequest
            <span class="apidocSignatureSpan">(payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendProduceRequest">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendProduceRequest
            <span class="apidocSignatureSpan">(payloads, requireAcks, ackTimeoutMs, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendSyncGroupRequest">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendSyncGroupRequest
            <span class="apidocSignatureSpan">(groupId, generationId, memberId, groupAssignment, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.sendToBroker">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendToBroker
            <span class="apidocSignatureSpan">(payloads, encoder, decoder, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.setupBroker">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>setupBroker
            <span class="apidocSignatureSpan">(host, port, longpolling, brokers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.setupBrokerProfiles">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>setupBrokerProfiles
            <span class="apidocSignatureSpan">(brokers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.topicExists">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>topicExists
            <span class="apidocSignatureSpan">(topics, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.unqueueCallback">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>unqueueCallback
            <span class="apidocSignatureSpan">(socket, id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Client.prototype.updateMetadatas">
            function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>updateMetadatas
            <span class="apidocSignatureSpan">(metadatas)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Consumer">module kafka-node.Consumer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.Consumer">
            function <span class="apidocSignatureSpan">kafka-node.</span>Consumer
            <span class="apidocSignatureSpan">(client, topics, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.super_">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Consumer.prototype">module kafka-node.Consumer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.addTopics">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>addTopics
            <span class="apidocSignatureSpan">(topics, cb, fromOffset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.autoCommit">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>autoCommit
            <span class="apidocSignatureSpan">(force, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.buildPayloads">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>buildPayloads
            <span class="apidocSignatureSpan">(payloads)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.close">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>close
            <span class="apidocSignatureSpan">(force, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.commit">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>commit
            <span class="apidocSignatureSpan">(force, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.connect">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>connect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.fetch">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>fetch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.fetchOffset">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>fetchOffset
            <span class="apidocSignatureSpan">(payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.init">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>init
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.pause">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>pause
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.pauseTopics">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>pauseTopics
            <span class="apidocSignatureSpan">(topics)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.removeTopics">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>removeTopics
            <span class="apidocSignatureSpan">(topics, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.resume">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>resume
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.resumeTopics">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>resumeTopics
            <span class="apidocSignatureSpan">(topics)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.setOffset">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>setOffset
            <span class="apidocSignatureSpan">(topic, partition, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Consumer.prototype.updateOffsets">
            function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>updateOffsets
            <span class="apidocSignatureSpan">(topics, initing)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.ConsumerGroup">module kafka-node.ConsumerGroup</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.ConsumerGroup">
            function <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup
            <span class="apidocSignatureSpan">(memberOptions, topics)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.super_">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.</span>super_
            <span class="apidocSignatureSpan">(client, topics, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.ConsumerGroup.prototype">module kafka-node.ConsumerGroup.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.assignPartitions">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>assignPartitions
            <span class="apidocSignatureSpan">(protocol, groupMembers, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.close">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>close
            <span class="apidocSignatureSpan">(force, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.connect">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>connect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.fetchOffset">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>fetchOffset
            <span class="apidocSignatureSpan">(payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.getDefaultOffset">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>getDefaultOffset
            <span class="apidocSignatureSpan">(tp, defaultOffset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.getOffset">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>getOffset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.handleJoinGroup">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>handleJoinGroup
            <span class="apidocSignatureSpan">(joinGroupResponse, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.handleSyncGroup">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>handleSyncGroup
            <span class="apidocSignatureSpan">(syncGroupResponse, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.leaveGroup">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>leaveGroup
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.saveDefaultOffsets">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>saveDefaultOffsets
            <span class="apidocSignatureSpan">(topicPartitionList, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.scheduleReconnect">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>scheduleReconnect
            <span class="apidocSignatureSpan">(timeout)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.sendHeartbeat">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>sendHeartbeat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.sendOffsetCommitRequest">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>sendOffsetCommitRequest
            <span class="apidocSignatureSpan">(commits, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.setCoordinatorId">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>setCoordinatorId
            <span class="apidocSignatureSpan">(coordinatorId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.setupProtocols">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>setupProtocols
            <span class="apidocSignatureSpan">(protocols)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.startHeartbeats">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>startHeartbeats
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.ConsumerGroup.prototype.stopHeartbeats">
            function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>stopHeartbeats
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.CustomPartitioner">module kafka-node.CustomPartitioner</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.CustomPartitioner.CustomPartitioner">
            function <span class="apidocSignatureSpan">kafka-node.</span>CustomPartitioner
            <span class="apidocSignatureSpan">(partitioner)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.CustomPartitioner.super_">
            function <span class="apidocSignatureSpan">kafka-node.CustomPartitioner.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.CyclicPartitioner">module kafka-node.CyclicPartitioner</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.CyclicPartitioner.CyclicPartitioner">
            function <span class="apidocSignatureSpan">kafka-node.</span>CyclicPartitioner
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.CyclicPartitioner.super_">
            function <span class="apidocSignatureSpan">kafka-node.CyclicPartitioner.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.CyclicPartitioner.prototype">module kafka-node.CyclicPartitioner.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.CyclicPartitioner.prototype.getPartition">
            function <span class="apidocSignatureSpan">kafka-node.CyclicPartitioner.prototype.</span>getPartition
            <span class="apidocSignatureSpan">(partitions)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.DefaultPartitioner">module kafka-node.DefaultPartitioner</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.DefaultPartitioner.DefaultPartitioner">
            function <span class="apidocSignatureSpan">kafka-node.</span>DefaultPartitioner
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.DefaultPartitioner.super_">
            function <span class="apidocSignatureSpan">kafka-node.DefaultPartitioner.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.DefaultPartitioner.prototype">module kafka-node.DefaultPartitioner.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.DefaultPartitioner.prototype.getPartition">
            function <span class="apidocSignatureSpan">kafka-node.DefaultPartitioner.prototype.</span>getPartition
            <span class="apidocSignatureSpan">(partitions)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.FailedToRebalanceConsumerError">module kafka-node.FailedToRebalanceConsumerError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.FailedToRebalanceConsumerError.FailedToRebalanceConsumerError">
            function <span class="apidocSignatureSpan">kafka-node.</span>FailedToRebalanceConsumerError
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.FailedToRebalanceConsumerError.super_">
            function <span class="apidocSignatureSpan">kafka-node.FailedToRebalanceConsumerError.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.FailedToRegisterConsumerError">module kafka-node.FailedToRegisterConsumerError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.FailedToRegisterConsumerError.FailedToRegisterConsumerError">
            function <span class="apidocSignatureSpan">kafka-node.</span>FailedToRegisterConsumerError
            <span class="apidocSignatureSpan">(message, nested)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.FailedToRegisterConsumerError.super_">
            function <span class="apidocSignatureSpan">kafka-node.FailedToRegisterConsumerError.</span>super_
            <span class="apidocSignatureSpan">(message, nested)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.GroupCoordinatorNotAvailableError">module kafka-node.GroupCoordinatorNotAvailableError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.GroupCoordinatorNotAvailableError.GroupCoordinatorNotAvailableError">
            function <span class="apidocSignatureSpan">kafka-node.</span>GroupCoordinatorNotAvailableError
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.GroupCoordinatorNotAvailableError.super_">
            function <span class="apidocSignatureSpan">kafka-node.GroupCoordinatorNotAvailableError.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.GroupLoadInProgressError">module kafka-node.GroupLoadInProgressError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.GroupLoadInProgressError.GroupLoadInProgressError">
            function <span class="apidocSignatureSpan">kafka-node.</span>GroupLoadInProgressError
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.GroupLoadInProgressError.super_">
            function <span class="apidocSignatureSpan">kafka-node.GroupLoadInProgressError.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.HeartbeatTimeoutError">module kafka-node.HeartbeatTimeoutError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HeartbeatTimeoutError.HeartbeatTimeoutError">
            function <span class="apidocSignatureSpan">kafka-node.</span>HeartbeatTimeoutError
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HeartbeatTimeoutError.super_">
            function <span class="apidocSignatureSpan">kafka-node.HeartbeatTimeoutError.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.HighLevelConsumer">module kafka-node.HighLevelConsumer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.HighLevelConsumer">
            function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer
            <span class="apidocSignatureSpan">(client, topics, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.super_">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype">module kafka-node.HighLevelConsumer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype._releasePartitions">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>_releasePartitions
            <span class="apidocSignatureSpan">(topicPayloads, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.addTopics">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>addTopics
            <span class="apidocSignatureSpan">(topics, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.autoCommit">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>autoCommit
            <span class="apidocSignatureSpan">(force, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.buildPayloads">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>buildPayloads
            <span class="apidocSignatureSpan">(payloads)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.buildTopicPayloads">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>buildTopicPayloads
            <span class="apidocSignatureSpan">(topics)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.close">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>close
            <span class="apidocSignatureSpan">(force, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.commit">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>commit
            <span class="apidocSignatureSpan">(force, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.connect">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>connect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.fetch">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>fetch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.fetchOffset">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>fetchOffset
            <span class="apidocSignatureSpan">(payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.getTopicPayloads">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>getTopicPayloads
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.init">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>init
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.leaveGroup">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>leaveGroup
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.offsetRequest">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>offsetRequest
            <span class="apidocSignatureSpan">(payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.pause">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>pause
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.rebalanceAttempt">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>rebalanceAttempt
            <span class="apidocSignatureSpan">(oldTopicPayloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.registerConsumer">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>registerConsumer
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.removeTopics">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>removeTopics
            <span class="apidocSignatureSpan">(topics, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.resume">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>resume
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.sendOffsetCommitRequest">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>sendOffsetCommitRequest
            <span class="apidocSignatureSpan">(commits, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.setOffset">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>setOffset
            <span class="apidocSignatureSpan">(topic, partition, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.stop">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>stop
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.updateOffsets">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>updateOffsets
            <span class="apidocSignatureSpan">(topics, initing)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.HighLevelProducer">module kafka-node.HighLevelProducer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelProducer.HighLevelProducer">
            function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelProducer
            <span class="apidocSignatureSpan">(client, options, customPartitioner)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelProducer.super_">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.</span>super_
            <span class="apidocSignatureSpan">(client, options, defaultPartitionerType, customPartitioner)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.</span>PARTITIONER_TYPES</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.HighLevelProducer.super_">module kafka-node.HighLevelProducer.super_</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelProducer.super_.super_">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.super_.</span>PARTITIONER_TYPES</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.HighLevelProducer.super_.prototype">module kafka-node.HighLevelProducer.super_.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.buildPayloads">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.super_.prototype.</span>buildPayloads
            <span class="apidocSignatureSpan">(payloads, topicMetadata)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.close">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.super_.prototype.</span>close
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.connect">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.super_.prototype.</span>connect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.createTopics">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.super_.prototype.</span>createTopics
            <span class="apidocSignatureSpan">(topics, async, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.send">
            function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.super_.prototype.</span>send
            <span class="apidocSignatureSpan">(payloads, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.IllegalGenerationError">module kafka-node.IllegalGenerationError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.IllegalGenerationError.IllegalGenerationError">
            function <span class="apidocSignatureSpan">kafka-node.</span>IllegalGenerationError
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.IllegalGenerationError.super_">
            function <span class="apidocSignatureSpan">kafka-node.IllegalGenerationError.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.InvalidConfigError">module kafka-node.InvalidConfigError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.InvalidConfigError.InvalidConfigError">
            function <span class="apidocSignatureSpan">kafka-node.</span>InvalidConfigError
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.InvalidConfigError.super_">
            function <span class="apidocSignatureSpan">kafka-node.InvalidConfigError.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.InvalidConsumerOffsetError">module kafka-node.InvalidConsumerOffsetError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.InvalidConsumerOffsetError.InvalidConsumerOffsetError">
            function <span class="apidocSignatureSpan">kafka-node.</span>InvalidConsumerOffsetError
            <span class="apidocSignatureSpan">(message, nested)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.InvalidConsumerOffsetError.super_">
            function <span class="apidocSignatureSpan">kafka-node.InvalidConsumerOffsetError.</span>super_
            <span class="apidocSignatureSpan">(message, nested)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.KafkaBuffer">module kafka-node.KafkaBuffer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.KafkaBuffer.KafkaBuffer">
            function <span class="apidocSignatureSpan">kafka-node.</span>KafkaBuffer
            <span class="apidocSignatureSpan">(batchSize, batchAge)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.KafkaBuffer.prototype">module kafka-node.KafkaBuffer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.KafkaBuffer.prototype._setupTimer">
            function <span class="apidocSignatureSpan">kafka-node.KafkaBuffer.prototype.</span>_setupTimer
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.KafkaBuffer.prototype.addChunk">
            function <span class="apidocSignatureSpan">kafka-node.KafkaBuffer.prototype.</span>addChunk
            <span class="apidocSignatureSpan">(buffer, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.KafkaBuffer.prototype.getBatch">
            function <span class="apidocSignatureSpan">kafka-node.KafkaBuffer.prototype.</span>getBatch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.KafkaBuffer.prototype.truncateBatch">
            function <span class="apidocSignatureSpan">kafka-node.KafkaBuffer.prototype.</span>truncateBatch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.KeyedPartitioner">module kafka-node.KeyedPartitioner</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.KeyedPartitioner.KeyedPartitioner">
            function <span class="apidocSignatureSpan">kafka-node.</span>KeyedPartitioner
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.KeyedPartitioner.super_">
            function <span class="apidocSignatureSpan">kafka-node.KeyedPartitioner.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.KeyedPartitioner.prototype">module kafka-node.KeyedPartitioner.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.KeyedPartitioner.prototype.getPartition">
            function <span class="apidocSignatureSpan">kafka-node.KeyedPartitioner.prototype.</span>getPartition
            <span class="apidocSignatureSpan">(partitions, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.KeyedPartitioner.prototype.hashCode">
            function <span class="apidocSignatureSpan">kafka-node.KeyedPartitioner.prototype.</span>hashCode
            <span class="apidocSignatureSpan">(string)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.NotCoordinatorForGroupError">module kafka-node.NotCoordinatorForGroupError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.NotCoordinatorForGroupError.NotCoordinatorForGroupError">
            function <span class="apidocSignatureSpan">kafka-node.</span>NotCoordinatorForGroupError
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.NotCoordinatorForGroupError.super_">
            function <span class="apidocSignatureSpan">kafka-node.NotCoordinatorForGroupError.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Offset">module kafka-node.Offset</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Offset.Offset">
            function <span class="apidocSignatureSpan">kafka-node.</span>Offset
            <span class="apidocSignatureSpan">(client)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Offset.super_">
            function <span class="apidocSignatureSpan">kafka-node.Offset.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Offset.prototype">module kafka-node.Offset.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Offset.prototype.buildPayloads">
            function <span class="apidocSignatureSpan">kafka-node.Offset.prototype.</span>buildPayloads
            <span class="apidocSignatureSpan">(payloads)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Offset.prototype.commit">
            function <span class="apidocSignatureSpan">kafka-node.Offset.prototype.</span>commit
            <span class="apidocSignatureSpan">(groupId, payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Offset.prototype.fetch">
            function <span class="apidocSignatureSpan">kafka-node.Offset.prototype.</span>fetch
            <span class="apidocSignatureSpan">(payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Offset.prototype.fetchCommits">
            function <span class="apidocSignatureSpan">kafka-node.Offset.prototype.</span>fetchCommits
            <span class="apidocSignatureSpan">(groupId, payloads, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Offset.prototype.fetchEarliestOffsets">
            function <span class="apidocSignatureSpan">kafka-node.Offset.prototype.</span>fetchEarliestOffsets
            <span class="apidocSignatureSpan">(topics, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Offset.prototype.fetchLatestOffsets">
            function <span class="apidocSignatureSpan">kafka-node.Offset.prototype.</span>fetchLatestOffsets
            <span class="apidocSignatureSpan">(topics, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.Producer">module kafka-node.Producer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Producer.Producer">
            function <span class="apidocSignatureSpan">kafka-node.</span>Producer
            <span class="apidocSignatureSpan">(client, options, customPartitioner)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.Producer.super_">
            function <span class="apidocSignatureSpan">kafka-node.Producer.</span>super_
            <span class="apidocSignatureSpan">(client, options, defaultPartitionerType, customPartitioner)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.Producer.</span>PARTITIONER_TYPES</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.RandomPartitioner">module kafka-node.RandomPartitioner</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.RandomPartitioner.RandomPartitioner">
            function <span class="apidocSignatureSpan">kafka-node.</span>RandomPartitioner
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.RandomPartitioner.super_">
            function <span class="apidocSignatureSpan">kafka-node.RandomPartitioner.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.RandomPartitioner.prototype">module kafka-node.RandomPartitioner.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.RandomPartitioner.prototype.getPartition">
            function <span class="apidocSignatureSpan">kafka-node.RandomPartitioner.prototype.</span>getPartition
            <span class="apidocSignatureSpan">(partitions)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.RebalanceInProgressError">module kafka-node.RebalanceInProgressError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.RebalanceInProgressError.RebalanceInProgressError">
            function <span class="apidocSignatureSpan">kafka-node.</span>RebalanceInProgressError
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.RebalanceInProgressError.super_">
            function <span class="apidocSignatureSpan">kafka-node.RebalanceInProgressError.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.TopicsNotExistError">module kafka-node.TopicsNotExistError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.TopicsNotExistError.TopicsNotExistError">
            function <span class="apidocSignatureSpan">kafka-node.</span>TopicsNotExistError
            <span class="apidocSignatureSpan">(topics)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.TopicsNotExistError.super_">
            function <span class="apidocSignatureSpan">kafka-node.TopicsNotExistError.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.UnknownMemberIdError">module kafka-node.UnknownMemberIdError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.UnknownMemberIdError.UnknownMemberIdError">
            function <span class="apidocSignatureSpan">kafka-node.</span>UnknownMemberIdError
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.UnknownMemberIdError.super_">
            function <span class="apidocSignatureSpan">kafka-node.UnknownMemberIdError.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.consumerGroupMigrator">module kafka-node.consumerGroupMigrator</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.consumerGroupMigrator.consumerGroupMigrator">
            function <span class="apidocSignatureSpan">kafka-node.</span>consumerGroupMigrator
            <span class="apidocSignatureSpan">(consumerGroup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.consumerGroupMigrator.super_">
            function <span class="apidocSignatureSpan">kafka-node.consumerGroupMigrator.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.consumerGroupMigrator.prototype">module kafka-node.consumerGroupMigrator.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.consumerGroupMigrator.prototype.checkForOwners">
            function <span class="apidocSignatureSpan">kafka-node.consumerGroupMigrator.prototype.</span>checkForOwners
            <span class="apidocSignatureSpan">(topics, listenForChange)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.consumerGroupMigrator.prototype.checkForOwnersAndListenForChange">
            function <span class="apidocSignatureSpan">kafka-node.consumerGroupMigrator.prototype.</span>checkForOwnersAndListenForChange
            <span class="apidocSignatureSpan">(topics)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.consumerGroupMigrator.prototype.connectConsumerGroup">
            function <span class="apidocSignatureSpan">kafka-node.consumerGroupMigrator.prototype.</span>connectConsumerGroup
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.consumerGroupMigrator.prototype.filterByExistingZkTopics">
            function <span class="apidocSignatureSpan">kafka-node.consumerGroupMigrator.prototype.</span>filterByExistingZkTopics
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.consumerGroupMigrator.prototype.getOffset">
            function <span class="apidocSignatureSpan">kafka-node.consumerGroupMigrator.prototype.</span>getOffset
            <span class="apidocSignatureSpan">(tp, defaultOffset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.consumerGroupMigrator.prototype.saveHighLevelConsumerOffsets">
            function <span class="apidocSignatureSpan">kafka-node.consumerGroupMigrator.prototype.</span>saveHighLevelConsumerOffsets
            <span class="apidocSignatureSpan">(topicPartitionList, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.consumerGroupRecovery">module kafka-node.consumerGroupRecovery</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.consumerGroupRecovery.consumerGroupRecovery">
            function <span class="apidocSignatureSpan">kafka-node.</span>consumerGroupRecovery
            <span class="apidocSignatureSpan">(consumerGroup)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.consumerGroupRecovery.prototype">module kafka-node.consumerGroupRecovery.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.consumerGroupRecovery.prototype.clearError">
            function <span class="apidocSignatureSpan">kafka-node.consumerGroupRecovery.prototype.</span>clearError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.consumerGroupRecovery.prototype.getRetryTimeout">
            function <span class="apidocSignatureSpan">kafka-node.consumerGroupRecovery.prototype.</span>getRetryTimeout
            <span class="apidocSignatureSpan">(error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.consumerGroupRecovery.prototype.tryToRecoverFrom">
            function <span class="apidocSignatureSpan">kafka-node.consumerGroupRecovery.prototype.</span>tryToRecoverFrom
            <span class="apidocSignatureSpan">(error, source)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.logging">module kafka-node.logging</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.logging.setLoggerProvider">
            function <span class="apidocSignatureSpan">kafka-node.logging.</span>setLoggerProvider
            <span class="apidocSignatureSpan">(provider)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.partitioner">module kafka-node.partitioner</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.partitioner.CustomPartitioner">
            function <span class="apidocSignatureSpan">kafka-node.partitioner.</span>CustomPartitioner
            <span class="apidocSignatureSpan">(partitioner)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.partitioner.CyclicPartitioner">
            function <span class="apidocSignatureSpan">kafka-node.partitioner.</span>CyclicPartitioner
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.partitioner.DefaultPartitioner">
            function <span class="apidocSignatureSpan">kafka-node.partitioner.</span>DefaultPartitioner
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.partitioner.KeyedPartitioner">
            function <span class="apidocSignatureSpan">kafka-node.partitioner.</span>KeyedPartitioner
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.partitioner.RandomPartitioner">
            function <span class="apidocSignatureSpan">kafka-node.partitioner.</span>RandomPartitioner
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.protocol">module kafka-node.protocol</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.protocol.decodeFetchResponse">
            function <span class="apidocSignatureSpan">kafka-node.protocol.</span>decodeFetchResponse
            <span class="apidocSignatureSpan">(cb, maxTickMessages)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.protocol.decodeGroupCoordinatorResponse">
            function <span class="apidocSignatureSpan">kafka-node.protocol.</span>decodeGroupCoordinatorResponse
            <span class="apidocSignatureSpan">(resp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.protocol.decodeGroupHeartbeat">
            function <span class="apidocSignatureSpan">kafka-node.protocol.</span>decodeGroupHeartbeat
            <span class="apidocSignatureSpan">(resp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.protocol.decodeJoinGroupResponse">
            function <span class="apidocSignatureSpan">kafka-node.protocol.</span>decodeJoinGroupResponse
            <span class="apidocSignatureSpan">(resp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.protocol.decodeLeaveGroupResponse">
            function <span class="apidocSignatureSpan">kafka-node.protocol.</span>decodeLeaveGroupResponse
            <span class="apidocSignatureSpan">(resp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.protocol.decodeMetadataResponse">
            function <span class="apidocSignatureSpan">kafka-node.protocol.</span>decodeMetadataResponse
            <span class="apidocSignatureSpan">(resp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.protocol.decodeOffsetCommitResponse">
            function <span class="apidocSignatureSpan">kafka-node.protocol.</span>decodeOffsetCommitResponse
            <span class="apidocSignatureSpan">(resp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.protocol.decodeOffsetFetchResponse">
            function <span class="apidocSignatureSpan">kafka-node.protocol.</span>decodeOffsetFetchResponse
            <span class="apidocSignatureSpan">(resp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.protocol.decodeOffsetFetchV1Response">
            function <span class="apidocSignatureSpan">kafka-node.protocol.</span>decodeOffsetFetchV1Response
            <span class="apidocSignatureSpan">(resp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.protocol.decodeOffsetResponse">
            function <span class="apidocSignatureSpan">kafka-node.protocol.</span>decodeOffsetResponse
            <span class="apidocSignatureSpan">(resp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.protocol.decodeProduceResponse">
            function <span class="apidocSignatureSpan">kafka-node.protocol.</span>decodeProduceResponse
            <span class="apidocSignatureSpan">(resp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.protocol.decodeSyncGroupResponse">
            function <span class="apidocSignatureSpan">kafka-node.protocol.</span>decodeSyncGroupResponse
            <span class="apidocSignatureSpan">(resp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.protocol.encodeFetchRequest">
            function <span class="apidocSignatureSpan">kafka-node.protocol.</span>encodeFetchRequest
            <span class="apidocSignatureSpan">(maxWaitMs, minBytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.protocol.encodeGroupCoordinatorRequest">
            function <span class="apidocSignatureSpan">kafka-node.protocol.</span>encodeGroupCoordinatorRequest
            <span class="apidocSignatureSpan">(clientId, correlationId, groupId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.protocol.encodeGroupHeartbeat">
            function <span class="apidocSignatureSpan">kafka-node.protocol.</span>encodeGroupHeartbeat
            <span class="apidocSignatureSpan">(clientId, correlationId, groupId, generationId, memberId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.protocol.encodeJoinGroupRequest">
            function <span class="apidocSignatureSpan">kafka-node.protocol.</span>encodeJoinGroupRequest
            <span class="apidocSignatureSpan">(clientId, correlationId, groupId, memberId, sessionTimeout, groupProtocols)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.protocol.encodeLeaveGroupRequest">
            function <span class="apidocSignatureSpan">kafka-node.protocol.</span>encodeLeaveGroupRequest
            <span class="apidocSignatureSpan">(clientId, correlationId, groupId, memberId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.protocol.encodeMessageSet">
            function <span class="apidocSignatureSpan">kafka-node.protocol.</span>encodeMessageSet
            <span class="apidocSignatureSpan">(messageSet)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.protocol.encodeMetadataRequest">
            function <span class="apidocSignatureSpan">kafka-node.protocol.</span>encodeMetadataRequest
            <span class="apidocSignatureSpan">(clientId, correlationId, topics)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.protocol.encodeOffsetCommitRequest">
            function <span class="apidocSignatureSpan">kafka-node.protocol.</span>encodeOffsetCommitRequest
            <span class="apidocSignatureSpan">(group)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.protocol.encodeOffsetCommitV2Request">
            function <span class="apidocSignatureSpan">kafka-node.protocol.</span>encodeOffsetCommitV2Request
            <span class="apidocSignatureSpan">(clientId, correlationId, group, generationId, memberId, payloads)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.protocol.encodeOffsetFetchRequest">
            function <span class="apidocSignatureSpan">kafka-node.protocol.</span>encodeOffsetFetchRequest
            <span class="apidocSignatureSpan">(group)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.protocol.encodeOffsetFetchV1Request">
            function <span class="apidocSignatureSpan">kafka-node.protocol.</span>encodeOffsetFetchV1Request
            <span class="apidocSignatureSpan">(clientId, correlationId, group, payloads)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.protocol.encodeOffsetRequest">
            function <span class="apidocSignatureSpan">kafka-node.protocol.</span>encodeOffsetRequest
            <span class="apidocSignatureSpan">(clientId, correlationId, payloads)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.protocol.encodeProduceRequest">
            function <span class="apidocSignatureSpan">kafka-node.protocol.</span>encodeProduceRequest
            <span class="apidocSignatureSpan">(requireAcks, ackTimeoutMs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.protocol.encodeSyncGroupRequest">
            function <span class="apidocSignatureSpan">kafka-node.protocol.</span>encodeSyncGroupRequest
            <span class="apidocSignatureSpan">(clientId, correlationId, groupId, generationId, memberId, groupAssignment)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.protocol_struct">module kafka-node.protocol_struct</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.protocol_struct.FetchRequest">
            function <span class="apidocSignatureSpan">kafka-node.protocol_struct.</span>FetchRequest
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.protocol_struct.FetchResponse">
            function <span class="apidocSignatureSpan">kafka-node.protocol_struct.</span>FetchResponse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.protocol_struct.KeyedMessage">
            function <span class="apidocSignatureSpan">kafka-node.protocol_struct.</span>KeyedMessage
            <span class="apidocSignatureSpan">(key, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.protocol_struct.Message">
            function <span class="apidocSignatureSpan">kafka-node.protocol_struct.</span>Message
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.protocol_struct.OffsetCommitRequest">
            function <span class="apidocSignatureSpan">kafka-node.protocol_struct.</span>OffsetCommitRequest
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.protocol_struct.OffsetCommitResponse">
            function <span class="apidocSignatureSpan">kafka-node.protocol_struct.</span>OffsetCommitResponse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.protocol_struct.PartitionMetadata">
            function <span class="apidocSignatureSpan">kafka-node.protocol_struct.</span>PartitionMetadata
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.protocol_struct.ProduceRequest">
            function <span class="apidocSignatureSpan">kafka-node.protocol_struct.</span>ProduceRequest
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.protocol_struct.Request">
            function <span class="apidocSignatureSpan">kafka-node.protocol_struct.</span>Request
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.protocol_struct.TopicAndPartition">
            function <span class="apidocSignatureSpan">kafka-node.protocol_struct.</span>TopicAndPartition
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.protocol_struct.</span>ERROR_CODE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.protocol_struct.</span>GROUP_ERROR</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.protocol_struct.</span>KEYS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">kafka-node.protocol_struct.</span>REQUEST_TYPE</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.range">module kafka-node.range</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.range.assign">
            function <span class="apidocSignatureSpan">kafka-node.range.</span>assign
            <span class="apidocSignatureSpan">(topicPartition, groupMembers, callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kafka-node.range.</span>version</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">kafka-node.range.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.roundrobin">module kafka-node.roundrobin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.roundrobin.assign">
            function <span class="apidocSignatureSpan">kafka-node.roundrobin.</span>assign
            <span class="apidocSignatureSpan">(topicPartition, groupMembers, callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">kafka-node.roundrobin.</span>version</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">kafka-node.roundrobin.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.snappy">module kafka-node.snappy</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.snappy.decode">
            function <span class="apidocSignatureSpan">kafka-node.snappy.</span>decode
            <span class="apidocSignatureSpan">(buffer, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.snappy.encode">
            function <span class="apidocSignatureSpan">kafka-node.snappy.</span>encode
            <span class="apidocSignatureSpan">(input, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.utils">module kafka-node.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.utils.createTopicPartitionList">
            function <span class="apidocSignatureSpan">kafka-node.utils.</span>createTopicPartitionList
            <span class="apidocSignatureSpan">(topicPartitions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.utils.groupPartitionsByTopic">
            function <span class="apidocSignatureSpan">kafka-node.utils.</span>groupPartitionsByTopic
            <span class="apidocSignatureSpan">(topicPartitions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.utils.validateConfig">
            function <span class="apidocSignatureSpan">kafka-node.utils.</span>validateConfig
            <span class="apidocSignatureSpan">(property, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.utils.validateTopicNames">
            function <span class="apidocSignatureSpan">kafka-node.utils.</span>validateTopicNames
            <span class="apidocSignatureSpan">(topics)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.utils.validateTopics">
            function <span class="apidocSignatureSpan">kafka-node.utils.</span>validateTopics
            <span class="apidocSignatureSpan">(topics)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.kafka-node.zookeeper">module kafka-node.zookeeper</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.zookeeper.Zookeeper">
            function <span class="apidocSignatureSpan">kafka-node.zookeeper.</span>Zookeeper
            <span class="apidocSignatureSpan">(connectionString, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.kafka-node.zookeeper.ZookeeperConsumerMappings">
            function <span class="apidocSignatureSpan">kafka-node.zookeeper.</span>ZookeeperConsumerMappings
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node" id="apidoc.module.kafka-node">module kafka-node</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.BrokerNotAvailableError" id="apidoc.element.kafka-node.BrokerNotAvailableError">
        function <span class="apidocSignatureSpan">kafka-node.</span>BrokerNotAvailableError
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BrokerNotAvailableError = function (message) {
  Error.captureStackTrace(this, this);
  this.message = message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  requestArgs.unshift(this.clientId, correlationId);

  var request = encode.apply(null, requestArgs);
  var broker = this.brokerForLeader(this.coordinatorId);

  if (!broker || !broker.socket || broker.socket.error || broker.socket.destroyed) {
    return cb(new errors.<span class="apidocCodeKeywordSpan">BrokerNotAvailableError</span>(&#x27;Broker not available&#x27;));
  }

  this.queueCallback(broker.socket, correlationId, [decode, cb]);
  broker.write(request);
};

Client.prototype.sendGroupCoordinatorRequest = function (groupId, cb) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.BrokerReadable" id="apidoc.element.kafka-node.BrokerReadable">
        function <span class="apidocSignatureSpan">kafka-node.</span>BrokerReadable
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BrokerReadable = function (options) {
  Readable.call(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.BrokerTransform" id="apidoc.element.kafka-node.BrokerTransform">
        function <span class="apidocSignatureSpan">kafka-node.</span>BrokerTransform
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BrokerTransform = function (options) {
  Transform.call(this, options);
  this.noAckBatchSize = options ? options.noAckBatchSize : null;
  this.noAckBatchAge = options ? options.noAckBatchAge : null;
  this._KafkaBuffer = new KafkaBuffer(this.noAckBatchSize, this.noAckBatchAge);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.BrokerWrapper" id="apidoc.element.kafka-node.BrokerWrapper">
        function <span class="apidocSignatureSpan">kafka-node.</span>BrokerWrapper
        <span class="apidocSignatureSpan">(socket, noAckBatchOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BrokerWrapper = function (socket, noAckBatchOptions) {
  this.socket = socket;

  var self = this;
  var readable = new BrokerReadable();
  var transform = new BrokerTransform(noAckBatchOptions);

  readable.pipe(transform);

  transform.on(&#x27;readable&#x27;, function () {
    var bulkMessage = null;
    while (bulkMessage = transform.read()) { // eslint-disable-line no-cond-assign
      self.socket.write(bulkMessage);
    }
  });

  this.readableSocket = readable;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client" id="apidoc.element.kafka-node.Client">
        function <span class="apidocSignatureSpan">kafka-node.</span>Client
        <span class="apidocSignatureSpan">(connectionString, clientId, zkOptions, noAckBatchOptions, sslOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client = function (connectionString, clientId, zkOptions, noAckBatchOptions, sslOptions) {
  if (this instanceof Client === false) {
    return new Client(connectionString, clientId, zkOptions, noAckBatchOptions, sslOptions);
  }

  this.sslOptions = sslOptions;
  this.ssl = !!sslOptions;

  if (clientId) {
    validateConfig(&#x27;clientId&#x27;, clientId);
  }

  this.connectionString = connectionString || &#x27;localhost:2181/&#x27;;
  this.clientId = clientId || &#x27;kafka-node-client&#x27;;
  this.zkOptions = zkOptions;
  this.noAckBatchOptions = noAckBatchOptions;
  this.brokers = {};
  this.longpollingBrokers = {};
  this.topicMetadata = {};
  this.topicPartitions = {};
  this.correlationId = 0;
  this._socketId = 0;
  this.cbqueue = {};
  this.brokerMetadata = {};
  this.ready = false;
  this.connect();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    partitionerType: 2
}
```

``` js
var kafka = require(&#x27;kafka-node&#x27;),
    Producer = kafka.Producer,
    client = new kafka.<span class="apidocCodeKeywordSpan">Client</span>(),
    producer = new Producer(client);
```

### Events

- `ready`: this event is emitted when producer is ready to send messages.
- `error`: this is the error event propagates from internal client, producer should always listen it.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer" id="apidoc.element.kafka-node.Consumer">
        function <span class="apidocSignatureSpan">kafka-node.</span>Consumer
        <span class="apidocSignatureSpan">(client, topics, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Consumer = function (client, topics, options) {
  if (!topics) {
    throw new Error(&#x27;Must have payloads&#x27;);
  }

  utils.validateTopics(topics);

  this.fetchCount = 0;
  this.client = client;
  this.options = _.defaults((options || {}), DEFAULTS);
  this.ready = false;
  this.paused = this.options.paused;
  this.id = nextId();
  this.payloads = this.buildPayloads(topics);
  this.connect();
  this.encoding = this.options.encoding;

  if (this.options.groupId) {
    utils.validateConfig(&#x27;options.groupId&#x27;, this.options.groupId);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup" id="apidoc.element.kafka-node.ConsumerGroup">
        function <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup
        <span class="apidocSignatureSpan">(memberOptions, topics)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ConsumerGroup(memberOptions, topics) {
  EventEmitter.call(this);
  const self = this;
  this.options = _.defaults((memberOptions || {}), DEFAULTS);

  if (!this.options.heartbeatInterval) {
    this.options.heartbeatInterval = Math.floor(this.options.sessionTimeout / 3);
  }

  if (memberOptions.ssl === true) {
    memberOptions.ssl = {};
  }

  if (!(this.options.fromOffset in ACCEPTED_FROM_OFFSET)) {
    throw new Error(`fromOffset ${this.options.fromOffset} should be either: ${Object.keys(ACCEPTED_FROM_OFFSET).join(&#x27;, &#x27;)}`);
  }

  if (!(this.options.outOfRangeOffset in ACCEPTED_FROM_OFFSET)) {
    throw new Error(`outOfRangeOffset ${this.options.outOfRangeOffset} should be either: ${Object.keys(ACCEPTED_FROM_OFFSET).join
(&#x27;, &#x27;)}`);
  }

  this.client = new Client(memberOptions.host, memberOptions.id, memberOptions.zk,
    memberOptions.batch, memberOptions.ssl);

  if (_.isString(topics)) {
    topics = [topics];
  }

  assert(Array.isArray(topics), &#x27;Array of topics is required&#x27;);

  this.topics = topics;

  this.recovery = new ConsumerGroupRecovery(this);

  this.setupProtocols(this.options.protocol);

  if (this.options.connectOnReady &#x26;&#x26; !this.options.migrateHLC) {
    this.client.once(&#x27;ready&#x27;, this.connect.bind(this));
  }

  if (this.options.migrateHLC) {
    const ConsumerGroupMigrator = require(&#x27;./consumerGroupMigrator&#x27;);
    this.migrator = new ConsumerGroupMigrator(this);
    this.migrator.on(&#x27;error&#x27;, function (error) {
      self.emit(&#x27;error&#x27;, error);
    });
  }

  this.client.on(&#x27;error&#x27;, function (err) {
    logger.error(&#x27;Error from %s&#x27;, self.client.clientId, err);
    self.emit(&#x27;error&#x27;, err);
  });

  const recoverFromBrokerChange = _.debounce(function () {
    logger.debug(&#x27;brokersChanged refreshing metadata&#x27;);
    self.client.refreshMetadata(self.topics, function (error) {
      if (error) {
        self.emit(error);
        return;
      }
      self.paused = false;
      if (!self.ready &#x26;&#x26; !self.connecting) {
        if (self.reconnectTimer) {
          // brokers changed so bypass backoff retry and reconnect now
          clearTimeout(self.reconnectTimer);
          self.reconnectTimer = null;
        }
        self.connect();
      } else if (!self.connecting) {
        self.fetch();
      }
    });
  }, 200);

  this.client.on(&#x27;brokersChanged&#x27;, function () {
    self.pause();
    recoverFromBrokerChange();
  });

  this.client.on(&#x27;reconnect&#x27;, function (lastError) {
    self.fetch();
  });

  this.on(&#x27;offsetOutOfRange&#x27;, topic =&#x3e; {
    this.pause();
    if (this.options.outOfRangeOffset === &#x27;none&#x27;) {
      this.emit(&#x27;error&#x27;, new errors.InvalidConsumerOffsetError(`Offset out of range for topic &#x22;${topic.topic}&#x22; partition ${topic
.partition}`));
      return;
    }

    topic.time = ACCEPTED_FROM_OFFSET[this.options.outOfRangeOffset];

    this.getOffset().fetch([topic], (error, result) =&#x3e; {
      if (error) {
        this.emit(&#x27;error&#x27;, new errors.InvalidConsumerOffsetError(`Fetching ${this.options.outOfRangeOffset} offset failed`, error
));
        return;
      }
      const offset = _.head(result[topic.topic][topic.partition]);
      const oldOffset = _.find(this.topicPayloads, {topic: topic.topic, partition: topic.partition}).offset;

      logger.debug(&#x27;replacing %s-%s stale offset of %d with %d&#x27;, topic.topic, topic.partition, oldOffset, offset);

      this.setOffset(topic.topic, topic.partition, offset);
      this.resume();
    });
  });

  // &#x27;done&#x27; will be emit when a message fetch request complete
  this.on(&#x27;done&#x27;, function (topics) {
    self.updateOffsets(topics);
    if (!self.paused) {
      setImmediate(function () {
        self.fetch();
      });
    }
  });

  if (this.options.groupId) {
    validateConfig(&#x27;options.groupId&#x27;, this.options.groupId);
  }

  this.isLeader = false;
  this.coordinatorId = null;
  this.generationId = null;
  this.ready = false;
  this.topicPayloads = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.CustomPartitioner" id="apidoc.element.kafka-node.CustomPartitioner">
        function <span class="apidocSignatureSpan">kafka-node.</span>CustomPartitioner
        <span class="apidocSignatureSpan">(partitioner)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CustomPartitioner = function (partitioner) {
  this.getPartition = partitioner;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.CyclicPartitioner" id="apidoc.element.kafka-node.CyclicPartitioner">
        function <span class="apidocSignatureSpan">kafka-node.</span>CyclicPartitioner
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CyclicPartitioner = function () {
  this.c = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.DefaultPartitioner" id="apidoc.element.kafka-node.DefaultPartitioner">
        function <span class="apidocSignatureSpan">kafka-node.</span>DefaultPartitioner
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">DefaultPartitioner = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.FailedToRebalanceConsumerError" id="apidoc.element.kafka-node.FailedToRebalanceConsumerError">
        function <span class="apidocSignatureSpan">kafka-node.</span>FailedToRebalanceConsumerError
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">FailedToRebalanceConsumerError = function (message) {
  Error.captureStackTrace(this, this);
  this.message = message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      operation.attempt(function (currentAttempt) {
self.rebalanceAttempt(oldTopicPayloads, function (err) {
  if (operation.retry(err)) {
    return;
  }
  if (err) {
    self.rebalancing = false;
    return self.emit(&#x27;error&#x27;, new errors.<span class="apidocCodeKeywordSpan">FailedToRebalanceConsumerError</span>(operation
.mainError().toString()));
  } else {
    var topicNames = self.topicPayloads.map(function (p) {
      return p.topic;
    });
    self.client.refreshMetadata(topicNames, function (err) {
      register();
      if (err) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.FailedToRegisterConsumerError" id="apidoc.element.kafka-node.FailedToRegisterConsumerError">
        function <span class="apidocSignatureSpan">kafka-node.</span>FailedToRegisterConsumerError
        <span class="apidocSignatureSpan">(message, nested)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">FailedToRegisterConsumerError = function (message, nested) {
  NestedError.call(this, message, nested);
  this.message = message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          } else {
            callback(new Error(util.format(&#x27;Consumer %s is not registered in group %s&#x27;, self.id, self.options.groupId)));
          }
        });
      }
    ], function (error) {
      if (error) {
        self.emit(&#x27;error&#x27;, new errors.<span class="apidocCodeKeywordSpan">FailedToRegisterConsumerError</span>(error.toString
(), error));
      }
    });
  }
}, 20000);

function fetchAndUpdateOffsets (cb) {
  self.fetchOffset(self.topicPayloads, function (err, topics) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.GroupCoordinatorNotAvailableError" id="apidoc.element.kafka-node.GroupCoordinatorNotAvailableError">
        function <span class="apidocSignatureSpan">kafka-node.</span>GroupCoordinatorNotAvailableError
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">GroupCoordinatorNotAvailableError = function (message) {
  Error.captureStackTrace(this, this);
  this.message = message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.GroupLoadInProgressError" id="apidoc.element.kafka-node.GroupLoadInProgressError">
        function <span class="apidocSignatureSpan">kafka-node.</span>GroupLoadInProgressError
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">GroupLoadInProgressError = function (message) {
  Error.captureStackTrace(this, this);
  this.message = message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HeartbeatTimeoutError" id="apidoc.element.kafka-node.HeartbeatTimeoutError">
        function <span class="apidocSignatureSpan">kafka-node.</span>HeartbeatTimeoutError
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">HeartbeatTimeoutError = function (message) {
  Error.captureStackTrace(this, this);
  this.message = message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer" id="apidoc.element.kafka-node.HighLevelConsumer">
        function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer
        <span class="apidocSignatureSpan">(client, topics, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">HighLevelConsumer = function (client, topics, options) {
  if (!topics) {
    throw new Error(&#x27;Must have payloads&#x27;);
  }
  this.fetchCount = 0;
  this.client = client;
  this.options = _.defaults((options || {}), DEFAULTS);
  this.initialised = false;
  this.ready = false;
  this.closing = false;
  this.paused = this.options.paused;
  this.rebalancing = false;
  this.pendingRebalances = 0;
  this.committing = false;
  this.needToCommit = false;
  this.id = this.options.id || this.options.groupId + &#x27;_&#x27; + uuid.v4();
  this.payloads = this.buildPayloads(topics);
  this.topicPayloads = this.buildTopicPayloads(topics);
  this.connect();

  if (this.options.groupId) {
    validateConfig(&#x27;options.groupId&#x27;, this.options.groupId);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelProducer" id="apidoc.element.kafka-node.HighLevelProducer">
        function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelProducer
        <span class="apidocSignatureSpan">(client, options, customPartitioner)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HighLevelProducer(client, options, customPartitioner) {
  BaseProducer.call(this, client, options, BaseProducer.PARTITIONER_TYPES.cyclic, customPartitioner);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelProducer.super_" id="apidoc.element.kafka-node.HighLevelProducer.super_">
        function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelProducer.super_
        <span class="apidocSignatureSpan">(client, options, defaultPartitionerType, customPartitioner)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BaseProducer(client, options, defaultPartitionerType, customPartitioner) {
  options = options || {};

  this.ready = false;
  this.client = client;

  this.requireAcks = options.requireAcks === undefined
    ? DEFAULTS.requireAcks
    : options.requireAcks;
  this.ackTimeoutMs = options.ackTimeoutMs === undefined
    ? DEFAULTS.ackTimeoutMs
    : options.ackTimeoutMs;

  if (customPartitioner !== undefined &#x26;&#x26; options.partitionerType !== PARTITIONER_TYPES.custom) {
    throw new Error(&#x27;Partitioner Type must be custom if providing a customPartitioner.&#x27;);
  } else if (customPartitioner === undefined &#x26;&#x26; options.partitionerType === PARTITIONER_TYPES.custom) {
    throw new Error(&#x27;No customer partitioner defined&#x27;);
  }

  var partitionerType = PARTITIONER_MAP[options.partitionerType] || PARTITIONER_MAP[defaultPartitionerType];

  // eslint-disable-next-line
  this.partitioner = new partitionerType(customPartitioner);

  this.connect();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.IllegalGenerationError" id="apidoc.element.kafka-node.IllegalGenerationError">
        function <span class="apidocSignatureSpan">kafka-node.</span>IllegalGenerationError
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IllegalGenerationError = function (message) {
  Error.captureStackTrace(this, this);
  this.message = message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.InvalidConfigError" id="apidoc.element.kafka-node.InvalidConfigError">
        function <span class="apidocSignatureSpan">kafka-node.</span>InvalidConfigError
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">InvalidConfigError = function (message) {
  Error.captureStackTrace(this, this);
  this.message = message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.InvalidConsumerOffsetError" id="apidoc.element.kafka-node.InvalidConsumerOffsetError">
        function <span class="apidocSignatureSpan">kafka-node.</span>InvalidConsumerOffsetError
        <span class="apidocSignatureSpan">(message, nested)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">InvalidConsumerOffsetError = function (message, nested) {
  NestedError.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.client.on(&#x27;reconnect&#x27;, function (lastError) {
self.fetch();
  });

  this.on(&#x27;offsetOutOfRange&#x27;, topic =&#x3e; {
this.pause();
if (this.options.outOfRangeOffset === &#x27;none&#x27;) {
  this.emit(&#x27;error&#x27;, new errors.<span class="apidocCodeKeywordSpan">InvalidConsumerOffsetError</span>(`Offset out of range
 for topic &#x22;${topic.topic}&#x22; partition ${topic.partition}`));
  return;
}

topic.time = ACCEPTED_FROM_OFFSET[this.options.outOfRangeOffset];

this.getOffset().fetch([topic], (error, result) =&#x3e; {
  if (error) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.KafkaBuffer" id="apidoc.element.kafka-node.KafkaBuffer">
        function <span class="apidocSignatureSpan">kafka-node.</span>KafkaBuffer
        <span class="apidocSignatureSpan">(batchSize, batchAge)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">KafkaBuffer = function (batchSize, batchAge) {
  this._batch_size = batchSize;
  this._batch_age = batchAge;
  this._batch_age_timer = null;
  this._buffer = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.KeyedMessage" id="apidoc.element.kafka-node.KeyedMessage">
        function <span class="apidocSignatureSpan">kafka-node.</span>KeyedMessage
        <span class="apidocSignatureSpan">(key, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function KeyedMessage(key, value) {
  exports.Message.call(this, 0, 0, key, value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.KeyedPartitioner" id="apidoc.element.kafka-node.KeyedPartitioner">
        function <span class="apidocSignatureSpan">kafka-node.</span>KeyedPartitioner
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">KeyedPartitioner = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.NotCoordinatorForGroupError" id="apidoc.element.kafka-node.NotCoordinatorForGroupError">
        function <span class="apidocSignatureSpan">kafka-node.</span>NotCoordinatorForGroupError
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">NotCoordinatorForGroupError = function (message) {
  Error.captureStackTrace(this, this);
  this.message = message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Offset" id="apidoc.element.kafka-node.Offset">
        function <span class="apidocSignatureSpan">kafka-node.</span>Offset
        <span class="apidocSignatureSpan">(client)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Offset = function (client) {
  var self = this;
  this.client = client;
  this.ready = this.client.ready;
  this.client.on(&#x27;ready&#x27;, function () {
    self.ready = true;
    self.emit(&#x27;ready&#x27;);
  });
  this.client.once(&#x27;connect&#x27;, function () {
    self.emit(&#x27;connect&#x27;);
  });
  this.client.on(&#x27;error&#x27;, function (err) {
    self.emit(&#x27;error&#x27;, err);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `cb`: *Function*, the callback

Example

```js
var kafka = require(&#x27;kafka-node&#x27;),
    client = new kafka.Client(),
    offset = new kafka.<span class="apidocCodeKeywordSpan">Offset</span>(client);
    offset.fetch([
        { topic: &#x27;t&#x27;, partition: 0, time: Date.now(), maxNum: 1 }
    ], function (err, data) {
        // data
        // { &#x27;t&#x27;: { &#x27;0&#x27;: [999] } }
    });
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Producer" id="apidoc.element.kafka-node.Producer">
        function <span class="apidocSignatureSpan">kafka-node.</span>Producer
        <span class="apidocSignatureSpan">(client, options, customPartitioner)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Producer(client, options, customPartitioner) {
  BaseProducer.call(this, client, options, BaseProducer.PARTITIONER_TYPES.default, customPartitioner);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.RandomPartitioner" id="apidoc.element.kafka-node.RandomPartitioner">
        function <span class="apidocSignatureSpan">kafka-node.</span>RandomPartitioner
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RandomPartitioner = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.RebalanceInProgressError" id="apidoc.element.kafka-node.RebalanceInProgressError">
        function <span class="apidocSignatureSpan">kafka-node.</span>RebalanceInProgressError
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RebalanceInProgressError = function (message) {
  Error.captureStackTrace(this, this);
  this.message = message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.TopicsNotExistError" id="apidoc.element.kafka-node.TopicsNotExistError">
        function <span class="apidocSignatureSpan">kafka-node.</span>TopicsNotExistError
        <span class="apidocSignatureSpan">(topics)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TopicsNotExistError = function (topics) {
  Error.captureStackTrace(this, this);
  this.topics = topics;
  this.message = &#x27;The topic(s) &#x27; + topics.toString() + &#x27; do not exist&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
Client.prototype.topicExists = function (topics, cb) {
var notExistsTopics = [];
var self = this;

async.each(topics, checkZK, function (err) {
  if (err) return cb(err);
  if (notExistsTopics.length) return cb(new errors.<span class="apidocCodeKeywordSpan">TopicsNotExistError</span>(notExistsTopics
));
  cb();
});

function checkZK (topic, cb) {
  self.zk.topicExists(topic, function (err, existed, topic) {
    if (err) return cb(err);
    if (!existed) notExistsTopics.push(topic);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.UnknownMemberIdError" id="apidoc.element.kafka-node.UnknownMemberIdError">
        function <span class="apidocSignatureSpan">kafka-node.</span>UnknownMemberIdError
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">UnknownMemberIdError = function (message) {
  Error.captureStackTrace(this, this);
  this.message = message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.consumerGroupMigrator" id="apidoc.element.kafka-node.consumerGroupMigrator">
        function <span class="apidocSignatureSpan">kafka-node.</span>consumerGroupMigrator
        <span class="apidocSignatureSpan">(consumerGroup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ConsumerGroupMigrator(consumerGroup) {
  EventEmitter.call(this);
  assert(consumerGroup);
  const self = this;
  this.consumerGroup = consumerGroup;
  this.client = consumerGroup.client;
  var verified = 0;

  if (consumerGroup.options.migrateRolling) {
    this.zk = zookeeper.createClient(consumerGroup.client.connectionString, {retries: 10});
    this.zk.on(&#x27;connected&#x27;, function () {
      self.filterByExistingZkTopics(function (error, topics) {
        if (error) {
          return self.emit(&#x27;error&#x27;, error);
        }

        if (topics.length) {
          self.checkForOwnersAndListenForChange(topics);
        } else {
          logger.debug(&#x27;No HLC topics exist in zookeeper.&#x27;);
          self.connectConsumerGroup();
        }
      });
    });

    this.on(&#x27;noOwnersForTopics&#x27;, function (topics) {
      logger.debug(&#x27;No owners for topics %s reported.&#x27;, topics);
      if (++verified &#x3c;= NUMER_OF_TIMES_TO_VERIFY) {
        logger.debug(&#x27;%s verify %d of %d HLC has given up ownership by checking again in %d&#x27;, self.client.clientId, verified,
          NUMER_OF_TIMES_TO_VERIFY, VERIFY_WAIT_TIME_MS);

        setTimeout(function () {
          self.checkForOwners(topics);
        }, VERIFY_WAIT_TIME_MS);
      } else {
        self.connectConsumerGroup();
      }
    });

    this.on(&#x27;topicOwnerChange&#x27;, _.debounce(function (topics) {
      verified = 0;
      self.checkForOwnersAndListenForChange(topics);
    }, 250));

    this.zk.connect();
  } else {
    this.connectConsumerGroup();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.consumerGroupRecovery" id="apidoc.element.kafka-node.consumerGroupRecovery">
        function <span class="apidocSignatureSpan">kafka-node.</span>consumerGroupRecovery
        <span class="apidocSignatureSpan">(consumerGroup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ConsumerGroupRecovery(consumerGroup) {
  this.consumerGroup = consumerGroup;
  this.options = consumerGroup.options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




















































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.BrokerNotAvailableError" id="apidoc.module.kafka-node.BrokerNotAvailableError">module kafka-node.BrokerNotAvailableError</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.BrokerNotAvailableError.BrokerNotAvailableError" id="apidoc.element.kafka-node.BrokerNotAvailableError.BrokerNotAvailableError">
        function <span class="apidocSignatureSpan">kafka-node.</span>BrokerNotAvailableError
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BrokerNotAvailableError = function (message) {
  Error.captureStackTrace(this, this);
  this.message = message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  requestArgs.unshift(this.clientId, correlationId);

  var request = encode.apply(null, requestArgs);
  var broker = this.brokerForLeader(this.coordinatorId);

  if (!broker || !broker.socket || broker.socket.error || broker.socket.destroyed) {
    return cb(new errors.<span class="apidocCodeKeywordSpan">BrokerNotAvailableError</span>(&#x27;Broker not available&#x27;));
  }

  this.queueCallback(broker.socket, correlationId, [decode, cb]);
  broker.write(request);
};

Client.prototype.sendGroupCoordinatorRequest = function (groupId, cb) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.BrokerNotAvailableError.super_" id="apidoc.element.kafka-node.BrokerNotAvailableError.super_">
        function <span class="apidocSignatureSpan">kafka-node.BrokerNotAvailableError.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Error() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.BrokerReadable" id="apidoc.module.kafka-node.BrokerReadable">module kafka-node.BrokerReadable</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.BrokerReadable.BrokerReadable" id="apidoc.element.kafka-node.BrokerReadable.BrokerReadable">
        function <span class="apidocSignatureSpan">kafka-node.</span>BrokerReadable
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BrokerReadable = function (options) {
  Readable.call(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.BrokerReadable.super_" id="apidoc.element.kafka-node.BrokerReadable.super_">
        function <span class="apidocSignatureSpan">kafka-node.BrokerReadable.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Readable(options) {
  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options &#x26;&#x26; typeof options.read === &#x27;function&#x27;)
    this._read = options.read;

  Stream.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.BrokerReadable.prototype" id="apidoc.module.kafka-node.BrokerReadable.prototype">module kafka-node.BrokerReadable.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.BrokerReadable.prototype._read" id="apidoc.element.kafka-node.BrokerReadable.prototype._read">
        function <span class="apidocSignatureSpan">kafka-node.BrokerReadable.prototype.</span>_read
        <span class="apidocSignatureSpan">(size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_read = function (size) {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.BrokerTransform" id="apidoc.module.kafka-node.BrokerTransform">module kafka-node.BrokerTransform</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.BrokerTransform.BrokerTransform" id="apidoc.element.kafka-node.BrokerTransform.BrokerTransform">
        function <span class="apidocSignatureSpan">kafka-node.</span>BrokerTransform
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BrokerTransform = function (options) {
  Transform.call(this, options);
  this.noAckBatchSize = options ? options.noAckBatchSize : null;
  this.noAckBatchAge = options ? options.noAckBatchAge : null;
  this._KafkaBuffer = new KafkaBuffer(this.noAckBatchSize, this.noAckBatchAge);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.BrokerTransform.super_" id="apidoc.element.kafka-node.BrokerTransform.super_">
        function <span class="apidocSignatureSpan">kafka-node.BrokerTransform.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(this);

  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === &#x27;function&#x27;)
      this._transform = options.transform;

    if (typeof options.flush === &#x27;function&#x27;)
      this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.once(&#x27;prefinish&#x27;, function() {
    if (typeof this._flush === &#x27;function&#x27;)
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.BrokerTransform.prototype" id="apidoc.module.kafka-node.BrokerTransform.prototype">module kafka-node.BrokerTransform.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.BrokerTransform.prototype._transform" id="apidoc.element.kafka-node.BrokerTransform.prototype._transform">
        function <span class="apidocSignatureSpan">kafka-node.BrokerTransform.prototype.</span>_transform
        <span class="apidocSignatureSpan">(chunk, enc, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_transform = function (chunk, enc, done) {
  this._KafkaBuffer.addChunk(chunk, this._transformNext.bind(this));
  done();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.BrokerTransform.prototype._transformNext" id="apidoc.element.kafka-node.BrokerTransform.prototype._transformNext">
        function <span class="apidocSignatureSpan">kafka-node.BrokerTransform.prototype.</span>_transformNext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_transformNext = function () {
  this.push(this._KafkaBuffer.getBatch());
  this._KafkaBuffer.truncateBatch();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.BrokerWrapper" id="apidoc.module.kafka-node.BrokerWrapper">module kafka-node.BrokerWrapper</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.BrokerWrapper.BrokerWrapper" id="apidoc.element.kafka-node.BrokerWrapper.BrokerWrapper">
        function <span class="apidocSignatureSpan">kafka-node.</span>BrokerWrapper
        <span class="apidocSignatureSpan">(socket, noAckBatchOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BrokerWrapper = function (socket, noAckBatchOptions) {
  this.socket = socket;

  var self = this;
  var readable = new BrokerReadable();
  var transform = new BrokerTransform(noAckBatchOptions);

  readable.pipe(transform);

  transform.on(&#x27;readable&#x27;, function () {
    var bulkMessage = null;
    while (bulkMessage = transform.read()) { // eslint-disable-line no-cond-assign
      self.socket.write(bulkMessage);
    }
  });

  this.readableSocket = readable;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.BrokerWrapper.prototype" id="apidoc.module.kafka-node.BrokerWrapper.prototype">module kafka-node.BrokerWrapper.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.BrokerWrapper.prototype.write" id="apidoc.element.kafka-node.BrokerWrapper.prototype.write">
        function <span class="apidocSignatureSpan">kafka-node.BrokerWrapper.prototype.</span>write
        <span class="apidocSignatureSpan">(buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function (buffer) {
  this.socket.write(buffer);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var broker = this.brokerForLeader(this.coordinatorId);

  if (!broker || !broker.socket || broker.socket.error || broker.socket.destroyed) {
    return cb(new errors.BrokerNotAvailableError(&#x27;Broker not available&#x27;));
  }

  this.queueCallback(broker.socket, correlationId, [decode, cb]);
  broker.<span class="apidocCodeKeywordSpan">write</span>(request);
};

Client.prototype.sendGroupCoordinatorRequest = function (groupId, cb) {
  this.sendGroupRequest(protocol.encodeGroupCoordinatorRequest, protocol.decodeGroupCoordinatorResponse, arguments);
};

Client.prototype.sendJoinGroupRequest = function (groupId, memberId, sessionTimeout, groupProtocol, cb) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.BrokerWrapper.prototype.writeAsync" id="apidoc.element.kafka-node.BrokerWrapper.prototype.writeAsync">
        function <span class="apidocSignatureSpan">kafka-node.BrokerWrapper.prototype.</span>writeAsync
        <span class="apidocSignatureSpan">(buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeAsync = function (buffer) {
  this.readableSocket.push(buffer);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    if (longpolling) {
      if (broker.socket.waiting) continue;
      broker.socket.waiting = true;
    }

    if (decoder.requireAcks === 0) {
      broker.<span class="apidocCodeKeywordSpan">writeAsync</span>(request);
      cb(null, { result: &#x27;no ack&#x27; });
    } else {
      this.queueCallback(broker.socket, correlationId, [decoder, cb]);
      broker.write(request);
    }
  }
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Client" id="apidoc.module.kafka-node.Client">module kafka-node.Client</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client.Client" id="apidoc.element.kafka-node.Client.Client">
        function <span class="apidocSignatureSpan">kafka-node.</span>Client
        <span class="apidocSignatureSpan">(connectionString, clientId, zkOptions, noAckBatchOptions, sslOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client = function (connectionString, clientId, zkOptions, noAckBatchOptions, sslOptions) {
  if (this instanceof Client === false) {
    return new Client(connectionString, clientId, zkOptions, noAckBatchOptions, sslOptions);
  }

  this.sslOptions = sslOptions;
  this.ssl = !!sslOptions;

  if (clientId) {
    validateConfig(&#x27;clientId&#x27;, clientId);
  }

  this.connectionString = connectionString || &#x27;localhost:2181/&#x27;;
  this.clientId = clientId || &#x27;kafka-node-client&#x27;;
  this.zkOptions = zkOptions;
  this.noAckBatchOptions = noAckBatchOptions;
  this.brokers = {};
  this.longpollingBrokers = {};
  this.topicMetadata = {};
  this.topicPartitions = {};
  this.correlationId = 0;
  this._socketId = 0;
  this.cbqueue = {};
  this.brokerMetadata = {};
  this.ready = false;
  this.connect();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    partitionerType: 2
}
```

``` js
var kafka = require(&#x27;kafka-node&#x27;),
    Producer = kafka.Producer,
    client = new kafka.<span class="apidocCodeKeywordSpan">Client</span>(),
    producer = new Producer(client);
```

### Events

- `ready`: this event is emitted when producer is ready to send messages.
- `error`: this is the error event propagates from internal client, producer should always listen it.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.super_" id="apidoc.element.kafka-node.Client.super_">
        function <span class="apidocSignatureSpan">kafka-node.Client.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Client.prototype" id="apidoc.module.kafka-node.Client.prototype">module kafka-node.Client.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.addTopics" id="apidoc.element.kafka-node.Client.prototype.addTopics">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>addTopics
        <span class="apidocSignatureSpan">(topics, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addTopics = function (topics, cb) {
  var self = this;
  this.topicExists(topics, function (err) {
    if (err) return cb(err);
    self.loadMetadataForTopics(topics, function (err, resp) {
      if (err) return cb(err);
      self.updateMetadatas(resp);
      cb(null, topics);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `topics`: **Array**, array of topics to add
* `cb`: **Function**,the callback
* `fromOffset`: **Boolean**, if true, the consumer will fetch message from the specified offset, otherwise it will fetch message
 from the last commited offset of the topic.

Example:

``` js
consumer.<span class="apidocCodeKeywordSpan">addTopics</span>([&#x27;t1&#x27;, &#x27;t2&#x27;], function (err, added) {
});

or

consumer.addTopics([{ topic: &#x27;t1&#x27;, offset: 10 }], function (err, added) {
}, true);
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.brokerForLeader" id="apidoc.element.kafka-node.Client.prototype.brokerForLeader">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>brokerForLeader
        <span class="apidocSignatureSpan">(leader, longpolling)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">brokerForLeader = function (leader, longpolling) {
  var addr;
  var brokers = this.getBrokers(longpolling);
  // If leader is not give, choose the first broker as leader
  if (typeof leader === &#x27;undefined&#x27;) {
    if (!_.isEmpty(brokers)) {
      addr = Object.keys(brokers)[0];
      return brokers[addr];
    } else if (!_.isEmpty(this.brokerMetadata)) {
      leader = Object.keys(this.brokerMetadata)[0];
    } else {
      return;
    }
  }

  var broker = _.find(this.brokerProfiles, {id: leader});

  if (!broker) {
    return;
  }

  addr = broker.host + &#x27;:&#x27; + broker.port;

  return brokers[addr] || this.setupBroker(broker.host, broker.port, longpolling, brokers);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
requestArgs = _.values(requestArgs);
var cb = requestArgs.pop();
var correlationId = this.nextId();

requestArgs.unshift(this.clientId, correlationId);

var request = encode.apply(null, requestArgs);
var broker = this.<span class="apidocCodeKeywordSpan">brokerForLeader</span>(this.coordinatorId);

if (!broker || !broker.socket || broker.socket.error || broker.socket.destroyed) {
  return cb(new errors.BrokerNotAvailableError(&#x27;Broker not available&#x27;));
}

this.queueCallback(broker.socket, correlationId, [decode, cb]);
broker.write(request);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.checkMetadatas" id="apidoc.element.kafka-node.Client.prototype.checkMetadatas">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>checkMetadatas
        <span class="apidocSignatureSpan">(payloads)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkMetadatas = function (payloads) {
  if (_.isEmpty(this.topicMetadata)) return [ [], payloads ];
  // out: [ [metadata exists], [metadata not exists] ]
  var out = [ [], [] ];
  payloads.forEach(function (p) {
    if (this.hasMetadata(p.topic, p.partition)) out[0].push(p);
    else out[1].push(p);
  }.bind(this));
  return out;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
};

Client.prototype.send = function (payloads, encoder, decoder, cb) {
var self = this;
var _payloads = payloads;
// payloads: [ [metadata exists], [metadata not exists] ]
payloads = this.<span class="apidocCodeKeywordSpan">checkMetadatas</span>(payloads);
if (payloads[0].length &#x26;&#x26; !payloads[1].length) {
  this.sendToBroker(_.flatten(payloads), encoder, decoder, cb);
  return;
}
if (payloads[1].length) {
  var topicNames = payloads[1].map(function (p) { return p.topic; });
  this.loadMetadataForTopics(topicNames, function (err, resp) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.clearCallbackQueue" id="apidoc.element.kafka-node.Client.prototype.clearCallbackQueue">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>clearCallbackQueue
        <span class="apidocSignatureSpan">(socket, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearCallbackQueue = function (socket, error) {
  var socketId = socket.socketId;
  var longpolling = socket.longpolling;

  if (!this.cbqueue.hasOwnProperty(socketId)) {
    return;
  }

  var queue = this.cbqueue[socketId];

  if (!longpolling) {
    Object.keys(queue).forEach(function (key) {
      var handlers = queue[key];
      var cb = handlers[1];
      cb(error);
    });
  }
  delete this.cbqueue[socketId];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
socket.on(&#x27;error&#x27;, function (err) {
  this.error = err;
  self.emit(&#x27;error&#x27;, err);
});
socket.on(&#x27;close&#x27;, function (hadError) {
  self.emit(&#x27;close&#x27;, this);
  if (hadError &#x26;&#x26; this.error) {
    self.<span class="apidocCodeKeywordSpan">clearCallbackQueue</span>(this, this.error);
  } else {
    self.clearCallbackQueue(this, new errors.BrokerNotAvailableError(&#x27;Broker not available&#x27;));
  }
  retry(this);
});
socket.on(&#x27;end&#x27;, function () {
  retry(this);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.close" id="apidoc.element.kafka-node.Client.prototype.close">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>close
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (cb) {
  this.closeBrokers(this.brokers);
  this.closeBrokers(this.longpollingBrokers);
  this.zk.close();
  cb &#x26;&#x26; cb();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### close(force, cb)
* `force`: **Boolean**, if set to true, it forces the consumer to commit the current offset before closing, default `false`

Example

```js
consumer.<span class="apidocCodeKeywordSpan">close</span>(true, cb);
consumer.close(cb); //force is disabled
```

## HighLevelConsumer
 ***This consumer has been deprecated in the latest version of Kafka (0.10.1) and is likely to be removed in the future. Please
 use the ConsumerGroup instead.***

### HighLevelConsumer(client, payloads, options)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.closeBrokers" id="apidoc.element.kafka-node.Client.prototype.closeBrokers">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>closeBrokers
        <span class="apidocSignatureSpan">(brokers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">closeBrokers = function (brokers) {
  _.each(brokers, function (broker) {
    broker.socket.closing = true;
    broker.socket.end();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  self.brokerProfiles[addr] = brokerProfile;
  self.brokerProfiles[addr].id = key;
});
};

Client.prototype.close = function (cb) {
this.<span class="apidocCodeKeywordSpan">closeBrokers</span>(this.brokers);
this.closeBrokers(this.longpollingBrokers);
this.zk.close();
cb &#x26;&#x26; cb();
};

Client.prototype.closeBrokers = function (brokers) {
_.each(brokers, function (broker) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.connect" id="apidoc.element.kafka-node.Client.prototype.connect">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>connect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connect = function () {
  var zk = this.zk = new Zookeeper(this.connectionString, this.zkOptions);
  var self = this;
  zk.once(&#x27;init&#x27;, function (brokers) {
    try {
      self.ready = true;
      self.brokerMetadata = brokers;
      self.setupBrokerProfiles(brokers);
      Object
          .keys(self.brokerProfiles)
          .some(function (key, index) {
            var broker = self.brokerProfiles[key];
            self.setupBroker(broker.host, broker.port, false, self.brokers);
            // Only connect one broker
            return !index;
          });
      self.emit(&#x27;ready&#x27;);
    } catch (error) {
      self.ready = false;
      self.emit(&#x27;error&#x27;, error);
    }
  });
  zk.on(&#x27;brokersChanged&#x27;, function (brokerMetadata) {
    try {
      self.brokerMetadata = brokerMetadata;
      logger.debug(&#x27;brokersChanged&#x27;, brokerMetadata);
      self.setupBrokerProfiles(brokerMetadata);
      self.refreshBrokers();
      // Emit after a 3 seconds
      setTimeout(function () {
        self.emit(&#x27;brokersChanged&#x27;);
      }, 3000);
    } catch (error) {
      self.emit(&#x27;error&#x27;, error);
    }
  });
  zk.once(&#x27;disconnected&#x27;, function () {
    if (!zk.closed) {
      zk.close();
      self.connect();
      self.emit(&#x27;zkReconnect&#x27;);
    }
  });
  zk.on(&#x27;error&#x27;, function (err) {
    self.emit(&#x27;error&#x27;, err);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

var partitionerType = PARTITIONER_MAP[options.partitionerType] || PARTITIONER_MAP[defaultPartitionerType];

// eslint-disable-next-line
this.partitioner = new partitionerType(customPartitioner);

this.<span class="apidocCodeKeywordSpan">connect</span>();
}

util.inherits(BaseProducer, events.EventEmitter);

BaseProducer.prototype.connect = function () {
// emiter...
var self = this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.createBroker" id="apidoc.element.kafka-node.Client.prototype.createBroker">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>createBroker
        <span class="apidocSignatureSpan">(host, port, longpolling)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createBroker = function (host, port, longpolling) {
  var self = this;
  var socket;
  if (self.ssl) {
    socket = tls.connect(port, host, self.sslOptions);
  } else {
    socket = net.createConnection(port, host);
  }
  socket.addr = host + &#x27;:&#x27; + port;
  socket.host = host;
  socket.port = port;
  socket.socketId = this.nextSocketId();
  if (longpolling) socket.longpolling = true;

  socket.on(&#x27;connect&#x27;, function () {
    var lastError = this.error;
    this.error = null;
    if (lastError) {
      this.waiting = false;
      self.emit(&#x27;reconnect&#x27;);
    } else {
      self.emit(&#x27;connect&#x27;);
    }
  });
  socket.on(&#x27;error&#x27;, function (err) {
    this.error = err;
    self.emit(&#x27;error&#x27;, err);
  });
  socket.on(&#x27;close&#x27;, function (hadError) {
    self.emit(&#x27;close&#x27;, this);
    if (hadError &#x26;&#x26; this.error) {
      self.clearCallbackQueue(this, this.error);
    } else {
      self.clearCallbackQueue(this, new errors.BrokerNotAvailableError(&#x27;Broker not available&#x27;));
    }
    retry(this);
  });
  socket.on(&#x27;end&#x27;, function () {
    retry(this);
  });
  socket.buffer = new Buffer([]);
  socket.on(&#x27;data&#x27;, function (data) {
    this.buffer = Buffer.concat([this.buffer, data]);
    self.handleReceivedData(this);
  });
  socket.setKeepAlive(true, 60000);

  function retry (s) {
    if (s.retrying || s.closing) return;
    s.retrying = true;
    s.retryTimer = setTimeout(function () {
      if (s.closing) return;
      self.reconnectBroker(s);
    }, 1000);
  }
  return new BrokerWrapper(socket, this.noAckBatchOptions);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Client.prototype.getBrokers = function (longpolling) {
return longpolling ? this.longpollingBrokers : this.brokers;
};

Client.prototype.setupBroker = function (host, port, longpolling, brokers) {
var brokerKey = host + &#x27;:&#x27; + port;
brokers[brokerKey] = this.<span class="apidocCodeKeywordSpan">createBroker</span>(host, port, longpolling);
return brokers[brokerKey];
};

Client.prototype.createBroker = function (host, port, longpolling) {
var self = this;
var socket;
if (self.ssl) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.createTopics" id="apidoc.element.kafka-node.Client.prototype.createTopics">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>createTopics
        <span class="apidocSignatureSpan">(topics, isAsync, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createTopics = function (topics, isAsync, cb) {
  topics = typeof topics === &#x27;string&#x27; ? [topics] : topics;

  if (typeof isAsync === &#x27;function&#x27; &#x26;&#x26; typeof cb === &#x27;undefined&#x27;) {
    cb = isAsync;
    isAsync = true;
  }

  try {
    validateKafkaTopics(topics);
  } catch (e) {
    if (isAsync) return cb(e);
    throw e;
  }

  cb = _.once(cb);

  const getTopicsFromKafka = (topics, callback) =&#x3e; {
    this.loadMetadataForTopics(topics, function (error, resp) {
      if (error) {
        return callback(error);
      }
      callback(null, Object.keys(resp[1].metadata));
    });
  };

  const operation = retry.operation({ minTimeout: 200, maxTimeout: 2000 });

  operation.attempt(currentAttempt =&#x3e; {
    logger.debug(&#x27;create topics currentAttempt&#x27;, currentAttempt);
    getTopicsFromKafka(topics, function (error, kafkaTopics) {
      if (error) {
        if (operation.retry(error)) {
          return;
        }
      }

      logger.debug(&#x27;kafka reported topics&#x27;, kafkaTopics);
      const left = _.difference(topics, kafkaTopics);
      if (left.length === 0) {
        logger.debug(`Topics created ${kafkaTopics}`);
        return cb(null, kafkaTopics);
      }

      logger.debug(`Topics left ${left.join(&#x27;, &#x27;)}`);
      if (!operation.retry(new Error(`Topics not created ${left}`))) {
        cb(operation.mainError());
      }
    });
  });

  if (!isAsync) {
    cb(null);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

``` js
var kafka = require(&#x27;kafka-node&#x27;),
    Producer = kafka.Producer,
    client = new kafka.Client(),
    producer = new Producer(client);
// Create topics sync
producer.<span class="apidocCodeKeywordSpan">createTopics</span>([&#x27;t&#x27;,&#x27;t1&#x27;], false, function (err, data) {
    console.log(data);
});
// Create topics async
producer.createTopics([&#x27;t&#x27;], true, function (err, data) {});
producer.createTopics([&#x27;t&#x27;], function (err, data) {});// Simply omit 2nd arg
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.getBrokers" id="apidoc.element.kafka-node.Client.prototype.getBrokers">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>getBrokers
        <span class="apidocSignatureSpan">(longpolling)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getBrokers = function (longpolling) {
  return longpolling ? this.longpollingBrokers : this.brokers;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Client.prototype.leaderByPartition = function (topic, partition) {
var topicMetadata = this.topicMetadata;
return topicMetadata[topic] &#x26;&#x26; topicMetadata[topic][partition] &#x26;&#x26; topicMetadata[topic][partition].leader;
};

Client.prototype.brokerForLeader = function (leader, longpolling) {
var addr;
var brokers = this.<span class="apidocCodeKeywordSpan">getBrokers</span>(longpolling);
// If leader is not give, choose the first broker as leader
if (typeof leader === &#x27;undefined&#x27;) {
  if (!_.isEmpty(brokers)) {
    addr = Object.keys(brokers)[0];
    return brokers[addr];
  } else if (!_.isEmpty(this.brokerMetadata)) {
    leader = Object.keys(this.brokerMetadata)[0];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.handleReceivedData" id="apidoc.element.kafka-node.Client.prototype.handleReceivedData">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>handleReceivedData
        <span class="apidocSignatureSpan">(socket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleReceivedData = function (socket) {
  var vars = Binary.parse(socket.buffer).word32bu(&#x27;size&#x27;).word32bu(&#x27;correlationId&#x27;).vars;
  var size = vars.size + 4;
  var correlationId = vars.correlationId;

  if (socket.buffer.length &#x3e;= size) {
    var resp = socket.buffer.slice(0, size);
    var handlers = this.unqueueCallback(socket, correlationId);

    if (!handlers) return;
    var decoder = handlers[0];
    var cb = handlers[1];
    var result = decoder(resp);
    (result instanceof Error)
      ? cb.call(this, result)
      : cb.call(this, null, result);
    socket.buffer = socket.buffer.slice(size);
    if (socket.longpolling) socket.waiting = false;
  } else { return; }

  if (socket.buffer.length) {
    setImmediate(function () { this.handleReceivedData(socket); }.bind(this));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
socket.on(&#x27;end&#x27;, function () {
  retry(this);
});
socket.buffer = new Buffer([]);
socket.on(&#x27;data&#x27;, function (data) {
  this.buffer = Buffer.concat([this.buffer, data]);
  self.<span class="apidocCodeKeywordSpan">handleReceivedData</span>(this);
});
socket.setKeepAlive(true, 60000);

function retry (s) {
  if (s.retrying || s.closing) return;
  s.retrying = true;
  s.retryTimer = setTimeout(function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.hasMetadata" id="apidoc.element.kafka-node.Client.prototype.hasMetadata">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>hasMetadata
        <span class="apidocSignatureSpan">(topic, partition)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasMetadata = function (topic, partition) {
  var brokerMetadata = this.brokerMetadata;
  var leader = this.leaderByPartition(topic, partition);

  return (leader !== undefined) &#x26;&#x26; brokerMetadata[leader];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

Client.prototype.checkMetadatas = function (payloads) {
if (_.isEmpty(this.topicMetadata)) return [ [], payloads ];
// out: [ [metadata exists], [metadata not exists] ]
var out = [ [], [] ];
payloads.forEach(function (p) {
  if (this.<span class="apidocCodeKeywordSpan">hasMetadata</span>(p.topic, p.partition)) out[0].push(p);
  else out[1].push(p);
}.bind(this));
return out;
};

Client.prototype.hasMetadata = function (topic, partition) {
var brokerMetadata = this.brokerMetadata;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.leaderByPartition" id="apidoc.element.kafka-node.Client.prototype.leaderByPartition">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>leaderByPartition
        <span class="apidocSignatureSpan">(topic, partition)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">leaderByPartition = function (topic, partition) {
  var topicMetadata = this.topicMetadata;
  return topicMetadata[topic] &#x26;&#x26; topicMetadata[topic][partition] &#x26;&#x26; topicMetadata[topic][partition].leader;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  else out[1].push(p);
}.bind(this));
return out;
};

Client.prototype.hasMetadata = function (topic, partition) {
var brokerMetadata = this.brokerMetadata;
var leader = this.<span class="apidocCodeKeywordSpan">leaderByPartition</span>(topic, partition);

return (leader !== undefined) &#x26;&#x26; brokerMetadata[leader];
};

Client.prototype.updateMetadatas = function (metadatas) {
// _.extend(this.brokerMetadata, metadatas[0])
_.extend(this.topicMetadata, metadatas[1].metadata);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.loadMetadataForTopics" id="apidoc.element.kafka-node.Client.prototype.loadMetadataForTopics">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>loadMetadataForTopics
        <span class="apidocSignatureSpan">(topics, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadMetadataForTopics = function (topics, cb) {
  var correlationId = this.nextId();
  var request = protocol.encodeMetadataRequest(this.clientId, correlationId, topics);
  var broker = this.brokerForLeader();

  if (!broker || !broker.socket || broker.socket.error || broker.socket.destroyed) {
    return cb(new errors.BrokerNotAvailableError(&#x27;Broker not available&#x27;));
  }

  this.queueCallback(broker.socket, correlationId, [protocol.decodeMetadataResponse, cb]);
  broker.write(request);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

## How do I get a list of all topics?

Call `client.loadMetadataForTopics` with a blank topic array to get the entire list of available topics (and available brokers).

```js
client.once(&#x27;connect&#x27;, function () {
	client.<span class="apidocCodeKeywordSpan">loadMetadataForTopics</span>([], function (error, results) {
	  if (error) {
	  	return console.error(error);
	  }
	  console.log(&#x27;%j&#x27;, _.get(results, &#x27;1.metadata&#x27;));
	});
});
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.nextId" id="apidoc.element.kafka-node.Client.prototype.nextId">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>nextId
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nextId = function () {
  if (this.correlationId &#x3e;= MAX_INT32) {
    this.correlationId = 0;
  }
  return this.correlationId++;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var decoder = protocol.decodeOffsetResponse;
this.send(payloads, encoder, decoder, cb);
};

Client.prototype.sendGroupRequest = function (encode, decode, requestArgs) {
requestArgs = _.values(requestArgs);
var cb = requestArgs.pop();
var correlationId = this.<span class="apidocCodeKeywordSpan">nextId</span>();

requestArgs.unshift(this.clientId, correlationId);

var request = encode.apply(null, requestArgs);
var broker = this.brokerForLeader(this.coordinatorId);

if (!broker || !broker.socket || broker.socket.error || broker.socket.destroyed) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.nextSocketId" id="apidoc.element.kafka-node.Client.prototype.nextSocketId">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>nextSocketId
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nextSocketId = function () {
  return this._socketId++;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  socket = tls.connect(port, host, self.sslOptions);
} else {
  socket = net.createConnection(port, host);
}
socket.addr = host + &#x27;:&#x27; + port;
socket.host = host;
socket.port = port;
socket.socketId = this.<span class="apidocCodeKeywordSpan">nextSocketId</span>();
if (longpolling) socket.longpolling = true;

socket.on(&#x27;connect&#x27;, function () {
  var lastError = this.error;
  this.error = null;
  if (lastError) {
    this.waiting = false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.payloadsByLeader" id="apidoc.element.kafka-node.Client.prototype.payloadsByLeader">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>payloadsByLeader
        <span class="apidocSignatureSpan">(payloads)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">payloadsByLeader = function (payloads) {
  return payloads.reduce(function (out, p) {
    var leader = this.leaderByPartition(p.topic, p.partition);
    out[leader] = out[leader] || [];
    out[leader].push(p);
    return out;
  }.bind(this), {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    self.sendToBroker(payloads[1].concat(payloads[0]), encoder, decoder, cb);
  });
}
};

Client.prototype.sendToBroker = function (payloads, encoder, decoder, cb) {
var longpolling = encoder.name === &#x27;encodeFetchRequest&#x27;;
payloads = this.<span class="apidocCodeKeywordSpan">payloadsByLeader</span>(payloads);
if (!longpolling) {
  cb = wrap(payloads, cb);
}
for (var leader in payloads) {
  if (!payloads.hasOwnProperty(leader)) {
    continue;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.queueCallback" id="apidoc.element.kafka-node.Client.prototype.queueCallback">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>queueCallback
        <span class="apidocSignatureSpan">(socket, id, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">queueCallback = function (socket, id, data) {
  var socketId = socket.socketId;
  var queue;

  if (this.cbqueue.hasOwnProperty(socketId)) {
    queue = this.cbqueue[socketId];
  } else {
    queue = {};
    this.cbqueue[socketId] = queue;
  }

  queue[id] = data;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var request = encode.apply(null, requestArgs);
  var broker = this.brokerForLeader(this.coordinatorId);

  if (!broker || !broker.socket || broker.socket.error || broker.socket.destroyed) {
    return cb(new errors.BrokerNotAvailableError(&#x27;Broker not available&#x27;));
  }

  this.<span class="apidocCodeKeywordSpan">queueCallback</span>(broker.socket, correlationId, [decode, cb]);
  broker.write(request);
};

Client.prototype.sendGroupCoordinatorRequest = function (groupId, cb) {
  this.sendGroupRequest(protocol.encodeGroupCoordinatorRequest, protocol.decodeGroupCoordinatorResponse, arguments);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.reconnectBroker" id="apidoc.element.kafka-node.Client.prototype.reconnectBroker">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>reconnectBroker
        <span class="apidocSignatureSpan">(oldSocket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reconnectBroker = function (oldSocket) {
  oldSocket.retrying = false;
  if (oldSocket.error) {
    oldSocket.destroy();
  }
  var brokers = this.getBrokers(oldSocket.longpolling);
  var newBroker = this.setupBroker(oldSocket.host, oldSocket.port, oldSocket.longpolling, brokers);
  newBroker.socket.error = oldSocket.error;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
socket.setKeepAlive(true, 60000);

function retry (s) {
  if (s.retrying || s.closing) return;
  s.retrying = true;
  s.retryTimer = setTimeout(function () {
    if (s.closing) return;
    self.<span class="apidocCodeKeywordSpan">reconnectBroker</span>(s);
  }, 1000);
}
return new BrokerWrapper(socket, this.noAckBatchOptions);
};

Client.prototype.reconnectBroker = function (oldSocket) {
oldSocket.retrying = false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.refreshBrokers" id="apidoc.element.kafka-node.Client.prototype.refreshBrokers">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>refreshBrokers
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">refreshBrokers = function () {
  var self = this;
  var validBrokers = Object.keys(this.brokerProfiles);

  function closeDeadBrokers (brokers) {
    var deadBrokerKeys = _.difference(Object.keys(brokers), validBrokers);
    if (deadBrokerKeys.length) {
      self.closeBrokers(deadBrokerKeys.map(function (key) {
        var broker = brokers[key];
        delete brokers[key];
        return broker;
      }));
    }
  }

  closeDeadBrokers(this.brokers);
  closeDeadBrokers(this.longpollingBrokers);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
});
zk.on(&#x27;brokersChanged&#x27;, function (brokerMetadata) {
  try {
    self.brokerMetadata = brokerMetadata;
    logger.debug(&#x27;brokersChanged&#x27;, brokerMetadata);
    self.setupBrokerProfiles(brokerMetadata);
    self.<span class="apidocCodeKeywordSpan">refreshBrokers</span>();
    // Emit after a 3 seconds
    setTimeout(function () {
      self.emit(&#x27;brokersChanged&#x27;);
    }, 3000);
  } catch (error) {
    self.emit(&#x27;error&#x27;, error);
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.refreshMetadata" id="apidoc.element.kafka-node.Client.prototype.refreshMetadata">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>refreshMetadata
        <span class="apidocSignatureSpan">(topicNames, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">refreshMetadata = function (topicNames, cb) {
  var self = this;
  if (!topicNames.length) return cb();
  attemptRequestMetadata(topicNames, cb);

  function attemptRequestMetadata (topics, cb) {
    var operation = retry.operation({ minTimeout: 200, maxTimeout: 1000 });
    operation.attempt(function (currentAttempt) {
      logger.debug(&#x27;refresh metadata currentAttempt&#x27;, currentAttempt);
      self.loadMetadataForTopics(topics, function (err, resp) {
        err = err || resp[1].error;
        if (operation.retry(err)) {
          return;
        }
        if (err) {
          logger.debug(&#x27;refresh metadata error&#x27;, err.message);
          return cb(err);
        }
        self.updateMetadatas(resp);
        cb();
      });
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Error:

```
BrokerNotAvailableError: Could not find the leader
```

Call `client.<span class="apidocCodeKeywordSpan">refreshMetadata</span>()` before sending the first message. Reference issue [#354
](https://github.com/SOHU-Co/kafka-node/issues/354)



## How do I debug an issue?
This module uses the [debug module](https://github.com/visionmedia/debug) so you can just run below before starting your app.

```bash
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.removeTopicMetadata" id="apidoc.element.kafka-node.Client.prototype.removeTopicMetadata">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>removeTopicMetadata
        <span class="apidocSignatureSpan">(topics, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeTopicMetadata = function (topics, cb) {
  topics.forEach(function (t) {
    if (this.topicMetadata[t]) delete this.topicMetadata[t];
  }.bind(this));
  cb(null, topics.length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Consumer.prototype.removeTopics = function (topics, cb) {
topics = typeof topics === &#x27;string&#x27; ? [topics] : topics;
this.payloads = this.payloads.filter(function (p) {
  return !~topics.indexOf(p.topic);
});

this.client.<span class="apidocCodeKeywordSpan">removeTopicMetadata</span>(topics, cb);
};

Consumer.prototype.close = function (force, cb) {
this.ready = false;
if (typeof force === &#x27;function&#x27;) {
  cb = force;
  force = false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.send" id="apidoc.element.kafka-node.Client.prototype.send">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>send
        <span class="apidocSignatureSpan">(payloads, encoder, decoder, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">send = function (payloads, encoder, decoder, cb) {
  var self = this;
  var _payloads = payloads;
  // payloads: [ [metadata exists], [metadata not exists] ]
  payloads = this.checkMetadatas(payloads);
  if (payloads[0].length &#x26;&#x26; !payloads[1].length) {
    this.sendToBroker(_.flatten(payloads), encoder, decoder, cb);
    return;
  }
  if (payloads[1].length) {
    var topicNames = payloads[1].map(function (p) { return p.topic; });
    this.loadMetadataForTopics(topicNames, function (err, resp) {
      if (err) {
        return cb(err);
      }

      var error = resp[1].error;
      if (error) {
        return cb(error);
      }

      self.updateMetadatas(resp);
      // check payloads again
      payloads = self.checkMetadatas(_payloads);
      if (payloads[1].length) {
        return cb(new errors.BrokerNotAvailableError(&#x27;Could not find the leader&#x27;));
      }

      self.sendToBroker(payloads[1].concat(payloads[0]), encoder, decoder, cb);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    producer = new Producer(client),
    km = new KeyedMessage(&#x27;key&#x27;, &#x27;message&#x27;),
    payloads = [
        { topic: &#x27;topic1&#x27;, messages: &#x27;hi&#x27;, partition: 0 },
        { topic: &#x27;topic2&#x27;, messages: [&#x27;hello&#x27;, &#x27;world&#x27;, km] }
    ];
producer.on(&#x27;ready&#x27;, function () {
    producer.<span class="apidocCodeKeywordSpan">send</span>(payloads, function (err, data) {
        console.log(data);
    });
});

producer.on(&#x27;error&#x27;, function (err) {})
```
&#x3e; **WARNING**: Batch multiple messages of the same topic/partition together as an array on the `messages` attribute otherwise
 you may lose messages!
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendFetchRequest" id="apidoc.element.kafka-node.Client.prototype.sendFetchRequest">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendFetchRequest
        <span class="apidocSignatureSpan">(consumer, payloads, fetchMaxWaitMs, fetchMinBytes, maxTickMessages)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendFetchRequest = function (consumer, payloads, fetchMaxWaitMs, fetchMinBytes, maxTickMessages) {
  var self = this;
  var encoder = protocol.encodeFetchRequest(fetchMaxWaitMs, fetchMinBytes);
  var decoder = protocol.decodeFetchResponse(function (err, type, message) {
    if (err) {
      if (err.message === &#x27;OffsetOutOfRange&#x27;) {
        return consumer.emit(&#x27;offsetOutOfRange&#x27;, err);
      } else if (err.message === &#x27;NotLeaderForPartition&#x27; || err.message === &#x27;UnknownTopicOrPartition&#x27;) {
        return self.emit(&#x27;brokersChanged&#x27;);
      }

      return consumer.emit(&#x27;error&#x27;, err);
    }

    var encoding = consumer.options.encoding;

    if (type === &#x27;message&#x27;) {
      if (encoding !== &#x27;buffer&#x27; &#x26;&#x26; message.value) {
        message.value = message.value.toString(encoding);
      }

      consumer.emit(&#x27;message&#x27;, message);
    } else {
      consumer.emit(&#x27;done&#x27;, message);
    }
  }, maxTickMessages);

  this.send(payloads, encoder, decoder, function (err) {
    if (err) {
      Array.prototype.unshift.call(arguments, &#x27;error&#x27;);
      consumer.emit.apply(consumer, arguments);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    cb(null, &#x27;Nothing to be committed&#x27;);
  }
}
Consumer.prototype.commit = Consumer.prototype.autoCommit = autoCommit;

Consumer.prototype.fetch = function () {
  if (!this.ready || this.paused) return;
  this.client.<span class="apidocCodeKeywordSpan">sendFetchRequest</span>(this, this.payloads, this.options.fetchMaxWaitMs, this
.options.fetchMinBytes);
};

Consumer.prototype.fetchOffset = function (payloads, cb) {
  this.client.sendOffsetFetchRequest(this.options.groupId, payloads, cb);
};

Consumer.prototype.addTopics = function (topics, cb, fromOffset) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendGroupCoordinatorRequest" id="apidoc.element.kafka-node.Client.prototype.sendGroupCoordinatorRequest">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendGroupCoordinatorRequest
        <span class="apidocSignatureSpan">(groupId, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendGroupCoordinatorRequest = function (groupId, cb) {
  this.sendGroupRequest(protocol.encodeGroupCoordinatorRequest, protocol.decodeGroupCoordinatorResponse, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.emit(&#x27;rebalancing&#x27;);

  async.waterfall([
function (callback) {
  if (self.client.coordinatorId) {
    return callback(null, null);
  }
  self.client.<span class="apidocCodeKeywordSpan">sendGroupCoordinatorRequest</span>(self.options.groupId, callback);
},

function (coordinatorInfo, callback) {
  logger.debug(&#x27;GroupCoordinator Response:&#x27;, coordinatorInfo);
  if (coordinatorInfo) {
    self.setCoordinatorId(coordinatorInfo.coordinatorId);
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendGroupRequest" id="apidoc.element.kafka-node.Client.prototype.sendGroupRequest">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendGroupRequest
        <span class="apidocSignatureSpan">(encode, decode, requestArgs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendGroupRequest = function (encode, decode, requestArgs) {
  requestArgs = _.values(requestArgs);
  var cb = requestArgs.pop();
  var correlationId = this.nextId();

  requestArgs.unshift(this.clientId, correlationId);

  var request = encode.apply(null, requestArgs);
  var broker = this.brokerForLeader(this.coordinatorId);

  if (!broker || !broker.socket || broker.socket.error || broker.socket.destroyed) {
    return cb(new errors.BrokerNotAvailableError(&#x27;Broker not available&#x27;));
  }

  this.queueCallback(broker.socket, correlationId, [decode, cb]);
  broker.write(request);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var decoder = protocol.decodeOffsetCommitResponse;
  this.send(payloads, encoder, decoder, cb);
};

Client.prototype.sendOffsetCommitV2Request = function (group, generationId, memberId, payloads, cb) {
  var encoder = protocol.encodeOffsetCommitV2Request;
  var decoder = protocol.decodeOffsetCommitResponse;
  this.<span class="apidocCodeKeywordSpan">sendGroupRequest</span>(encoder, decoder, arguments);
};

Client.prototype.sendOffsetFetchV1Request = function (group, payloads, cb) {
  var encoder = protocol.encodeOffsetFetchV1Request;
  var decoder = protocol.decodeOffsetFetchV1Response;
  this.sendGroupRequest(encoder, decoder, arguments);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendHeartbeatRequest" id="apidoc.element.kafka-node.Client.prototype.sendHeartbeatRequest">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendHeartbeatRequest
        <span class="apidocSignatureSpan">(groupId, generationId, memberId, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendHeartbeatRequest = function (groupId, generationId, memberId, cb) {
  this.sendGroupRequest(protocol.encodeGroupHeartbeat, protocol.decodeGroupHeartbeat, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
constructor (client, handler) {
  this.client = client;
  this.handler = handler;
  this.pending = true;
}

send (groupId, generationId, memberId) {
  this.client.<span class="apidocCodeKeywordSpan">sendHeartbeatRequest</span>(groupId, generationId, memberId, (error) =&#x3e; {
    if (this.canceled) {
      logger.debug(&#x27;heartbeat yielded after being canceled&#x27;, error);
      return;
    }
    this.pending = false;
    this.handler(error);
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendJoinGroupRequest" id="apidoc.element.kafka-node.Client.prototype.sendJoinGroupRequest">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendJoinGroupRequest
        <span class="apidocSignatureSpan">(groupId, memberId, sessionTimeout, groupProtocol, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendJoinGroupRequest = function (groupId, memberId, sessionTimeout, groupProtocol, cb) {
  this.sendGroupRequest(protocol.encodeJoinGroupRequest, protocol.decodeJoinGroupResponse, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

function (coordinatorInfo, callback) {
  logger.debug(&#x27;GroupCoordinator Response:&#x27;, coordinatorInfo);
  if (coordinatorInfo) {
    self.setCoordinatorId(coordinatorInfo.coordinatorId);
  }
  self.client.<span class="apidocCodeKeywordSpan">sendJoinGroupRequest</span>(self.options.groupId, emptyStrIfNull(self.memberId
), self.options.sessionTimeout, self.protocols, callback);
},

function (joinGroupResponse, callback) {
  self.handleJoinGroup(joinGroupResponse, callback);
},

function (groupAssignment, callback) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendLeaveGroupRequest" id="apidoc.element.kafka-node.Client.prototype.sendLeaveGroupRequest">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendLeaveGroupRequest
        <span class="apidocSignatureSpan">(groupId, memberId, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendLeaveGroupRequest = function (groupId, memberId, cb) {
  this.sendGroupRequest(protocol.encodeLeaveGroupRequest, protocol.decodeLeaveGroupResponse, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

ConsumerGroup.prototype.leaveGroup = function (callback) {
  logger.debug(&#x27;%s leaving group&#x27;, this.client.clientId);
  var self = this;
  this.stopHeartbeats();
  if (self.generationId != null &#x26;&#x26; self.memberId) {
    this.client.<span class="apidocCodeKeywordSpan">sendLeaveGroupRequest</span>(this.options.groupId, this.memberId, function (
error) {
      self.generationId = null;
      callback(error);
    });
  } else {
    callback(null);
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendOffsetCommitRequest" id="apidoc.element.kafka-node.Client.prototype.sendOffsetCommitRequest">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendOffsetCommitRequest
        <span class="apidocSignatureSpan">(group, payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendOffsetCommitRequest = function (group, payloads, cb) {
  var encoder = protocol.encodeOffsetCommitRequest(group);
  var decoder = protocol.decodeOffsetCommitResponse;
  this.send(payloads, encoder, decoder, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }.bind(this), this.options.autoCommitIntervalMs);

  var payloads = this.payloads;
  if (this.pausedPayloads) payloads = payloads.concat(this.pausedPayloads);

  var commits = payloads.filter(function (p) { return p.offset !== 0; });
  if (commits.length) {
    this.client.<span class="apidocCodeKeywordSpan">sendOffsetCommitRequest</span>(this.options.groupId, commits, cb);
  } else {
    cb(null, &#x27;Nothing to be committed&#x27;);
  }
}
Consumer.prototype.commit = Consumer.prototype.autoCommit = autoCommit;

Consumer.prototype.fetch = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendOffsetCommitV2Request" id="apidoc.element.kafka-node.Client.prototype.sendOffsetCommitV2Request">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendOffsetCommitV2Request
        <span class="apidocSignatureSpan">(group, generationId, memberId, payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendOffsetCommitV2Request = function (group, generationId, memberId, payloads, cb) {
  var encoder = protocol.encodeOffsetCommitV2Request;
  var decoder = protocol.decodeOffsetCommitResponse;
  this.sendGroupRequest(encoder, decoder, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

ConsumerGroup.prototype.fetchOffset = function (payloads, cb) {
this.client.sendOffsetFetchV1Request(this.options.groupId, payloads, cb);
};

ConsumerGroup.prototype.sendOffsetCommitRequest = function (commits, cb) {
if (this.generationId &#x26;&#x26; this.memberId) {
  this.client.<span class="apidocCodeKeywordSpan">sendOffsetCommitV2Request</span>(this.options.groupId, this.generationId, this
.memberId, commits, cb);
} else {
  cb(null, &#x27;Nothing to be committed&#x27;);
}
};

ConsumerGroup.prototype.close = function (force, cb) {
var self = this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendOffsetFetchRequest" id="apidoc.element.kafka-node.Client.prototype.sendOffsetFetchRequest">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendOffsetFetchRequest
        <span class="apidocSignatureSpan">(group, payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendOffsetFetchRequest = function (group, payloads, cb) {
  var encoder = protocol.encodeOffsetFetchRequest(group);
  var decoder = protocol.decodeOffsetFetchResponse;
  this.send(payloads, encoder, decoder, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }
);
};

ConsumerGroupMigrator.prototype.saveHighLevelConsumerOffsets = function (topicPartitionList, callback) {
const self = this;
this.client.<span class="apidocCodeKeywordSpan">sendOffsetFetchRequest</span>(this.consumerGroup.options.groupId, topicPartitionList
, function (error, results) {
  logger.debug(&#x27;sendOffsetFetchRequest response:&#x27;, results, error);
  if (error) {
    return callback(error);
  }
  self.offsets = results;
  callback(null);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendOffsetFetchV1Request" id="apidoc.element.kafka-node.Client.prototype.sendOffsetFetchV1Request">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendOffsetFetchV1Request
        <span class="apidocSignatureSpan">(group, payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendOffsetFetchV1Request = function (group, payloads, cb) {
  var encoder = protocol.encodeOffsetFetchV1Request;
  var decoder = protocol.decodeOffsetFetchV1Response;
  this.sendGroupRequest(encoder, decoder, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
const heartbeat = new Heartbeat(this.client, heartbeatCallback);
heartbeat.send(this.options.groupId, this.generationId, this.memberId);

return heartbeat;
};

ConsumerGroup.prototype.fetchOffset = function (payloads, cb) {
this.client.<span class="apidocCodeKeywordSpan">sendOffsetFetchV1Request</span>(this.options.groupId, payloads, cb);
};

ConsumerGroup.prototype.sendOffsetCommitRequest = function (commits, cb) {
if (this.generationId &#x26;&#x26; this.memberId) {
  this.client.sendOffsetCommitV2Request(this.options.groupId, this.generationId, this.memberId, commits, cb);
} else {
  cb(null, &#x27;Nothing to be committed&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendOffsetRequest" id="apidoc.element.kafka-node.Client.prototype.sendOffsetRequest">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendOffsetRequest
        <span class="apidocSignatureSpan">(payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendOffsetRequest = function (payloads, cb) {
  var encoder = protocol.encodeOffsetRequest;
  var decoder = protocol.decodeOffsetResponse;
  this.send(payloads, encoder, decoder, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

HighLevelConsumer.prototype.fetchOffset = function (payloads, cb) {
 logger.debug(&#x27;in fetchOffset %s payloads: %j&#x27;, this.id, payloads);
 this.client.sendOffsetFetchRequest(this.options.groupId, payloads, cb);
};

HighLevelConsumer.prototype.offsetRequest = function (payloads, cb) {
 this.client.<span class="apidocCodeKeywordSpan">sendOffsetRequest</span>(payloads, cb);
};

/**
* Register a consumer against a group
*
* @param consumer to register
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendProduceRequest" id="apidoc.element.kafka-node.Client.prototype.sendProduceRequest">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendProduceRequest
        <span class="apidocSignatureSpan">(payloads, requireAcks, ackTimeoutMs, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendProduceRequest = function (payloads, requireAcks, ackTimeoutMs, cb) {
  var encoder = protocol.encodeProduceRequest(requireAcks, ackTimeoutMs);
  var decoder = protocol.decodeProduceResponse;
  var self = this;

  decoder.requireAcks = requireAcks;

  async.each(payloads, buildRequest, function (err) {
    if (err) return cb(err);
    self.send(payloads, encoder, decoder, function (err, result) {
      if (err) {
        if (err.message === &#x27;NotLeaderForPartition&#x27;) {
          self.emit(&#x27;brokersChanged&#x27;);
        }
        cb(err);
      } else {
        cb(null, result);
      }
    });
  });

  function buildRequest (payload, cb) {
    var attributes = payload.attributes;
    var codec = getCodec(attributes);

    if (!codec) return cb();

    var innerSet = encodeMessageSet(payload.messages);
    codec.encode(innerSet, function (err, message) {
      if (err) return cb(err);
      payload.messages = [ new Message(0, attributes, &#x27;&#x27;, message) ];
      cb();
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {BaseProducer~sendCallback} cb A function to call once the send has completed
 */
BaseProducer.prototype.send = function (payloads, cb) {
var client = this.client;
var requireAcks = this.requireAcks;
var ackTimeoutMs = this.ackTimeoutMs;

client.<span class="apidocCodeKeywordSpan">sendProduceRequest</span>(this.buildPayloads(payloads, client.topicMetadata), requireAcks
, ackTimeoutMs, cb);
};

BaseProducer.prototype.buildPayloads = function (payloads, topicMetadata) {
const topicPartitionRequests = Object.create(null);
payloads.forEach((p) =&#x3e; {
  p.partition = p.hasOwnProperty(&#x27;partition&#x27;) ? p.partition : this.partitioner.getPartition(_.map(topicMetadata[p.topic
], &#x27;partition&#x27;), p.key);
  p.attributes = p.hasOwnProperty(&#x27;attributes&#x27;) ? p.attributes : 0;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendSyncGroupRequest" id="apidoc.element.kafka-node.Client.prototype.sendSyncGroupRequest">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendSyncGroupRequest
        <span class="apidocSignatureSpan">(groupId, generationId, memberId, groupAssignment, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendSyncGroupRequest = function (groupId, generationId, memberId, groupAssignment, cb) {
  this.sendGroupRequest(protocol.encodeSyncGroupRequest, protocol.decodeSyncGroupResponse, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  function (joinGroupResponse, callback) {
    self.handleJoinGroup(joinGroupResponse, callback);
  },

  function (groupAssignment, callback) {
    logger.debug(&#x27;SyncGroup Request from %s&#x27;, self.memberId);
    self.client.<span class="apidocCodeKeywordSpan">sendSyncGroupRequest</span>(self.options.groupId, self.generationId, self.memberId
, groupAssignment, callback);
  },

  function (syncGroupResponse, callback) {
    self.handleSyncGroup(syncGroupResponse, callback);
  }
], function (error, startFetch) {
  self.connecting = false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.sendToBroker" id="apidoc.element.kafka-node.Client.prototype.sendToBroker">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>sendToBroker
        <span class="apidocSignatureSpan">(payloads, encoder, decoder, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendToBroker = function (payloads, encoder, decoder, cb) {
  var longpolling = encoder.name === &#x27;encodeFetchRequest&#x27;;
  payloads = this.payloadsByLeader(payloads);
  if (!longpolling) {
    cb = wrap(payloads, cb);
  }
  for (var leader in payloads) {
    if (!payloads.hasOwnProperty(leader)) {
      continue;
    }
    var correlationId = this.nextId();
    var request = encoder(this.clientId, correlationId, payloads[leader]);
    var broker = this.brokerForLeader(leader, longpolling);
    if (!broker || !broker.socket || broker.socket.error || broker.socket.closing || broker.socket.destroyed) {
      return cb(new errors.BrokerNotAvailableError(&#x27;Could not find the leader&#x27;), payloads[leader]);
    }

    if (longpolling) {
      if (broker.socket.waiting) continue;
      broker.socket.waiting = true;
    }

    if (decoder.requireAcks === 0) {
      broker.writeAsync(request);
      cb(null, { result: &#x27;no ack&#x27; });
    } else {
      this.queueCallback(broker.socket, correlationId, [decoder, cb]);
      broker.write(request);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Client.prototype.send = function (payloads, encoder, decoder, cb) {
var self = this;
var _payloads = payloads;
// payloads: [ [metadata exists], [metadata not exists] ]
payloads = this.checkMetadatas(payloads);
if (payloads[0].length &#x26;&#x26; !payloads[1].length) {
  this.<span class="apidocCodeKeywordSpan">sendToBroker</span>(_.flatten(payloads), encoder, decoder, cb);
  return;
}
if (payloads[1].length) {
  var topicNames = payloads[1].map(function (p) { return p.topic; });
  this.loadMetadataForTopics(topicNames, function (err, resp) {
    if (err) {
      return cb(err);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.setupBroker" id="apidoc.element.kafka-node.Client.prototype.setupBroker">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>setupBroker
        <span class="apidocSignatureSpan">(host, port, longpolling, brokers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setupBroker = function (host, port, longpolling, brokers) {
  var brokerKey = host + &#x27;:&#x27; + port;
  brokers[brokerKey] = this.createBroker(host, port, longpolling);
  return brokers[brokerKey];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  self.ready = true;
  self.brokerMetadata = brokers;
  self.setupBrokerProfiles(brokers);
  Object
      .keys(self.brokerProfiles)
      .some(function (key, index) {
        var broker = self.brokerProfiles[key];
        self.<span class="apidocCodeKeywordSpan">setupBroker</span>(broker.host, broker.port, false, self.brokers);
        // Only connect one broker
        return !index;
      });
  self.emit(&#x27;ready&#x27;);
} catch (error) {
  self.ready = false;
  self.emit(&#x27;error&#x27;, error);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.setupBrokerProfiles" id="apidoc.element.kafka-node.Client.prototype.setupBrokerProfiles">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>setupBrokerProfiles
        <span class="apidocSignatureSpan">(brokers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setupBrokerProfiles = function (brokers) {
  this.brokerProfiles = Object.create(null);
  var self = this;
  var protocol = self.ssl ? &#x27;ssl:&#x27; : &#x27;plaintext:&#x27;;

  Object.keys(brokers).forEach(function (key) {
    var brokerProfile = brokers[key];
    var addr;

    if (brokerProfile.endpoints &#x26;&#x26; brokerProfile.endpoints.length) {
      var endpoint = _.find(brokerProfile.endpoints, function (endpoint) {
        return url.parse(endpoint).protocol === protocol;
      });

      if (endpoint == null) {
        throw new Error([&#x27;No kafka endpoint found for broker: &#x27;, key, &#x27; with protocol &#x27;, protocol].join(&#x27;&#x27;));
      }

      var endpointUrl = url.parse(endpoint);

      addr = endpointUrl.hostname + &#x27;:&#x27; + endpointUrl.port;

      brokerProfile.host = endpointUrl.hostname;
      brokerProfile.port = endpointUrl.port;
    } else {
      addr = brokerProfile.host + &#x27;:&#x27; + brokerProfile.port;
    }
    assert(brokerProfile.host &#x26;&#x26; brokerProfile.port, &#x27;kafka host or port is empty&#x27;);

    self.brokerProfiles[addr] = brokerProfile;
    self.brokerProfiles[addr].id = key;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Client.prototype.connect = function () {
var zk = this.zk = new Zookeeper(this.connectionString, this.zkOptions);
var self = this;
zk.once(&#x27;init&#x27;, function (brokers) {
  try {
    self.ready = true;
    self.brokerMetadata = brokers;
    self.<span class="apidocCodeKeywordSpan">setupBrokerProfiles</span>(brokers);
    Object
        .keys(self.brokerProfiles)
        .some(function (key, index) {
          var broker = self.brokerProfiles[key];
          self.setupBroker(broker.host, broker.port, false, self.brokers);
          // Only connect one broker
          return !index;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.topicExists" id="apidoc.element.kafka-node.Client.prototype.topicExists">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>topicExists
        <span class="apidocSignatureSpan">(topics, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">topicExists = function (topics, cb) {
  var notExistsTopics = [];
  var self = this;

  async.each(topics, checkZK, function (err) {
    if (err) return cb(err);
    if (notExistsTopics.length) return cb(new errors.TopicsNotExistError(notExistsTopics));
    cb();
  });

  function checkZK (topic, cb) {
    self.zk.topicExists(topic, function (err, existed, topic) {
      if (err) return cb(err);
      if (!existed) notExistsTopics.push(topic);
      cb();
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  async.each(topics, checkZK, function (err) {
    if (err) return cb(err);
    if (notExistsTopics.length) return cb(new errors.TopicsNotExistError(notExistsTopics));
    cb();
  });

  function checkZK (topic, cb) {
    self.zk.<span class="apidocCodeKeywordSpan">topicExists</span>(topic, function (err, existed, topic) {
      if (err) return cb(err);
      if (!existed) notExistsTopics.push(topic);
      cb();
    });
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.unqueueCallback" id="apidoc.element.kafka-node.Client.prototype.unqueueCallback">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>unqueueCallback
        <span class="apidocSignatureSpan">(socket, id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unqueueCallback = function (socket, id) {
  var socketId = socket.socketId;

  if (!this.cbqueue.hasOwnProperty(socketId)) {
    return null;
  }

  var queue = this.cbqueue[socketId];
  if (!queue.hasOwnProperty(id)) {
    return null;
  }

  var result = queue[id];

  // cleanup socket queue
  delete queue[id];
  if (!Object.keys(queue).length) {
    delete this.cbqueue[socketId];
  }

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Client.prototype.handleReceivedData = function (socket) {
  var vars = Binary.parse(socket.buffer).word32bu(&#x27;size&#x27;).word32bu(&#x27;correlationId&#x27;).vars;
  var size = vars.size + 4;
  var correlationId = vars.correlationId;

  if (socket.buffer.length &#x3e;= size) {
var resp = socket.buffer.slice(0, size);
var handlers = this.<span class="apidocCodeKeywordSpan">unqueueCallback</span>(socket, correlationId);

if (!handlers) return;
var decoder = handlers[0];
var cb = handlers[1];
var result = decoder(resp);
(result instanceof Error)
  ? cb.call(this, result)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Client.prototype.updateMetadatas" id="apidoc.element.kafka-node.Client.prototype.updateMetadatas">
        function <span class="apidocSignatureSpan">kafka-node.Client.prototype.</span>updateMetadatas
        <span class="apidocSignatureSpan">(metadatas)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateMetadatas = function (metadatas) {
  // _.extend(this.brokerMetadata, metadatas[0])
  _.extend(this.topicMetadata, metadatas[1].metadata);
  for (var topic in this.topicMetadata) {
    if (!this.topicMetadata.hasOwnProperty(topic)) {
      continue;
    }
    this.topicPartitions[topic] = Object.keys(this.topicMetadata[topic]).map(function (val) {
      return parseInt(val, 10);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Client.prototype.addTopics = function (topics, cb) {
var self = this;
this.topicExists(topics, function (err) {
  if (err) return cb(err);
  self.loadMetadataForTopics(topics, function (err, resp) {
    if (err) return cb(err);
    self.<span class="apidocCodeKeywordSpan">updateMetadatas</span>(resp);
    cb(null, topics);
  });
});
};

Client.prototype.nextId = function () {
if (this.correlationId &#x3e;= MAX_INT32) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Consumer" id="apidoc.module.kafka-node.Consumer">module kafka-node.Consumer</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.Consumer" id="apidoc.element.kafka-node.Consumer.Consumer">
        function <span class="apidocSignatureSpan">kafka-node.</span>Consumer
        <span class="apidocSignatureSpan">(client, topics, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Consumer = function (client, topics, options) {
  if (!topics) {
    throw new Error(&#x27;Must have payloads&#x27;);
  }

  utils.validateTopics(topics);

  this.fetchCount = 0;
  this.client = client;
  this.options = _.defaults((options || {}), DEFAULTS);
  this.ready = false;
  this.paused = this.options.paused;
  this.id = nextId();
  this.payloads = this.buildPayloads(topics);
  this.connect();
  this.encoding = this.options.encoding;

  if (this.options.groupId) {
    utils.validateConfig(&#x27;options.groupId&#x27;, this.options.groupId);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.super_" id="apidoc.element.kafka-node.Consumer.super_">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Consumer.prototype" id="apidoc.module.kafka-node.Consumer.prototype">module kafka-node.Consumer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.addTopics" id="apidoc.element.kafka-node.Consumer.prototype.addTopics">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>addTopics
        <span class="apidocSignatureSpan">(topics, cb, fromOffset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addTopics = function (topics, cb, fromOffset) {
  fromOffset = !!fromOffset;
  var self = this;
  if (!this.ready) {
    setTimeout(function () {
      self.addTopics(topics, cb, fromOffset);
    }
    , 100);
    return;
  }

  // The default is that the topics is a string array of topic names
  var topicNames = topics;

  // If the topics is actually an object and not string we assume it is an array of payloads
  if (typeof topics[0] === &#x27;object&#x27;) {
    topicNames = topics.map(function (p) { return p.topic; });
  }

  this.client.addTopics(
    topicNames,
    function (err, added) {
      if (err) return cb &#x26;&#x26; cb(err, added);

      var payloads = self.buildPayloads(topics);
      var reFetch = !self.payloads.length;

      if (fromOffset) {
        payloads.forEach(function (p) {
          self.payloads.push(p);
        });
        if (reFetch) self.fetch();
        cb &#x26;&#x26; cb(null, added);
        return;
      }

      // update offset of topics that will be added
      self.fetchOffset(payloads, function (err, offsets) {
        if (err) return cb(err);
        payloads.forEach(function (p) {
          var offset = offsets[p.topic][p.partition];
          if (offset === -1) offset = 0;
          p.offset = offset;
          self.payloads.push(p);
        });
        if (reFetch) self.fetch();
        cb &#x26;&#x26; cb(null, added);
      });
    }
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `topics`: **Array**, array of topics to add
* `cb`: **Function**,the callback
* `fromOffset`: **Boolean**, if true, the consumer will fetch message from the specified offset, otherwise it will fetch message
 from the last commited offset of the topic.

Example:

``` js
consumer.<span class="apidocCodeKeywordSpan">addTopics</span>([&#x27;t1&#x27;, &#x27;t2&#x27;], function (err, added) {
});

or

consumer.addTopics([{ topic: &#x27;t1&#x27;, offset: 10 }], function (err, added) {
}, true);
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.autoCommit" id="apidoc.element.kafka-node.Consumer.prototype.autoCommit">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>autoCommit
        <span class="apidocSignatureSpan">(force, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function autoCommit(force, cb) {
  if (arguments.length === 1) {
    cb = force;
    force = false;
  }

  if (this.committing &#x26;&#x26; !force) return cb(null, &#x27;Offset committing&#x27;);

  this.committing = true;
  setTimeout(function () {
    this.committing = false;
  }.bind(this), this.options.autoCommitIntervalMs);

  var payloads = this.payloads;
  if (this.pausedPayloads) payloads = payloads.concat(this.pausedPayloads);

  var commits = payloads.filter(function (p) { return p.offset !== 0; });
  if (commits.length) {
    this.client.sendOffsetCommitRequest(this.options.groupId, commits, cb);
  } else {
    cb(null, &#x27;Nothing to be committed&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (offset === -1) offset = 0;
    if (!initing) p.offset = offset + 1;
    else p.offset = offset;
  }
});

if (this.options.autoCommit &#x26;&#x26; !initing) {
  this.<span class="apidocCodeKeywordSpan">autoCommit</span>(false, function (err) {
    err &#x26;&#x26; logger.debug(&#x27;auto commit offset&#x27;, err);
  });
}
};

function autoCommit (force, cb) {
if (arguments.length === 1) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.buildPayloads" id="apidoc.element.kafka-node.Consumer.prototype.buildPayloads">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>buildPayloads
        <span class="apidocSignatureSpan">(payloads)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildPayloads = function (payloads) {
  var self = this;
  return payloads.map(function (p) {
    if (typeof p !== &#x27;object&#x27;) p = { topic: p };
    p.partition = p.partition || 0;
    p.offset = p.offset || 0;
    p.maxBytes = self.options.fetchMaxBytes;
    p.metadata = &#x27;m&#x27;; // metadata can be arbitrary
    return p;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {BaseProducer~sendCallback} cb A function to call once the send has completed
 */
BaseProducer.prototype.send = function (payloads, cb) {
var client = this.client;
var requireAcks = this.requireAcks;
var ackTimeoutMs = this.ackTimeoutMs;

client.sendProduceRequest(this.<span class="apidocCodeKeywordSpan">buildPayloads</span>(payloads, client.topicMetadata), requireAcks
, ackTimeoutMs, cb);
};

BaseProducer.prototype.buildPayloads = function (payloads, topicMetadata) {
const topicPartitionRequests = Object.create(null);
payloads.forEach((p) =&#x3e; {
  p.partition = p.hasOwnProperty(&#x27;partition&#x27;) ? p.partition : this.partitioner.getPartition(_.map(topicMetadata[p.topic
], &#x27;partition&#x27;), p.key);
  p.attributes = p.hasOwnProperty(&#x27;attributes&#x27;) ? p.attributes : 0;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.close" id="apidoc.element.kafka-node.Consumer.prototype.close">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>close
        <span class="apidocSignatureSpan">(force, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (force, cb) {
  this.ready = false;
  if (typeof force === &#x27;function&#x27;) {
    cb = force;
    force = false;
  }

  if (force) {
    this.commit(force, function (err) {
      if (err) {
        return cb(err);
      }
      this.client.close(cb);
    }.bind(this));
  } else {
    this.client.close(cb);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### close(force, cb)
* `force`: **Boolean**, if set to true, it forces the consumer to commit the current offset before closing, default `false`

Example

```js
consumer.<span class="apidocCodeKeywordSpan">close</span>(true, cb);
consumer.close(cb); //force is disabled
```

## HighLevelConsumer
 ***This consumer has been deprecated in the latest version of Kafka (0.10.1) and is likely to be removed in the future. Please
 use the ConsumerGroup instead.***

### HighLevelConsumer(client, payloads, options)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.commit" id="apidoc.element.kafka-node.Consumer.prototype.commit">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>commit
        <span class="apidocSignatureSpan">(force, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function autoCommit(force, cb) {
  if (arguments.length === 1) {
    cb = force;
    force = false;
  }

  if (this.committing &#x26;&#x26; !force) return cb(null, &#x27;Offset committing&#x27;);

  this.committing = true;
  setTimeout(function () {
    this.committing = false;
  }.bind(this), this.options.autoCommitIntervalMs);

  var payloads = this.payloads;
  if (this.pausedPayloads) payloads = payloads.concat(this.pausedPayloads);

  var commits = payloads.filter(function (p) { return p.offset !== 0; });
  if (commits.length) {
    this.client.sendOffsetCommitRequest(this.options.groupId, commits, cb);
  } else {
    cb(null, &#x27;Nothing to be committed&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Commit offset of the current topics manually, this method should be called when a consumer leaves

* `cb`: **Function**, the callback

Example:

``` js
consumer.<span class="apidocCodeKeywordSpan">commit</span>(function(err, data) {
});
```

### setOffset(topic, partition, offset)
Set offset of the given topic

* `topic`: **String**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.connect" id="apidoc.element.kafka-node.Consumer.prototype.connect">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>connect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connect = function () {
  var self = this;
  // Client already exists
  this.ready = this.client.ready;
  if (this.ready) this.init();

  this.client.on(&#x27;ready&#x27;, function () {
    logger.debug(&#x27;consumer ready&#x27;);
    if (!self.ready) self.init();
    self.ready = true;
  });

  this.client.on(&#x27;error&#x27;, function (err) {
    logger.error(&#x27;client error %s&#x27;, err.message);
    self.emit(&#x27;error&#x27;, err);
  });

  this.client.on(&#x27;close&#x27;, function () {
    logger.debug(&#x27;connection closed&#x27;);
  });

  this.client.on(&#x27;brokersChanged&#x27;, function () {
    var topicNames = self.payloads.map(function (p) {
      return p.topic;
    });

    this.refreshMetadata(topicNames, function (err) {
      if (err) return self.emit(&#x27;error&#x27;, err);
      self.fetch();
    });
  });
  // &#x27;done&#x27; will be emit when a message fetch request complete
  this.on(&#x27;done&#x27;, function (topics) {
    self.updateOffsets(topics);
    setImmediate(function () {
      self.fetch();
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

var partitionerType = PARTITIONER_MAP[options.partitionerType] || PARTITIONER_MAP[defaultPartitionerType];

// eslint-disable-next-line
this.partitioner = new partitionerType(customPartitioner);

this.<span class="apidocCodeKeywordSpan">connect</span>();
}

util.inherits(BaseProducer, events.EventEmitter);

BaseProducer.prototype.connect = function () {
// emiter...
var self = this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.fetch" id="apidoc.element.kafka-node.Consumer.prototype.fetch">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>fetch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetch = function () {
  if (!this.ready || this.paused) return;
  this.client.sendFetchRequest(this, this.payloads, this.options.fetchMaxWaitMs, this.options.fetchMinBytes);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Example

```js
var kafka = require(&#x27;kafka-node&#x27;),
    client = new kafka.Client(),
    offset = new kafka.Offset(client);
    offset.<span class="apidocCodeKeywordSpan">fetch</span>([
        { topic: &#x27;t&#x27;, partition: 0, time: Date.now(), maxNum: 1 }
    ], function (err, data) {
        // data
        // { &#x27;t&#x27;: { &#x27;0&#x27;: [999] } }
    });
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.fetchOffset" id="apidoc.element.kafka-node.Consumer.prototype.fetchOffset">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>fetchOffset
        <span class="apidocSignatureSpan">(payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetchOffset = function (payloads, cb) {
  this.client.sendOffsetFetchRequest(this.options.groupId, payloads, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    logger.debug(&#x27;%s owns topics: &#x27;, self.client.clientId, syncGroupResponse.partitions);

    const topicPartitionList = createTopicPartitionList(syncGroupResponse.partitions);
    const useDefaultOffsets = self.options.fromOffset in ACCEPTED_FROM_OFFSET;

    async.waterfall([
      function (callback) {
self.<span class="apidocCodeKeywordSpan">fetchOffset</span>(syncGroupResponse.partitions, callback);
      },
      function (offsets, callback) {
logger.debug(&#x27;%s fetchOffset Response: %j&#x27;, self.client.clientId, offsets);

var noOffset = topicPartitionList.some(function (tp) {
  return offsets[tp.topic][tp.partition] === -1;
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.init" id="apidoc.element.kafka-node.Consumer.prototype.init">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>init
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init = function () {
  if (!this.payloads.length) {
    return;
  }

  var self = this;
  var topics = self.payloads.map(function (p) { return p.topic; });

  self.client.topicExists(topics, function (err) {
    if (err) {
      return self.emit(&#x27;error&#x27;, err);
    }

    if (self.options.fromOffset) {
      return self.fetch();
    }

    self.fetchOffset(self.payloads, function (err, topics) {
      if (err) {
        return self.emit(&#x27;error&#x27;, err);
      }

      self.updateOffsets(topics, true);
      self.fetch();
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
};

Consumer.prototype.connect = function () {
var self = this;
// Client already exists
this.ready = this.client.ready;
if (this.ready) this.<span class="apidocCodeKeywordSpan">init</span>();

this.client.on(&#x27;ready&#x27;, function () {
  logger.debug(&#x27;consumer ready&#x27;);
  if (!self.ready) self.init();
  self.ready = true;
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.pause" id="apidoc.element.kafka-node.Consumer.prototype.pause">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>pause
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pause = function () {
  this.paused = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    } else if (!self.connecting) {
      self.fetch();
    }
  });
}, 200);

this.client.on(&#x27;brokersChanged&#x27;, function () {
  self.<span class="apidocCodeKeywordSpan">pause</span>();
  recoverFromBrokerChange();
});

this.client.on(&#x27;reconnect&#x27;, function (lastError) {
  self.fetch();
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.pauseTopics" id="apidoc.element.kafka-node.Consumer.prototype.pauseTopics">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>pauseTopics
        <span class="apidocSignatureSpan">(topics)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pauseTopics = function (topics) {
  if (!this.pausedPayloads) this.pausedPayloads = [];
  pauseOrResume(this.payloads, this.pausedPayloads, topics);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### resume()
Resume the consumer. Resumes the fetch loop.

### pauseTopics(topics)
Pause specify topics

```
consumer.<span class="apidocCodeKeywordSpan">pauseTopics</span>([
    &#x27;topic1&#x27;,
    { topic: &#x27;topic2&#x27;, partition: 0 }
]);
```

### resumeTopics(topics)
Resume specify topics
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.removeTopics" id="apidoc.element.kafka-node.Consumer.prototype.removeTopics">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>removeTopics
        <span class="apidocSignatureSpan">(topics, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeTopics = function (topics, cb) {
  topics = typeof topics === &#x27;string&#x27; ? [topics] : topics;
  this.payloads = this.payloads.filter(function (p) {
    return !~topics.indexOf(p.topic);
  });

  this.client.removeTopicMetadata(topics, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### removeTopics(topics, cb)
* `topics`: **Array**, array of topics to remove
* `cb`: **Function**, the callback

Example:

``` js
consumer.<span class="apidocCodeKeywordSpan">removeTopics</span>([&#x27;t1&#x27;, &#x27;t2&#x27;], function (err, removed) {
});
```

### commit(cb)
Commit offset of the current topics manually, this method should be called when a consumer leaves

* `cb`: **Function**, the callback
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.resume" id="apidoc.element.kafka-node.Consumer.prototype.resume">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>resume
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resume = function () {
  this.paused = false;
  this.fetch();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
    const offset = _.head(result[topic.topic][topic.partition]);
    const oldOffset = _.find(this.topicPayloads, {topic: topic.topic, partition: topic.partition}).offset;

    logger.debug(&#x27;replacing %s-%s stale offset of %d with %d&#x27;, topic.topic, topic.partition, oldOffset, offset);

    this.setOffset(topic.topic, topic.partition, offset);
    this.<span class="apidocCodeKeywordSpan">resume</span>();
  });
});

// &#x27;done&#x27; will be emit when a message fetch request complete
this.on(&#x27;done&#x27;, function (topics) {
  self.updateOffsets(topics);
  if (!self.paused) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.resumeTopics" id="apidoc.element.kafka-node.Consumer.prototype.resumeTopics">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>resumeTopics
        <span class="apidocSignatureSpan">(topics)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resumeTopics = function (topics) {
  if (!this.pausedPayloads) this.pausedPayloads = [];
  var reFetch = !this.payloads.length;
  pauseOrResume(this.pausedPayloads, this.payloads, topics);
  reFetch = reFetch &#x26;&#x26; this.payloads.length;
  if (reFetch) this.fetch();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
]);
```

### resumeTopics(topics)
Resume specify topics

```
consumer.<span class="apidocCodeKeywordSpan">resumeTopics</span>([
    &#x27;topic1&#x27;,
    { topic: &#x27;topic2&#x27;, partition: 0 }
]);
```

### close(force, cb)
* `force`: **Boolean**, if set to true, it forces the consumer to commit the current offset before closing, default `false`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.setOffset" id="apidoc.element.kafka-node.Consumer.prototype.setOffset">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>setOffset
        <span class="apidocSignatureSpan">(topic, partition, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setOffset = function (topic, partition, offset) {
  this.payloads.every(function (p) {
    if (p.topic === topic &#x26;&#x26; p.partition == partition) { // eslint-disable-line eqeqeq
      p.offset = offset;
      return false;
    }
    return true;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `partition`: **Number**

* `offset`: **Number**

Example:

``` js
consumer.<span class="apidocCodeKeywordSpan">setOffset</span>(&#x27;topic&#x27;, 0, 0);
```

### pause()
Pause the consumer. ***Calling `pause` does not automatically stop messages from being emitted.*** This is because pause just stops
 the kafka consumer fetch loop. Each iteration of the fetch loop can obtain a batch of messages (limited by `fetchMaxBytes`).

### resume()
Resume the consumer. Resumes the fetch loop.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Consumer.prototype.updateOffsets" id="apidoc.element.kafka-node.Consumer.prototype.updateOffsets">
        function <span class="apidocSignatureSpan">kafka-node.Consumer.prototype.</span>updateOffsets
        <span class="apidocSignatureSpan">(topics, initing)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateOffsets = function (topics, initing) {
  this.payloads.forEach(function (p) {
    if (!_.isEmpty(topics[p.topic]) &#x26;&#x26; topics[p.topic][p.partition] !== undefined) {
      var offset = topics[p.topic][p.partition];
      if (offset === -1) offset = 0;
      if (!initing) p.offset = offset + 1;
      else p.offset = offset;
    }
  });

  if (this.options.autoCommit &#x26;&#x26; !initing) {
    this.autoCommit(false, function (err) {
      err &#x26;&#x26; logger.debug(&#x27;auto commit offset&#x27;, err);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.setOffset(topic.topic, topic.partition, offset);
    this.resume();
  });
});

// &#x27;done&#x27; will be emit when a message fetch request complete
this.on(&#x27;done&#x27;, function (topics) {
  self.<span class="apidocCodeKeywordSpan">updateOffsets</span>(topics);
  if (!self.paused) {
    setImmediate(function () {
      self.fetch();
    });
  }
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.ConsumerGroup" id="apidoc.module.kafka-node.ConsumerGroup">module kafka-node.ConsumerGroup</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.ConsumerGroup" id="apidoc.element.kafka-node.ConsumerGroup.ConsumerGroup">
        function <span class="apidocSignatureSpan">kafka-node.</span>ConsumerGroup
        <span class="apidocSignatureSpan">(memberOptions, topics)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ConsumerGroup(memberOptions, topics) {
  EventEmitter.call(this);
  const self = this;
  this.options = _.defaults((memberOptions || {}), DEFAULTS);

  if (!this.options.heartbeatInterval) {
    this.options.heartbeatInterval = Math.floor(this.options.sessionTimeout / 3);
  }

  if (memberOptions.ssl === true) {
    memberOptions.ssl = {};
  }

  if (!(this.options.fromOffset in ACCEPTED_FROM_OFFSET)) {
    throw new Error(`fromOffset ${this.options.fromOffset} should be either: ${Object.keys(ACCEPTED_FROM_OFFSET).join(&#x27;, &#x27;)}`);
  }

  if (!(this.options.outOfRangeOffset in ACCEPTED_FROM_OFFSET)) {
    throw new Error(`outOfRangeOffset ${this.options.outOfRangeOffset} should be either: ${Object.keys(ACCEPTED_FROM_OFFSET).join
(&#x27;, &#x27;)}`);
  }

  this.client = new Client(memberOptions.host, memberOptions.id, memberOptions.zk,
    memberOptions.batch, memberOptions.ssl);

  if (_.isString(topics)) {
    topics = [topics];
  }

  assert(Array.isArray(topics), &#x27;Array of topics is required&#x27;);

  this.topics = topics;

  this.recovery = new ConsumerGroupRecovery(this);

  this.setupProtocols(this.options.protocol);

  if (this.options.connectOnReady &#x26;&#x26; !this.options.migrateHLC) {
    this.client.once(&#x27;ready&#x27;, this.connect.bind(this));
  }

  if (this.options.migrateHLC) {
    const ConsumerGroupMigrator = require(&#x27;./consumerGroupMigrator&#x27;);
    this.migrator = new ConsumerGroupMigrator(this);
    this.migrator.on(&#x27;error&#x27;, function (error) {
      self.emit(&#x27;error&#x27;, error);
    });
  }

  this.client.on(&#x27;error&#x27;, function (err) {
    logger.error(&#x27;Error from %s&#x27;, self.client.clientId, err);
    self.emit(&#x27;error&#x27;, err);
  });

  const recoverFromBrokerChange = _.debounce(function () {
    logger.debug(&#x27;brokersChanged refreshing metadata&#x27;);
    self.client.refreshMetadata(self.topics, function (error) {
      if (error) {
        self.emit(error);
        return;
      }
      self.paused = false;
      if (!self.ready &#x26;&#x26; !self.connecting) {
        if (self.reconnectTimer) {
          // brokers changed so bypass backoff retry and reconnect now
          clearTimeout(self.reconnectTimer);
          self.reconnectTimer = null;
        }
        self.connect();
      } else if (!self.connecting) {
        self.fetch();
      }
    });
  }, 200);

  this.client.on(&#x27;brokersChanged&#x27;, function () {
    self.pause();
    recoverFromBrokerChange();
  });

  this.client.on(&#x27;reconnect&#x27;, function (lastError) {
    self.fetch();
  });

  this.on(&#x27;offsetOutOfRange&#x27;, topic =&#x3e; {
    this.pause();
    if (this.options.outOfRangeOffset === &#x27;none&#x27;) {
      this.emit(&#x27;error&#x27;, new errors.InvalidConsumerOffsetError(`Offset out of range for topic &#x22;${topic.topic}&#x22; partition ${topic
.partition}`));
      return;
    }

    topic.time = ACCEPTED_FROM_OFFSET[this.options.outOfRangeOffset];

    this.getOffset().fetch([topic], (error, result) =&#x3e; {
      if (error) {
        this.emit(&#x27;error&#x27;, new errors.InvalidConsumerOffsetError(`Fetching ${this.options.outOfRangeOffset} offset failed`, error
));
        return;
      }
      const offset = _.head(result[topic.topic][topic.partition]);
      const oldOffset = _.find(this.topicPayloads, {topic: topic.topic, partition: topic.partition}).offset;

      logger.debug(&#x27;replacing %s-%s stale offset of %d with %d&#x27;, topic.topic, topic.partition, oldOffset, offset);

      this.setOffset(topic.topic, topic.partition, offset);
      this.resume();
    });
  });

  // &#x27;done&#x27; will be emit when a message fetch request complete
  this.on(&#x27;done&#x27;, function (topics) {
    self.updateOffsets(topics);
    if (!self.paused) {
      setImmediate(function () {
        self.fetch();
      });
    }
  });

  if (this.options.groupId) {
    validateConfig(&#x27;options.groupId&#x27;, this.options.groupId);
  }

  this.isLeader = false;
  this.coordinatorId = null;
  this.generationId = null;
  this.ready = false;
  this.topicPayloads = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.super_" id="apidoc.element.kafka-node.ConsumerGroup.super_">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.</span>super_
        <span class="apidocSignatureSpan">(client, topics, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function (client, topics, options) {
  if (!topics) {
    throw new Error(&#x27;Must have payloads&#x27;);
  }
  this.fetchCount = 0;
  this.client = client;
  this.options = _.defaults((options || {}), DEFAULTS);
  this.initialised = false;
  this.ready = false;
  this.closing = false;
  this.paused = this.options.paused;
  this.rebalancing = false;
  this.pendingRebalances = 0;
  this.committing = false;
  this.needToCommit = false;
  this.id = this.options.id || this.options.groupId + &#x27;_&#x27; + uuid.v4();
  this.payloads = this.buildPayloads(topics);
  this.topicPayloads = this.buildTopicPayloads(topics);
  this.connect();

  if (this.options.groupId) {
    validateConfig(&#x27;options.groupId&#x27;, this.options.groupId);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.ConsumerGroup.prototype" id="apidoc.module.kafka-node.ConsumerGroup.prototype">module kafka-node.ConsumerGroup.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.assignPartitions" id="apidoc.element.kafka-node.ConsumerGroup.prototype.assignPartitions">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>assignPartitions
        <span class="apidocSignatureSpan">(protocol, groupMembers, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assignPartitions = function (protocol, groupMembers, callback) {
  logger.debug(&#x27;Assigning Partitions to members&#x27;, groupMembers);
  logger.debug(&#x27;Using group protocol&#x27;, protocol);

  protocol = _.find(this.protocols, {name: protocol});

  var self = this;
  var topics = _(groupMembers).map(&#x27;subscription&#x27;).flatten().uniq().value();

  async.waterfall([
    function (callback) {
      logger.debug(&#x27;loadingMetadata for topics:&#x27;, topics);
      self.client.loadMetadataForTopics(topics, callback);
    },

    function (metadataResponse, callback) {
      var metadata = mapTopicToPartitions(metadataResponse[1].metadata);
      logger.debug(&#x27;mapTopicToPartitions&#x27;, metadata);
      protocol.assign(metadata, groupMembers, callback);
    }
  ], callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.isLeader = (joinGroupResponse.leaderId === joinGroupResponse.memberId);
this.generationId = joinGroupResponse.generationId;
this.memberId = joinGroupResponse.memberId;

var groupAssignment;
if (this.isLeader) {
  // assign partitions
  return this.<span class="apidocCodeKeywordSpan">assignPartitions</span>(joinGroupResponse.groupProtocol, joinGroupResponse.members
, callback);
}
callback(null, groupAssignment);
};

ConsumerGroup.prototype.saveDefaultOffsets = function (topicPartitionList, callback) {
var self = this;
const offsetPayload = _(topicPartitionList).cloneDeep().map(tp =&#x3e; {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.close" id="apidoc.element.kafka-node.ConsumerGroup.prototype.close">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>close
        <span class="apidocSignatureSpan">(force, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (force, cb) {
  var self = this;
  this.ready = false;

  this.stopHeartbeats();

  if (typeof force === &#x27;function&#x27;) {
    cb = force;
    force = false;
  }

  async.series([
    function (callback) {
      if (force) {
        self.commit(true, callback);
        return;
      }
      callback(null);
    },
    function (callback) {
      self.leaveGroup(function (error) {
        if (error) {
          logger.error(&#x27;Leave group failed with&#x27;, error);
        }
        callback(null);
      });
    },
    function (callback) {
      self.client.close(callback);
    }
  ], cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### close(force, cb)
* `force`: **Boolean**, if set to true, it forces the consumer to commit the current offset before closing, default `false`

Example

```js
consumer.<span class="apidocCodeKeywordSpan">close</span>(true, cb);
consumer.close(cb); //force is disabled
```

## HighLevelConsumer
 ***This consumer has been deprecated in the latest version of Kafka (0.10.1) and is likely to be removed in the future. Please
 use the ConsumerGroup instead.***

### HighLevelConsumer(client, payloads, options)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.connect" id="apidoc.element.kafka-node.ConsumerGroup.prototype.connect">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>connect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connect = function () {
  if (this.connecting) {
    logger.warn(&#x27;Connect ignored. Currently connecting.&#x27;);
    return;
  }

  logger.debug(&#x27;Connecting %s&#x27;, this.client.clientId);
  var self = this;

  this.connecting = true;
  this.emit(&#x27;rebalancing&#x27;);

  async.waterfall([
    function (callback) {
      if (self.client.coordinatorId) {
        return callback(null, null);
      }
      self.client.sendGroupCoordinatorRequest(self.options.groupId, callback);
    },

    function (coordinatorInfo, callback) {
      logger.debug(&#x27;GroupCoordinator Response:&#x27;, coordinatorInfo);
      if (coordinatorInfo) {
        self.setCoordinatorId(coordinatorInfo.coordinatorId);
      }
      self.client.sendJoinGroupRequest(self.options.groupId, emptyStrIfNull(self.memberId), self.options.sessionTimeout, self.protocols
, callback);
    },

    function (joinGroupResponse, callback) {
      self.handleJoinGroup(joinGroupResponse, callback);
    },

    function (groupAssignment, callback) {
      logger.debug(&#x27;SyncGroup Request from %s&#x27;, self.memberId);
      self.client.sendSyncGroupRequest(self.options.groupId, self.generationId, self.memberId, groupAssignment, callback);
    },

    function (syncGroupResponse, callback) {
      self.handleSyncGroup(syncGroupResponse, callback);
    }
  ], function (error, startFetch) {
    self.connecting = false;
    self.rebalancing = false;
    if (error) {
      return self.recovery.tryToRecoverFrom(error, &#x27;connect&#x27;);
    }

    self.ready = true;
    self.recovery.clearError();

    logger.debug(&#x27;generationId&#x27;, self.generationId);

    if (startFetch) {
      self.fetch();
    }
    self.startHeartbeats();
    self.emit(&#x27;connect&#x27;);
    self.emit(&#x27;rebalanced&#x27;);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

var partitionerType = PARTITIONER_MAP[options.partitionerType] || PARTITIONER_MAP[defaultPartitionerType];

// eslint-disable-next-line
this.partitioner = new partitionerType(customPartitioner);

this.<span class="apidocCodeKeywordSpan">connect</span>();
}

util.inherits(BaseProducer, events.EventEmitter);

BaseProducer.prototype.connect = function () {
// emiter...
var self = this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.fetchOffset" id="apidoc.element.kafka-node.ConsumerGroup.prototype.fetchOffset">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>fetchOffset
        <span class="apidocSignatureSpan">(payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetchOffset = function (payloads, cb) {
  this.client.sendOffsetFetchV1Request(this.options.groupId, payloads, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    logger.debug(&#x27;%s owns topics: &#x27;, self.client.clientId, syncGroupResponse.partitions);

    const topicPartitionList = createTopicPartitionList(syncGroupResponse.partitions);
    const useDefaultOffsets = self.options.fromOffset in ACCEPTED_FROM_OFFSET;

    async.waterfall([
      function (callback) {
self.<span class="apidocCodeKeywordSpan">fetchOffset</span>(syncGroupResponse.partitions, callback);
      },
      function (offsets, callback) {
logger.debug(&#x27;%s fetchOffset Response: %j&#x27;, self.client.clientId, offsets);

var noOffset = topicPartitionList.some(function (tp) {
  return offsets[tp.topic][tp.partition] === -1;
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.getDefaultOffset" id="apidoc.element.kafka-node.ConsumerGroup.prototype.getDefaultOffset">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>getDefaultOffset
        <span class="apidocSignatureSpan">(tp, defaultOffset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDefaultOffset = function (tp, defaultOffset) {
  return _.get(this.defaultOffsets, [tp.topic, tp.partition], defaultOffset);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    callback(null, offsets);
  }
},
function (offsets, callback) {
  self.topicPayloads = self.buildPayloads(topicPartitionList).map(function (p) {
    var offset = offsets[p.topic][p.partition];
    if (offset === -1) { // -1 means no offset was saved for this topic/partition combo
      offset = useDefaultOffsets ? self.<span class="apidocCodeKeywordSpan">getDefaultOffset</span>(p, 0) : 0;
      if (self.migrator) {
        offset = self.migrator.getOffset(p, offset);
      }
    }
    p.offset = offset;
    return p;
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.getOffset" id="apidoc.element.kafka-node.ConsumerGroup.prototype.getOffset">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>getOffset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOffset = function () {
  if (this.offset) {
    return this.offset;
  }
  this.offset = new Offset(this.client);
  // we can ignore this since we are already forwarding error event emitted from client
  this.offset.on(&#x27;error&#x27;, _.noop);
  return this.offset;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this.options.outOfRangeOffset === &#x27;none&#x27;) {
  this.emit(&#x27;error&#x27;, new errors.InvalidConsumerOffsetError(`Offset out of range for topic &#x22;${topic.topic}&#x22; partition
 ${topic.partition}`));
  return;
}

topic.time = ACCEPTED_FROM_OFFSET[this.options.outOfRangeOffset];

this.<span class="apidocCodeKeywordSpan">getOffset</span>().fetch([topic], (error, result) =&#x3e; {
  if (error) {
    this.emit(&#x27;error&#x27;, new errors.InvalidConsumerOffsetError(`Fetching ${this.options.outOfRangeOffset} offset failed`,
error));
    return;
  }
  const offset = _.head(result[topic.topic][topic.partition]);
  const oldOffset = _.find(this.topicPayloads, {topic: topic.topic, partition: topic.partition}).offset;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.handleJoinGroup" id="apidoc.element.kafka-node.ConsumerGroup.prototype.handleJoinGroup">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>handleJoinGroup
        <span class="apidocSignatureSpan">(joinGroupResponse, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleJoinGroup = function (joinGroupResponse, callback) {
  logger.debug(&#x27;joinGroupResponse %j from %s&#x27;, joinGroupResponse, this.client.clientId);

  this.isLeader = (joinGroupResponse.leaderId === joinGroupResponse.memberId);
  this.generationId = joinGroupResponse.generationId;
  this.memberId = joinGroupResponse.memberId;

  var groupAssignment;
  if (this.isLeader) {
    // assign partitions
    return this.assignPartitions(joinGroupResponse.groupProtocol, joinGroupResponse.members, callback);
  }
  callback(null, groupAssignment);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (coordinatorInfo) {
    self.setCoordinatorId(coordinatorInfo.coordinatorId);
  }
  self.client.sendJoinGroupRequest(self.options.groupId, emptyStrIfNull(self.memberId), self.options.sessionTimeout, self.protocols
, callback);
},

function (joinGroupResponse, callback) {
  self.<span class="apidocCodeKeywordSpan">handleJoinGroup</span>(joinGroupResponse, callback);
},

function (groupAssignment, callback) {
  logger.debug(&#x27;SyncGroup Request from %s&#x27;, self.memberId);
  self.client.sendSyncGroupRequest(self.options.groupId, self.generationId, self.memberId, groupAssignment, callback);
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.handleSyncGroup" id="apidoc.element.kafka-node.ConsumerGroup.prototype.handleSyncGroup">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>handleSyncGroup
        <span class="apidocSignatureSpan">(syncGroupResponse, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleSyncGroup = function (syncGroupResponse, callback) {
  logger.debug(&#x27;SyncGroup Response&#x27;);
  var self = this;
  var ownedTopics = Object.keys(syncGroupResponse.partitions);
  if (ownedTopics.length) {
    logger.debug(&#x27;%s owns topics: &#x27;, self.client.clientId, syncGroupResponse.partitions);

    const topicPartitionList = createTopicPartitionList(syncGroupResponse.partitions);
    const useDefaultOffsets = self.options.fromOffset in ACCEPTED_FROM_OFFSET;

    async.waterfall([
      function (callback) {
        self.fetchOffset(syncGroupResponse.partitions, callback);
      },
      function (offsets, callback) {
        logger.debug(&#x27;%s fetchOffset Response: %j&#x27;, self.client.clientId, offsets);

        var noOffset = topicPartitionList.some(function (tp) {
          return offsets[tp.topic][tp.partition] === -1;
        });

        if (noOffset) {
          logger.debug(&#x27;No saved offsets&#x27;);

          if (self.options.fromOffset === &#x27;none&#x27;) {
            return callback(new Error(`${self.client.clientId} owns topics and partitions which contains no saved offsets for group
 &#x27;${self.options.groupId}&#x27;`));
          }

          async.parallel([
            function (callback) {
              if (self.migrator) {
                return self.migrator.saveHighLevelConsumerOffsets(topicPartitionList, callback);
              }
              callback(null);
            },
            function (callback) {
              if (useDefaultOffsets) {
                return self.saveDefaultOffsets(topicPartitionList, callback);
              }
              callback(null);
            }
          ], function (error) {
            if (error) {
              return callback(error);
            }
            logger.debug(&#x27;%s defaultOffset Response for %s: %j&#x27;, self.client.clientId, self.options.fromOffset, self.defaultOffsets
);
            callback(null, offsets);
          });
        } else {
          logger.debug(&#x27;Has saved offsets&#x27;);
          callback(null, offsets);
        }
      },
      function (offsets, callback) {
        self.topicPayloads = self.buildPayloads(topicPartitionList).map(function (p) {
          var offset = offsets[p.topic][p.partition];
          if (offset === -1) { // -1 means no offset was saved for this topic/partition combo
            offset = useDefaultOffsets ? self.getDefaultOffset(p, 0) : 0;
            if (self.migrator) {
              offset = self.migrator.getOffset(p, offset);
            }
          }
          p.offset = offset;
          return p;
        });
        callback(null, true);
      }
    ], callback);
  } else { // no partitions assigned
    callback(null, false);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  function (groupAssignment, callback) {
    logger.debug(&#x27;SyncGroup Request from %s&#x27;, self.memberId);
    self.client.sendSyncGroupRequest(self.options.groupId, self.generationId, self.memberId, groupAssignment, callback);
  },

  function (syncGroupResponse, callback) {
    self.<span class="apidocCodeKeywordSpan">handleSyncGroup</span>(syncGroupResponse, callback);
  }
], function (error, startFetch) {
  self.connecting = false;
  self.rebalancing = false;
  if (error) {
    return self.recovery.tryToRecoverFrom(error, &#x27;connect&#x27;);
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.leaveGroup" id="apidoc.element.kafka-node.ConsumerGroup.prototype.leaveGroup">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>leaveGroup
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">leaveGroup = function (callback) {
  logger.debug(&#x27;%s leaving group&#x27;, this.client.clientId);
  var self = this;
  this.stopHeartbeats();
  if (self.generationId != null &#x26;&#x26; self.memberId) {
    this.client.sendLeaveGroupRequest(this.options.groupId, this.memberId, function (error) {
      self.generationId = null;
      callback(error);
    });
  } else {
    callback(null);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (force) {
    self.commit(true, callback);
    return;
  }
  callback(null);
},
function (callback) {
  self.<span class="apidocCodeKeywordSpan">leaveGroup</span>(function (error) {
    if (error) {
      logger.error(&#x27;Leave group failed with&#x27;, error);
    }
    callback(null);
  });
},
function (callback) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.saveDefaultOffsets" id="apidoc.element.kafka-node.ConsumerGroup.prototype.saveDefaultOffsets">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>saveDefaultOffsets
        <span class="apidocSignatureSpan">(topicPartitionList, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">saveDefaultOffsets = function (topicPartitionList, callback) {
  var self = this;
  const offsetPayload = _(topicPartitionList).cloneDeep().map(tp =&#x3e; {
    tp.time = ACCEPTED_FROM_OFFSET[this.options.fromOffset];
    return tp;
  });

  self.getOffset().fetch(offsetPayload, function (error, result) {
    if (error) {
      return callback(error);
    }
    self.defaultOffsets = _.mapValues(result, function (partitionOffsets) {
      return _.mapValues(partitionOffsets, _.head);
    });
    callback(null);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (self.migrator) {
      return self.migrator.saveHighLevelConsumerOffsets(topicPartitionList, callback);
    }
    callback(null);
  },
  function (callback) {
    if (useDefaultOffsets) {
      return self.<span class="apidocCodeKeywordSpan">saveDefaultOffsets</span>(topicPartitionList, callback);
    }
    callback(null);
  }
], function (error) {
  if (error) {
    return callback(error);
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.scheduleReconnect" id="apidoc.element.kafka-node.ConsumerGroup.prototype.scheduleReconnect">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>scheduleReconnect
        <span class="apidocSignatureSpan">(timeout)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scheduleReconnect = function (timeout) {
  assert(timeout);
  this.rebalancing = true;

  if (this.reconnectTimer) {
    clearTimeout(this.reconnectTimer);
  }

  var self = this;
  this.reconnectTimer = setTimeout(function () {
    self.reconnectTimer = null;
    self.connect();
  }, timeout);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  if (retry) {
    retryTimeout = this.getRetryTimeout(error);
  }

  if (retry &#x26;&#x26; retryTimeout) {
    logger.debug(&#x27;RECOVERY from %s: %s retrying in %s ms&#x27;, source, this.consumerGroup.client.clientId, retryTimeout, error
);
    this.consumerGroup.<span class="apidocCodeKeywordSpan">scheduleReconnect</span>(retryTimeout);
  } else {
    this.consumerGroup.emit(&#x27;error&#x27;, error);
  }
  this.lastError = error;
};

ConsumerGroupRecovery.prototype.clearError = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.sendHeartbeat" id="apidoc.element.kafka-node.ConsumerGroup.prototype.sendHeartbeat">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>sendHeartbeat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendHeartbeat = function () {
  assert(this.memberId, &#x27;invalid memberId&#x27;);
  assert(this.generationId &#x3e;= 0, &#x27;invalid generationId&#x27;);
  // logger.debug(&#x27;%s   -&#x3e;&#x27;, this.client.clientId);
  var self = this;

  function heartbeatCallback (error) {
    if (error) {
      logger.warn(&#x27;%s Heartbeat error:&#x27;, self.client.clientId, error);
      self.recovery.tryToRecoverFrom(error, &#x27;heartbeat&#x27;);
    }
    // logger.debug(&#x27;%s  &#x3c;-&#x27;, self.client.clientId, error);
  }

  const heartbeat = new Heartbeat(this.client, heartbeatCallback);
  heartbeat.send(this.options.groupId, this.generationId, this.memberId);

  return heartbeat;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
assert(this.ready, &#x27;consumerGroup is not ready&#x27;);

const heartbeatIntervalMs = this.options.heartbeatInterval || (Math.floor(this.options.sessionTimeout / 3));

logger.debug(&#x27;%s started heartbeats at every %d ms&#x27;, this.client.clientId, heartbeatIntervalMs);
this.stopHeartbeats();

let heartbeat = this.<span class="apidocCodeKeywordSpan">sendHeartbeat</span>();

this.heartbeatInterval = setInterval(() =&#x3e; {
  // only send another heartbeat if we got a response from the last one
  if (heartbeat.verifyResolved()) {
    heartbeat = this.sendHeartbeat();
  }
}, heartbeatIntervalMs);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.sendOffsetCommitRequest" id="apidoc.element.kafka-node.ConsumerGroup.prototype.sendOffsetCommitRequest">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>sendOffsetCommitRequest
        <span class="apidocSignatureSpan">(commits, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendOffsetCommitRequest = function (commits, cb) {
  if (this.generationId &#x26;&#x26; this.memberId) {
    this.client.sendOffsetCommitV2Request(this.options.groupId, this.generationId, this.memberId, commits, cb);
  } else {
    cb(null, &#x27;Nothing to be committed&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }.bind(this), this.options.autoCommitIntervalMs);

  var payloads = this.payloads;
  if (this.pausedPayloads) payloads = payloads.concat(this.pausedPayloads);

  var commits = payloads.filter(function (p) { return p.offset !== 0; });
  if (commits.length) {
    this.client.<span class="apidocCodeKeywordSpan">sendOffsetCommitRequest</span>(this.options.groupId, commits, cb);
  } else {
    cb(null, &#x27;Nothing to be committed&#x27;);
  }
}
Consumer.prototype.commit = Consumer.prototype.autoCommit = autoCommit;

Consumer.prototype.fetch = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.setCoordinatorId" id="apidoc.element.kafka-node.ConsumerGroup.prototype.setCoordinatorId">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>setCoordinatorId
        <span class="apidocSignatureSpan">(coordinatorId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setCoordinatorId = function (coordinatorId) {
  this.client.coordinatorId = String(coordinatorId);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  self.client.sendGroupCoordinatorRequest(self.options.groupId, callback);
},

function (coordinatorInfo, callback) {
  logger.debug(&#x27;GroupCoordinator Response:&#x27;, coordinatorInfo);
  if (coordinatorInfo) {
    self.<span class="apidocCodeKeywordSpan">setCoordinatorId</span>(coordinatorInfo.coordinatorId);
  }
  self.client.sendJoinGroupRequest(self.options.groupId, emptyStrIfNull(self.memberId), self.options.sessionTimeout, self.protocols
, callback);
},

function (joinGroupResponse, callback) {
  self.handleJoinGroup(joinGroupResponse, callback);
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.setupProtocols" id="apidoc.element.kafka-node.ConsumerGroup.prototype.setupProtocols">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>setupProtocols
        <span class="apidocSignatureSpan">(protocols)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setupProtocols = function (protocols) {
  if (!Array.isArray(protocols)) {
    protocols = [protocols];
  }

  this.protocols = protocols.map(function (protocol) {
    if (typeof protocol === &#x27;string&#x27;) {
      if (!(protocol in builtInProtocols)) {
        throw new Error(&#x27;Unknown built in assignment protocol &#x27; + protocol);
      }
      protocol = _.assign({}, builtInProtocols[protocol]);
    } else {
      checkProtocol(protocol);
    }

    protocol.subscription = this.topics;
    return protocol;
  }, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

assert(Array.isArray(topics), &#x27;Array of topics is required&#x27;);

this.topics = topics;

this.recovery = new ConsumerGroupRecovery(this);

this.<span class="apidocCodeKeywordSpan">setupProtocols</span>(this.options.protocol);

if (this.options.connectOnReady &#x26;&#x26; !this.options.migrateHLC) {
  this.client.once(&#x27;ready&#x27;, this.connect.bind(this));
}

if (this.options.migrateHLC) {
  const ConsumerGroupMigrator = require(&#x27;./consumerGroupMigrator&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.startHeartbeats" id="apidoc.element.kafka-node.ConsumerGroup.prototype.startHeartbeats">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>startHeartbeats
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">startHeartbeats = function () {
  assert(this.options.sessionTimeout &#x3e; 0);
  assert(this.ready, &#x27;consumerGroup is not ready&#x27;);

  const heartbeatIntervalMs = this.options.heartbeatInterval || (Math.floor(this.options.sessionTimeout / 3));

  logger.debug(&#x27;%s started heartbeats at every %d ms&#x27;, this.client.clientId, heartbeatIntervalMs);
  this.stopHeartbeats();

  let heartbeat = this.sendHeartbeat();

  this.heartbeatInterval = setInterval(() =&#x3e; {
    // only send another heartbeat if we got a response from the last one
    if (heartbeat.verifyResolved()) {
      heartbeat = this.sendHeartbeat();
    }
  }, heartbeatIntervalMs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  self.recovery.clearError();

  logger.debug(&#x27;generationId&#x27;, self.generationId);

  if (startFetch) {
    self.fetch();
  }
  self.<span class="apidocCodeKeywordSpan">startHeartbeats</span>();
  self.emit(&#x27;connect&#x27;);
  self.emit(&#x27;rebalanced&#x27;);
});
};

ConsumerGroup.prototype.scheduleReconnect = function (timeout) {
assert(timeout);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.ConsumerGroup.prototype.stopHeartbeats" id="apidoc.element.kafka-node.ConsumerGroup.prototype.stopHeartbeats">
        function <span class="apidocSignatureSpan">kafka-node.ConsumerGroup.prototype.</span>stopHeartbeats
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stopHeartbeats = function () {
  this.heartbeatInterval &#x26;&#x26; clearInterval(this.heartbeatInterval);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
ConsumerGroup.prototype.startHeartbeats = function () {
assert(this.options.sessionTimeout &#x3e; 0);
assert(this.ready, &#x27;consumerGroup is not ready&#x27;);

const heartbeatIntervalMs = this.options.heartbeatInterval || (Math.floor(this.options.sessionTimeout / 3));

logger.debug(&#x27;%s started heartbeats at every %d ms&#x27;, this.client.clientId, heartbeatIntervalMs);
this.<span class="apidocCodeKeywordSpan">stopHeartbeats</span>();

let heartbeat = this.sendHeartbeat();

this.heartbeatInterval = setInterval(() =&#x3e; {
  // only send another heartbeat if we got a response from the last one
  if (heartbeat.verifyResolved()) {
    heartbeat = this.sendHeartbeat();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.CustomPartitioner" id="apidoc.module.kafka-node.CustomPartitioner">module kafka-node.CustomPartitioner</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.CustomPartitioner.CustomPartitioner" id="apidoc.element.kafka-node.CustomPartitioner.CustomPartitioner">
        function <span class="apidocSignatureSpan">kafka-node.</span>CustomPartitioner
        <span class="apidocSignatureSpan">(partitioner)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CustomPartitioner = function (partitioner) {
  this.getPartition = partitioner;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.CustomPartitioner.super_" id="apidoc.element.kafka-node.CustomPartitioner.super_">
        function <span class="apidocSignatureSpan">kafka-node.CustomPartitioner.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.CyclicPartitioner" id="apidoc.module.kafka-node.CyclicPartitioner">module kafka-node.CyclicPartitioner</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.CyclicPartitioner.CyclicPartitioner" id="apidoc.element.kafka-node.CyclicPartitioner.CyclicPartitioner">
        function <span class="apidocSignatureSpan">kafka-node.</span>CyclicPartitioner
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CyclicPartitioner = function () {
  this.c = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.CyclicPartitioner.super_" id="apidoc.element.kafka-node.CyclicPartitioner.super_">
        function <span class="apidocSignatureSpan">kafka-node.CyclicPartitioner.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.CyclicPartitioner.prototype" id="apidoc.module.kafka-node.CyclicPartitioner.prototype">module kafka-node.CyclicPartitioner.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.CyclicPartitioner.prototype.getPartition" id="apidoc.element.kafka-node.CyclicPartitioner.prototype.getPartition">
        function <span class="apidocSignatureSpan">kafka-node.CyclicPartitioner.prototype.</span>getPartition
        <span class="apidocSignatureSpan">(partitions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPartition = function (partitions) {
  if (_.isEmpty(partitions)) return 0;
  return partitions[ this.c++ % partitions.length ];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  client.sendProduceRequest(this.buildPayloads(payloads, client.topicMetadata), requireAcks, ackTimeoutMs, cb);
};

BaseProducer.prototype.buildPayloads = function (payloads, topicMetadata) {
  const topicPartitionRequests = Object.create(null);
  payloads.forEach((p) =&#x3e; {
p.partition = p.hasOwnProperty(&#x27;partition&#x27;) ? p.partition : this.partitioner.<span class="apidocCodeKeywordSpan">getPartition
</span>(_.map(topicMetadata[p.topic], &#x27;partition&#x27;), p.key);
p.attributes = p.hasOwnProperty(&#x27;attributes&#x27;) ? p.attributes : 0;
let messages = _.isArray(p.messages) ? p.messages : [p.messages];

messages = messages.map(function (message) {
  if (message instanceof KeyedMessage) {
    return message;
  }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.DefaultPartitioner" id="apidoc.module.kafka-node.DefaultPartitioner">module kafka-node.DefaultPartitioner</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.DefaultPartitioner.DefaultPartitioner" id="apidoc.element.kafka-node.DefaultPartitioner.DefaultPartitioner">
        function <span class="apidocSignatureSpan">kafka-node.</span>DefaultPartitioner
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">DefaultPartitioner = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.DefaultPartitioner.super_" id="apidoc.element.kafka-node.DefaultPartitioner.super_">
        function <span class="apidocSignatureSpan">kafka-node.DefaultPartitioner.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.DefaultPartitioner.prototype" id="apidoc.module.kafka-node.DefaultPartitioner.prototype">module kafka-node.DefaultPartitioner.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.DefaultPartitioner.prototype.getPartition" id="apidoc.element.kafka-node.DefaultPartitioner.prototype.getPartition">
        function <span class="apidocSignatureSpan">kafka-node.DefaultPartitioner.prototype.</span>getPartition
        <span class="apidocSignatureSpan">(partitions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPartition = function (partitions) {
  if (partitions &#x26;&#x26; _.isArray(partitions) &#x26;&#x26; partitions.length &#x3e; 0) {
    return partitions[0];
  } else {
    return 0;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  client.sendProduceRequest(this.buildPayloads(payloads, client.topicMetadata), requireAcks, ackTimeoutMs, cb);
};

BaseProducer.prototype.buildPayloads = function (payloads, topicMetadata) {
  const topicPartitionRequests = Object.create(null);
  payloads.forEach((p) =&#x3e; {
p.partition = p.hasOwnProperty(&#x27;partition&#x27;) ? p.partition : this.partitioner.<span class="apidocCodeKeywordSpan">getPartition
</span>(_.map(topicMetadata[p.topic], &#x27;partition&#x27;), p.key);
p.attributes = p.hasOwnProperty(&#x27;attributes&#x27;) ? p.attributes : 0;
let messages = _.isArray(p.messages) ? p.messages : [p.messages];

messages = messages.map(function (message) {
  if (message instanceof KeyedMessage) {
    return message;
  }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.FailedToRebalanceConsumerError" id="apidoc.module.kafka-node.FailedToRebalanceConsumerError">module kafka-node.FailedToRebalanceConsumerError</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.FailedToRebalanceConsumerError.FailedToRebalanceConsumerError" id="apidoc.element.kafka-node.FailedToRebalanceConsumerError.FailedToRebalanceConsumerError">
        function <span class="apidocSignatureSpan">kafka-node.</span>FailedToRebalanceConsumerError
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">FailedToRebalanceConsumerError = function (message) {
  Error.captureStackTrace(this, this);
  this.message = message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      operation.attempt(function (currentAttempt) {
self.rebalanceAttempt(oldTopicPayloads, function (err) {
  if (operation.retry(err)) {
    return;
  }
  if (err) {
    self.rebalancing = false;
    return self.emit(&#x27;error&#x27;, new errors.<span class="apidocCodeKeywordSpan">FailedToRebalanceConsumerError</span>(operation
.mainError().toString()));
  } else {
    var topicNames = self.topicPayloads.map(function (p) {
      return p.topic;
    });
    self.client.refreshMetadata(topicNames, function (err) {
      register();
      if (err) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.FailedToRebalanceConsumerError.super_" id="apidoc.element.kafka-node.FailedToRebalanceConsumerError.super_">
        function <span class="apidocSignatureSpan">kafka-node.FailedToRebalanceConsumerError.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Error() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.FailedToRegisterConsumerError" id="apidoc.module.kafka-node.FailedToRegisterConsumerError">module kafka-node.FailedToRegisterConsumerError</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.FailedToRegisterConsumerError.FailedToRegisterConsumerError" id="apidoc.element.kafka-node.FailedToRegisterConsumerError.FailedToRegisterConsumerError">
        function <span class="apidocSignatureSpan">kafka-node.</span>FailedToRegisterConsumerError
        <span class="apidocSignatureSpan">(message, nested)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">FailedToRegisterConsumerError = function (message, nested) {
  NestedError.call(this, message, nested);
  this.message = message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          } else {
            callback(new Error(util.format(&#x27;Consumer %s is not registered in group %s&#x27;, self.id, self.options.groupId)));
          }
        });
      }
    ], function (error) {
      if (error) {
        self.emit(&#x27;error&#x27;, new errors.<span class="apidocCodeKeywordSpan">FailedToRegisterConsumerError</span>(error.toString
(), error));
      }
    });
  }
}, 20000);

function fetchAndUpdateOffsets (cb) {
  self.fetchOffset(self.topicPayloads, function (err, topics) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.FailedToRegisterConsumerError.super_" id="apidoc.element.kafka-node.FailedToRegisterConsumerError.super_">
        function <span class="apidocSignatureSpan">kafka-node.FailedToRegisterConsumerError.</span>super_
        <span class="apidocSignatureSpan">(message, nested)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function (message, nested) {
    this.nested = nested;

    if (typeof message !== &#x27;undefined&#x27;) {
        Object.defineProperty(this, &#x27;message&#x27;, {
            value: message,
            writable: true,
            enumerable: false,
            configurable: true
        });
    }

    Error.captureStackTrace(this, this.constructor);
    var oldStackDescriptor = Object.getOwnPropertyDescriptor(this, &#x27;stack&#x27;);
    var stackDescriptor = buildStackDescriptor(oldStackDescriptor, nested);
    Object.defineProperty(this, &#x27;stack&#x27;, stackDescriptor);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.GroupCoordinatorNotAvailableError" id="apidoc.module.kafka-node.GroupCoordinatorNotAvailableError">module kafka-node.GroupCoordinatorNotAvailableError</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.GroupCoordinatorNotAvailableError.GroupCoordinatorNotAvailableError" id="apidoc.element.kafka-node.GroupCoordinatorNotAvailableError.GroupCoordinatorNotAvailableError">
        function <span class="apidocSignatureSpan">kafka-node.</span>GroupCoordinatorNotAvailableError
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">GroupCoordinatorNotAvailableError = function (message) {
  Error.captureStackTrace(this, this);
  this.message = message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.GroupCoordinatorNotAvailableError.super_" id="apidoc.element.kafka-node.GroupCoordinatorNotAvailableError.super_">
        function <span class="apidocSignatureSpan">kafka-node.GroupCoordinatorNotAvailableError.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Error() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.GroupLoadInProgressError" id="apidoc.module.kafka-node.GroupLoadInProgressError">module kafka-node.GroupLoadInProgressError</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.GroupLoadInProgressError.GroupLoadInProgressError" id="apidoc.element.kafka-node.GroupLoadInProgressError.GroupLoadInProgressError">
        function <span class="apidocSignatureSpan">kafka-node.</span>GroupLoadInProgressError
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">GroupLoadInProgressError = function (message) {
  Error.captureStackTrace(this, this);
  this.message = message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.GroupLoadInProgressError.super_" id="apidoc.element.kafka-node.GroupLoadInProgressError.super_">
        function <span class="apidocSignatureSpan">kafka-node.GroupLoadInProgressError.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Error() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.HeartbeatTimeoutError" id="apidoc.module.kafka-node.HeartbeatTimeoutError">module kafka-node.HeartbeatTimeoutError</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.HeartbeatTimeoutError.HeartbeatTimeoutError" id="apidoc.element.kafka-node.HeartbeatTimeoutError.HeartbeatTimeoutError">
        function <span class="apidocSignatureSpan">kafka-node.</span>HeartbeatTimeoutError
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">HeartbeatTimeoutError = function (message) {
  Error.captureStackTrace(this, this);
  this.message = message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HeartbeatTimeoutError.super_" id="apidoc.element.kafka-node.HeartbeatTimeoutError.super_">
        function <span class="apidocSignatureSpan">kafka-node.HeartbeatTimeoutError.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Error() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.HighLevelConsumer" id="apidoc.module.kafka-node.HighLevelConsumer">module kafka-node.HighLevelConsumer</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.HighLevelConsumer" id="apidoc.element.kafka-node.HighLevelConsumer.HighLevelConsumer">
        function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelConsumer
        <span class="apidocSignatureSpan">(client, topics, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">HighLevelConsumer = function (client, topics, options) {
  if (!topics) {
    throw new Error(&#x27;Must have payloads&#x27;);
  }
  this.fetchCount = 0;
  this.client = client;
  this.options = _.defaults((options || {}), DEFAULTS);
  this.initialised = false;
  this.ready = false;
  this.closing = false;
  this.paused = this.options.paused;
  this.rebalancing = false;
  this.pendingRebalances = 0;
  this.committing = false;
  this.needToCommit = false;
  this.id = this.options.id || this.options.groupId + &#x27;_&#x27; + uuid.v4();
  this.payloads = this.buildPayloads(topics);
  this.topicPayloads = this.buildTopicPayloads(topics);
  this.connect();

  if (this.options.groupId) {
    validateConfig(&#x27;options.groupId&#x27;, this.options.groupId);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.super_" id="apidoc.element.kafka-node.HighLevelConsumer.super_">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.HighLevelConsumer.prototype" id="apidoc.module.kafka-node.HighLevelConsumer.prototype">module kafka-node.HighLevelConsumer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype._releasePartitions" id="apidoc.element.kafka-node.HighLevelConsumer.prototype._releasePartitions">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>_releasePartitions
        <span class="apidocSignatureSpan">(topicPayloads, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_releasePartitions = function (topicPayloads, callback) {
  var self = this;
  async.each(topicPayloads, function (tp, cbb) {
    if (tp.partition !== undefined) {
      async.series([
        function (delcbb) {
          self.client.zk.checkPartitionOwnership(self.id, self.options.groupId, tp.topic, tp.partition, function (err) {
            if (err) {
              // Partition doesn&#x27;t exist simply carry on
              cbb();
            } else delcbb();
          });
        },
        function (delcbb) {
          self.client.zk.deletePartitionOwnership(self.options.groupId, tp.topic, tp.partition, delcbb);
        },
        function (delcbb) {
          self.client.zk.checkPartitionOwnership(self.id, self.options.groupId, tp.topic, tp.partition, function (err) {
            if (err) {
              delcbb();
            } else {
              delcbb(&#x27;Partition should not exist&#x27;);
            }
          });
        }],
      cbb);
    } else {
      cbb();
    }
  }, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  });
},

// Release current partitions
function (callback) {
  logger.debug(&#x27;HighLevelConsumer %s releasing current partitions during rebalance&#x27;, self.id);
  self.<span class="apidocCodeKeywordSpan">_releasePartitions</span>(oldTopicPayloads, callback);
},

// Rebalance
function (callback) {
  logger.debug(&#x27;HighLevelConsumer %s determining the partitions to own during rebalance&#x27;, self.id);
  logger.debug(&#x27;consumerPerTopicMap.consumerTopicMap %j&#x27;, consumerPerTopicMap.consumerTopicMap);
  for (var topic in consumerPerTopicMap.consumerTopicMap[self.id]) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.addTopics" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.addTopics">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>addTopics
        <span class="apidocSignatureSpan">(topics, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addTopics = function (topics, cb) {
  var self = this;
  if (!this.ready) {
    setTimeout(function () {
      self.addTopics(topics, cb);
    }, 100);
    return;
  }
  this.client.addTopics(
    topics,
    function (err, added) {
      if (err) return cb &#x26;&#x26; cb(err, added);

      var payloads = self.buildPayloads(topics);
      // update offset of topics that will be added
      self.fetchOffset(payloads, function (err, offsets) {
        if (err) return cb(err);
        payloads.forEach(function (p) {
          var offset = offsets[p.topic][p.partition];
          if (offset === -1) offset = 0;
          p.offset = offset;
          self.topicPayloads.push(p);
        });
        // TODO: rebalance consumer
        cb &#x26;&#x26; cb(null, added);
      });
    }
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `topics`: **Array**, array of topics to add
* `cb`: **Function**,the callback
* `fromOffset`: **Boolean**, if true, the consumer will fetch message from the specified offset, otherwise it will fetch message
 from the last commited offset of the topic.

Example:

``` js
consumer.<span class="apidocCodeKeywordSpan">addTopics</span>([&#x27;t1&#x27;, &#x27;t2&#x27;], function (err, added) {
});

or

consumer.addTopics([{ topic: &#x27;t1&#x27;, offset: 10 }], function (err, added) {
}, true);
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.autoCommit" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.autoCommit">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>autoCommit
        <span class="apidocSignatureSpan">(force, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function autoCommit(force, cb) {
  if (arguments.length === 1) {
    cb = force;
    force = false;
  }

  if (!force) {
    if (this.committing) return cb(null, &#x27;Offset committing&#x27;);
    if (!this.needToCommit) return cb(null, &#x27;Commit not needed&#x27;);
  }

  this.needToCommit = false;
  this.committing = true;
  setTimeout(function () {
    this.committing = false;
  }.bind(this), this.options.autoCommitIntervalMs);

  var commits = this.topicPayloads.filter(function (p) { return p.offset !== -1; });

  if (commits.length) {
    this.sendOffsetCommitRequest(commits, cb);
  } else {
    cb(null, &#x27;Nothing to be committed&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (offset === -1) offset = 0;
    if (!initing) p.offset = offset + 1;
    else p.offset = offset;
  }
});

if (this.options.autoCommit &#x26;&#x26; !initing) {
  this.<span class="apidocCodeKeywordSpan">autoCommit</span>(false, function (err) {
    err &#x26;&#x26; logger.debug(&#x27;auto commit offset&#x27;, err);
  });
}
};

function autoCommit (force, cb) {
if (arguments.length === 1) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.buildPayloads" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.buildPayloads">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>buildPayloads
        <span class="apidocSignatureSpan">(payloads)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildPayloads = function (payloads) {
  var self = this;
  return payloads.map(function (p) {
    if (typeof p !== &#x27;object&#x27;) p = { topic: p };
    p.partition = p.partition || 0;
    p.offset = p.offset || 0;
    p.maxBytes = self.options.fetchMaxBytes;
    p.metadata = &#x27;m&#x27;; // metadata can be arbitrary
    return p;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {BaseProducer~sendCallback} cb A function to call once the send has completed
 */
BaseProducer.prototype.send = function (payloads, cb) {
var client = this.client;
var requireAcks = this.requireAcks;
var ackTimeoutMs = this.ackTimeoutMs;

client.sendProduceRequest(this.<span class="apidocCodeKeywordSpan">buildPayloads</span>(payloads, client.topicMetadata), requireAcks
, ackTimeoutMs, cb);
};

BaseProducer.prototype.buildPayloads = function (payloads, topicMetadata) {
const topicPartitionRequests = Object.create(null);
payloads.forEach((p) =&#x3e; {
  p.partition = p.hasOwnProperty(&#x27;partition&#x27;) ? p.partition : this.partitioner.getPartition(_.map(topicMetadata[p.topic
], &#x27;partition&#x27;), p.key);
  p.attributes = p.hasOwnProperty(&#x27;attributes&#x27;) ? p.attributes : 0;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.buildTopicPayloads" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.buildTopicPayloads">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>buildTopicPayloads
        <span class="apidocSignatureSpan">(topics)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildTopicPayloads = function (topics) {
  return topics.map(function (j) {
    var k = { topic: j.topic };
    return k;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.paused = this.options.paused;
  this.rebalancing = false;
  this.pendingRebalances = 0;
  this.committing = false;
  this.needToCommit = false;
  this.id = this.options.id || this.options.groupId + &#x27;_&#x27; + uuid.v4();
  this.payloads = this.buildPayloads(topics);
  this.topicPayloads = this.<span class="apidocCodeKeywordSpan">buildTopicPayloads</span>(topics);
  this.connect();

  if (this.options.groupId) {
    validateConfig(&#x27;options.groupId&#x27;, this.options.groupId);
  }
};
util.inherits(HighLevelConsumer, events.EventEmitter);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.close" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.close">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>close
        <span class="apidocSignatureSpan">(force, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (force, cb) {
  var self = this;
  this.ready = false;
  this.closing = true;
  clearInterval(this.checkPartitionOwnershipInterval);

  if (typeof force === &#x27;function&#x27;) {
    cb = force;
    force = false;
  }

  async.series([
    function (callback) {
      self.leaveGroup(callback);
    },
    function (callback) {
      if (force) {
        async.series([
          function (callback) {
            self.commit(true, callback);
          },
          function (callback) {
            self.client.close(callback);
          }
        ], callback);
        return;
      }
      self.client.close(callback);
    }
  ], cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### close(force, cb)
* `force`: **Boolean**, if set to true, it forces the consumer to commit the current offset before closing, default `false`

Example

```js
consumer.<span class="apidocCodeKeywordSpan">close</span>(true, cb);
consumer.close(cb); //force is disabled
```

## HighLevelConsumer
 ***This consumer has been deprecated in the latest version of Kafka (0.10.1) and is likely to be removed in the future. Please
 use the ConsumerGroup instead.***

### HighLevelConsumer(client, payloads, options)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.commit" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.commit">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>commit
        <span class="apidocSignatureSpan">(force, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function autoCommit(force, cb) {
  if (arguments.length === 1) {
    cb = force;
    force = false;
  }

  if (!force) {
    if (this.committing) return cb(null, &#x27;Offset committing&#x27;);
    if (!this.needToCommit) return cb(null, &#x27;Commit not needed&#x27;);
  }

  this.needToCommit = false;
  this.committing = true;
  setTimeout(function () {
    this.committing = false;
  }.bind(this), this.options.autoCommitIntervalMs);

  var commits = this.topicPayloads.filter(function (p) { return p.offset !== -1; });

  if (commits.length) {
    this.sendOffsetCommitRequest(commits, cb);
  } else {
    cb(null, &#x27;Nothing to be committed&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Commit offset of the current topics manually, this method should be called when a consumer leaves

* `cb`: **Function**, the callback

Example:

``` js
consumer.<span class="apidocCodeKeywordSpan">commit</span>(function(err, data) {
});
```

### setOffset(topic, partition, offset)
Set offset of the given topic

* `topic`: **String**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.connect" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.connect">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>connect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connect = function () {
  var self = this;
  // Client alreadyexists
  if (this.client.ready) {
    this.init();
  }

  this.client.on(&#x27;ready&#x27;, function () {
    if (!self.initialised) self.init();

    // Check the topics exist and create a watcher on them
    var topics = self.payloads.map(function (p) {
      return p.topic;
    });

    self.client.topicExists(topics, function (err) {
      if (err) {
        return self.emit(&#x27;error&#x27;, err);
      }
      self.initialised = true;
    });
  });

  function checkPartitionOwnership (callback) {
    async.each(self.topicPayloads, function (tp, cbb) {
      if (tp.partition !== undefined) {
        self.client.zk.checkPartitionOwnership(self.id, self.options.groupId, tp.topic, tp.partition, function (err) {
          if (err) {
            cbb(err);
          } else {
            cbb();
          }
        });
      } else {
        cbb();
      }
    }, callback);
  }

  // Check partition ownership and registration
  this.checkPartitionOwnershipInterval = setInterval(function () {
    if (!self.rebalancing) {
      async.parallel([
        checkPartitionOwnership,
        function (callback) {
          self.client.zk.isConsumerRegistered(self.options.groupId, self.id, function (error, registered) {
            if (error) {
              return callback(error);
            }
            if (registered) {
              callback();
            } else {
              callback(new Error(util.format(&#x27;Consumer %s is not registered in group %s&#x27;, self.id, self.options.groupId)));
            }
          });
        }
      ], function (error) {
        if (error) {
          self.emit(&#x27;error&#x27;, new errors.FailedToRegisterConsumerError(error.toString(), error));
        }
      });
    }
  }, 20000);

  function fetchAndUpdateOffsets (cb) {
    self.fetchOffset(self.topicPayloads, function (err, topics) {
      if (err) {
        return cb(err);
      }

      self.ready = true;
      self.updateOffsets(topics, true);

      return cb();
    });
  }

  function rebalance () {
    logger.debug(&#x27;rebalance() %s is rebalancing: %s ready: %s&#x27;, self.id, self.rebalancing, self.ready);
    if (!self.rebalancing &#x26;&#x26; !self.closing) {
      deregister();

      self.emit(&#x27;rebalancing&#x27;);

      self.rebalancing = true;
      logger.debug(&#x27;HighLevelConsumer rebalance retry config: %s&#x27;, JSON.stringify(self.options.rebalanceRetry));
      var oldTopicPayloads = self.topicPayloads;
      var operation = retry.operation(self.options.rebalanceRetry);

      operation.attempt(function (currentAttempt) {
        self.rebalanceAttempt(oldTopicPayloads, function (err) {
          if (operation.retry(err)) {
            return;
          }
          if (err) {
            self.rebalancing = false;
            return self.emit(&#x27;error&#x27;, new errors.FailedToRebalanceConsumerError(operation.mainError().toString()));
          } else {
            var topicNames = self.topicPayloads.map(function (p) {
              return p.topic;
            });
            self.client.refreshMetadata(topicNames, function (err) {
              register();
              if (err) {
                self.rebalancing = false;
                self.emit(&#x27;error&#x27;, err);
                return;
              }

              if (self.topicPayloads.length) {
                fetchAndUpdateOffsets(function (err) {
                  self.rebalancing = false;
                  if (err) {
                    self.emit(&#x27;error&#x27;, new errors.FailedToRebalanceConsumerError(err.message));
                    return;
                  }
                  self.fetch();
                  self.emit(&#x27;rebalanced&#x27;);
                });
              } else { // was not assigned any partitions during rebalance
                self.rebalancing = false;
                self.emit(&#x27;rebalanced&#x27;);
              }
            });
          }
        });
      });
    }
  }

  // Wait for the consumer to be ready
  this.on(&#x27;registered&#x27;, rebalance);

  function register (fn) {
    logger.debug(&#x27;Registered listeners %s&#x27;, self.id);
    self.client.zk.on(&#x27;consumersChanged&#x27;, fn ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

var partitionerType = PARTITIONER_MAP[options.partitionerType] || PARTITIONER_MAP[defaultPartitionerType];

// eslint-disable-next-line
this.partitioner = new partitionerType(customPartitioner);

this.<span class="apidocCodeKeywordSpan">connect</span>();
}

util.inherits(BaseProducer, events.EventEmitter);

BaseProducer.prototype.connect = function () {
// emiter...
var self = this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.fetch" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.fetch">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>fetch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetch = function () {
  if (!this.ready || this.rebalancing || this.paused) {
    return;
  }

  this.client.sendFetchRequest(this, this.topicPayloads, this.options.fetchMaxWaitMs, this.options.fetchMinBytes, this.options.maxTickMessages
);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Example

```js
var kafka = require(&#x27;kafka-node&#x27;),
    client = new kafka.Client(),
    offset = new kafka.Offset(client);
    offset.<span class="apidocCodeKeywordSpan">fetch</span>([
        { topic: &#x27;t&#x27;, partition: 0, time: Date.now(), maxNum: 1 }
    ], function (err, data) {
        // data
        // { &#x27;t&#x27;: { &#x27;0&#x27;: [999] } }
    });
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.fetchOffset" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.fetchOffset">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>fetchOffset
        <span class="apidocSignatureSpan">(payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetchOffset = function (payloads, cb) {
  logger.debug(&#x27;in fetchOffset %s payloads: %j&#x27;, this.id, payloads);
  this.client.sendOffsetFetchRequest(this.options.groupId, payloads, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    logger.debug(&#x27;%s owns topics: &#x27;, self.client.clientId, syncGroupResponse.partitions);

    const topicPartitionList = createTopicPartitionList(syncGroupResponse.partitions);
    const useDefaultOffsets = self.options.fromOffset in ACCEPTED_FROM_OFFSET;

    async.waterfall([
      function (callback) {
self.<span class="apidocCodeKeywordSpan">fetchOffset</span>(syncGroupResponse.partitions, callback);
      },
      function (offsets, callback) {
logger.debug(&#x27;%s fetchOffset Response: %j&#x27;, self.client.clientId, offsets);

var noOffset = topicPartitionList.some(function (tp) {
  return offsets[tp.topic][tp.partition] === -1;
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.getTopicPayloads" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.getTopicPayloads">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>getTopicPayloads
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTopicPayloads = function () {
  if (!this.rebalancing) return this.topicPayloads;
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.init" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.init">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>init
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init = function () {
  var self = this;

  if (!self.topicPayloads.length) {
    return;
  }

  self.registerConsumer(function (err) {
    if (err) {
      return self.emit(&#x27;error&#x27;, new errors.FailedToRegisterConsumerError(err.toString()));
    }

    // Close the
    return self.emit(&#x27;registered&#x27;);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
};

Consumer.prototype.connect = function () {
var self = this;
// Client already exists
this.ready = this.client.ready;
if (this.ready) this.<span class="apidocCodeKeywordSpan">init</span>();

this.client.on(&#x27;ready&#x27;, function () {
  logger.debug(&#x27;consumer ready&#x27;);
  if (!self.ready) self.init();
  self.ready = true;
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.leaveGroup" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.leaveGroup">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>leaveGroup
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">leaveGroup = function (cb) {
  var self = this;
  async.parallel([
    function (callback) {
      if (self.topicPayloads.length) {
        self._releasePartitions(self.topicPayloads, callback);
      } else {
        callback(null);
      }
    },
    function (callback) {
      self.client.zk.unregisterConsumer(self.options.groupId, self.id, callback);
    }
  ], cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (force) {
    self.commit(true, callback);
    return;
  }
  callback(null);
},
function (callback) {
  self.<span class="apidocCodeKeywordSpan">leaveGroup</span>(function (error) {
    if (error) {
      logger.error(&#x27;Leave group failed with&#x27;, error);
    }
    callback(null);
  });
},
function (callback) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.offsetRequest" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.offsetRequest">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>offsetRequest
        <span class="apidocSignatureSpan">(payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">offsetRequest = function (payloads, cb) {
  this.client.sendOffsetRequest(payloads, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});

this.on(&#x27;offsetOutOfRange&#x27;, function (topic) {
  self.pause();
  topic.maxNum = self.options.maxNumSegments;
  topic.metadata = &#x27;m&#x27;;
  topic.time = Date.now();
  self.<span class="apidocCodeKeywordSpan">offsetRequest</span>([topic], function (err, offsets) {
    if (err) {
      self.emit(&#x27;error&#x27;, new errors.InvalidConsumerOffsetError(self));
    } else {
      var min = Math.min.apply(null, offsets[topic.topic][topic.partition]);
      // set minimal offset
      self.setOffset(topic.topic, topic.partition, min);
      self.resume();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.pause" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.pause">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>pause
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pause = function () {
  this.paused = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    } else if (!self.connecting) {
      self.fetch();
    }
  });
}, 200);

this.client.on(&#x27;brokersChanged&#x27;, function () {
  self.<span class="apidocCodeKeywordSpan">pause</span>();
  recoverFromBrokerChange();
});

this.client.on(&#x27;reconnect&#x27;, function (lastError) {
  self.fetch();
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.rebalanceAttempt" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.rebalanceAttempt">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>rebalanceAttempt
        <span class="apidocSignatureSpan">(oldTopicPayloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rebalanceAttempt = function (oldTopicPayloads, cb) {
  var self = this;
  // Do the rebalance.....
  var consumerPerTopicMap;
  var newTopicPayloads = [];
  logger.debug(&#x27;HighLevelConsumer %s is attempting to rebalance&#x27;, self.id);
  async.series([

    // Stop fetching data and commit offsets
    function (callback) {
      logger.debug(&#x27;HighLevelConsumer %s stopping data read during rebalance&#x27;, self.id);
      self.stop(function () {
        callback();
      });
    },

    // Assemble the data
    function (callback) {
      logger.debug(&#x27;HighLevelConsumer %s assembling data for rebalance&#x27;, self.id);
      self.client.zk.getConsumersPerTopic(self.options.groupId, function (err, obj) {
        if (err) {
          callback(err);
        } else {
          consumerPerTopicMap = obj;
          callback();
        }
      });
    },

    // Release current partitions
    function (callback) {
      logger.debug(&#x27;HighLevelConsumer %s releasing current partitions during rebalance&#x27;, self.id);
      self._releasePartitions(oldTopicPayloads, callback);
    },

    // Rebalance
    function (callback) {
      logger.debug(&#x27;HighLevelConsumer %s determining the partitions to own during rebalance&#x27;, self.id);
      logger.debug(&#x27;consumerPerTopicMap.consumerTopicMap %j&#x27;, consumerPerTopicMap.consumerTopicMap);
      for (var topic in consumerPerTopicMap.consumerTopicMap[self.id]) {
        if (!consumerPerTopicMap.consumerTopicMap[self.id].hasOwnProperty(topic)) {
          continue;
        }
        var topicToAdd = consumerPerTopicMap.consumerTopicMap[self.id][topic];
        var numberOfConsumers = consumerPerTopicMap.topicConsumerMap[topicToAdd].length;
        var numberOfPartition = consumerPerTopicMap.topicPartitionMap[topicToAdd].length;
        var partitionsPerConsumer = Math.floor(numberOfPartition / numberOfConsumers);
        var extraPartitions = numberOfPartition % numberOfConsumers;
        var currentConsumerIndex;
        for (var index in consumerPerTopicMap.topicConsumerMap[topicToAdd]) {
          if (!consumerPerTopicMap.topicConsumerMap[topicToAdd].hasOwnProperty(index)) {
            continue;
          }
          if (consumerPerTopicMap.topicConsumerMap[topicToAdd][index] === self.id) {
            currentConsumerIndex = parseInt(index);
            break;
          }
        }
        var extraBit = currentConsumerIndex;
        if (currentConsumerIndex &#x3e; extraPartitions) extraBit = extraPartitions;
        var startPart = partitionsPerConsumer * currentConsumerIndex + extraBit;
        var extraNParts = 1;
        if (currentConsumerIndex + 1 &#x3e; extraPartitions) extraNParts = 0;
        var nParts = partitionsPerConsumer + extraNParts;

        for (var i = startPart; i &#x3c; startPart + nParts; i++) {
          newTopicPayloads.push({
            topic: topicToAdd,
            partition: consumerPerTopicMap.topicPartitionMap[topicToAdd][i],
            offset: 0,
            maxBytes: self.options.fetchMaxBytes,
            metadata: &#x27;m&#x27;
          });
        }
      }
      logger.debug(&#x27;newTopicPayloads %j&#x27;, newTopicPayloads);
      callback();
    },

    // Update ZK with new ownership
    function (callback) {
      if (newTopicPayloads.length) {
        logger.debug(&#x27;HighLevelConsumer %s gaining ownership of partitions during rebalance&#x27;, self.id);
        async.eachSeries(newTopicPayloads, function (tp, cbb) {
          if (tp.partition !== undefined) {
            async.series([
              function (addcbb) {
                self.client.zk.checkPartitionOwnership(self.id, self.options.groupId, tp.topic, tp.partition, function (err) {
                  if (err) {
                    // Partition doesn&#x27;t exist simply carry on
                    addcbb();
                  } else cbb(); // Partition exists simply carry on
                });
              },
              function (addcbb) {
                self.client.zk.addPartitionOwnership(self.id, self.options.groupId, tp.topic, tp.partition, function (err) {
                  if (err) {
                    addcbb(err);
                  } else addcbb(); ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

self.rebalancing = true;
logger.debug(&#x27;HighLevelConsumer rebalance retry config: %s&#x27;, JSON.stringify(self.options.rebalanceRetry));
var oldTopicPayloads = self.topicPayloads;
var operation = retry.operation(self.options.rebalanceRetry);

operation.attempt(function (currentAttempt) {
  self.<span class="apidocCodeKeywordSpan">rebalanceAttempt</span>(oldTopicPayloads, function (err) {
    if (operation.retry(err)) {
      return;
    }
    if (err) {
      self.rebalancing = false;
      return self.emit(&#x27;error&#x27;, new errors.FailedToRebalanceConsumerError(operation.mainError().toString()));
    } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.registerConsumer" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.registerConsumer">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>registerConsumer
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerConsumer = function (cb) {
  var self = this;
  var groupId = this.options.groupId;
  this.client.zk.registerConsumer(groupId, this.id, this.payloads, function (err) {
    if (err) return cb(err);
    self.client.zk.listConsumers(self.options.groupId);
    var topics = self.topicPayloads.reduce(function (ret, topicPayload) {
      if (ret.indexOf(topicPayload.topic) === -1) {
        ret.push(topicPayload.topic);
      }
      return ret;
    }, []);
    topics.forEach(function (topic) {
      self.client.zk.listPartitions(topic);
    });
    cb();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.client.on(&#x27;zkReconnect&#x27;, function () {
  logger.debug(&#x27;zookeeper reconnect for %s&#x27;, self.id);
  attachZookeeperErrorListener();

  // clean up what&#x27;s leftover
  self.leaveGroup(function () {
    // rejoin the group
    self.<span class="apidocCodeKeywordSpan">registerConsumer</span>(function (error) {
      if (error) {
        return self.emit(&#x27;error&#x27;, new errors.FailedToRegisterConsumerError(&#x27;Failed to register consumer on zkReconnect
&#x27;, error));
      }
      self.emit(&#x27;registered&#x27;);
    });
  });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.removeTopics" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.removeTopics">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>removeTopics
        <span class="apidocSignatureSpan">(topics, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeTopics = function (topics, cb) {
  topics = typeof topics === &#x27;string&#x27; ? [topics] : topics;
  this.payloads = this.payloads.filter(function (p) {
    return !~topics.indexOf(p.topic);
  });

  this.client.removeTopicMetadata(topics, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### removeTopics(topics, cb)
* `topics`: **Array**, array of topics to remove
* `cb`: **Function**, the callback

Example:

``` js
consumer.<span class="apidocCodeKeywordSpan">removeTopics</span>([&#x27;t1&#x27;, &#x27;t2&#x27;], function (err, removed) {
});
```

### commit(cb)
Commit offset of the current topics manually, this method should be called when a consumer leaves

* `cb`: **Function**, the callback
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.resume" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.resume">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>resume
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resume = function () {
  this.paused = false;
  this.fetch();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
    const offset = _.head(result[topic.topic][topic.partition]);
    const oldOffset = _.find(this.topicPayloads, {topic: topic.topic, partition: topic.partition}).offset;

    logger.debug(&#x27;replacing %s-%s stale offset of %d with %d&#x27;, topic.topic, topic.partition, oldOffset, offset);

    this.setOffset(topic.topic, topic.partition, offset);
    this.<span class="apidocCodeKeywordSpan">resume</span>();
  });
});

// &#x27;done&#x27; will be emit when a message fetch request complete
this.on(&#x27;done&#x27;, function (topics) {
  self.updateOffsets(topics);
  if (!self.paused) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.sendOffsetCommitRequest" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.sendOffsetCommitRequest">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>sendOffsetCommitRequest
        <span class="apidocSignatureSpan">(commits, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendOffsetCommitRequest = function (commits, cb) {
  this.client.sendOffsetCommitRequest(this.options.groupId, commits, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }.bind(this), this.options.autoCommitIntervalMs);

  var payloads = this.payloads;
  if (this.pausedPayloads) payloads = payloads.concat(this.pausedPayloads);

  var commits = payloads.filter(function (p) { return p.offset !== 0; });
  if (commits.length) {
    this.client.<span class="apidocCodeKeywordSpan">sendOffsetCommitRequest</span>(this.options.groupId, commits, cb);
  } else {
    cb(null, &#x27;Nothing to be committed&#x27;);
  }
}
Consumer.prototype.commit = Consumer.prototype.autoCommit = autoCommit;

Consumer.prototype.fetch = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.setOffset" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.setOffset">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>setOffset
        <span class="apidocSignatureSpan">(topic, partition, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setOffset = function (topic, partition, offset) {
  this.topicPayloads.every(function (p) {
    if (p.topic === topic &#x26;&#x26; p.partition == partition) { // eslint-disable-line eqeqeq
      p.offset = offset;
      return false;
    }
    return true;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `partition`: **Number**

* `offset`: **Number**

Example:

``` js
consumer.<span class="apidocCodeKeywordSpan">setOffset</span>(&#x27;topic&#x27;, 0, 0);
```

### pause()
Pause the consumer. ***Calling `pause` does not automatically stop messages from being emitted.*** This is because pause just stops
 the kafka consumer fetch loop. Each iteration of the fetch loop can obtain a batch of messages (limited by `fetchMaxBytes`).

### resume()
Resume the consumer. Resumes the fetch loop.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.stop" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.stop">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>stop
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stop = function (cb) {
  if (!this.options.autoCommit) return cb &#x26;&#x26; cb();
  this.commit(true, function (err) {
    cb &#x26;&#x26; cb(err);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var newTopicPayloads = [];
  logger.debug(&#x27;HighLevelConsumer %s is attempting to rebalance&#x27;, self.id);
  async.series([

// Stop fetching data and commit offsets
function (callback) {
  logger.debug(&#x27;HighLevelConsumer %s stopping data read during rebalance&#x27;, self.id);
  self.<span class="apidocCodeKeywordSpan">stop</span>(function () {
    callback();
  });
},

// Assemble the data
function (callback) {
  logger.debug(&#x27;HighLevelConsumer %s assembling data for rebalance&#x27;, self.id);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelConsumer.prototype.updateOffsets" id="apidoc.element.kafka-node.HighLevelConsumer.prototype.updateOffsets">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelConsumer.prototype.</span>updateOffsets
        <span class="apidocSignatureSpan">(topics, initing)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateOffsets = function (topics, initing) {
  this.topicPayloads.forEach(p =&#x3e; {
    if (!_.isEmpty(topics[p.topic]) &#x26;&#x26; topics[p.topic][p.partition] !== undefined) {
      var offset = topics[p.topic][p.partition];
      if (offset === -1) offset = 0;
      if (!initing) p.offset = offset + 1;
      else p.offset = offset;
      this.needToCommit = true;
    }
  });

  if (this.options.autoCommit &#x26;&#x26; !initing) {
    this.autoCommit(false, function (err) {
      err &#x26;&#x26; logger.debug(&#x27;auto commit offset&#x27;, err);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.setOffset(topic.topic, topic.partition, offset);
    this.resume();
  });
});

// &#x27;done&#x27; will be emit when a message fetch request complete
this.on(&#x27;done&#x27;, function (topics) {
  self.<span class="apidocCodeKeywordSpan">updateOffsets</span>(topics);
  if (!self.paused) {
    setImmediate(function () {
      self.fetch();
    });
  }
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.HighLevelProducer" id="apidoc.module.kafka-node.HighLevelProducer">module kafka-node.HighLevelProducer</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelProducer.HighLevelProducer" id="apidoc.element.kafka-node.HighLevelProducer.HighLevelProducer">
        function <span class="apidocSignatureSpan">kafka-node.</span>HighLevelProducer
        <span class="apidocSignatureSpan">(client, options, customPartitioner)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HighLevelProducer(client, options, customPartitioner) {
  BaseProducer.call(this, client, options, BaseProducer.PARTITIONER_TYPES.cyclic, customPartitioner);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelProducer.super_" id="apidoc.element.kafka-node.HighLevelProducer.super_">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.</span>super_
        <span class="apidocSignatureSpan">(client, options, defaultPartitionerType, customPartitioner)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BaseProducer(client, options, defaultPartitionerType, customPartitioner) {
  options = options || {};

  this.ready = false;
  this.client = client;

  this.requireAcks = options.requireAcks === undefined
    ? DEFAULTS.requireAcks
    : options.requireAcks;
  this.ackTimeoutMs = options.ackTimeoutMs === undefined
    ? DEFAULTS.ackTimeoutMs
    : options.ackTimeoutMs;

  if (customPartitioner !== undefined &#x26;&#x26; options.partitionerType !== PARTITIONER_TYPES.custom) {
    throw new Error(&#x27;Partitioner Type must be custom if providing a customPartitioner.&#x27;);
  } else if (customPartitioner === undefined &#x26;&#x26; options.partitionerType === PARTITIONER_TYPES.custom) {
    throw new Error(&#x27;No customer partitioner defined&#x27;);
  }

  var partitionerType = PARTITIONER_MAP[options.partitionerType] || PARTITIONER_MAP[defaultPartitionerType];

  // eslint-disable-next-line
  this.partitioner = new partitionerType(customPartitioner);

  this.connect();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.HighLevelProducer.super_" id="apidoc.module.kafka-node.HighLevelProducer.super_">module kafka-node.HighLevelProducer.super_</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelProducer.super_.super_" id="apidoc.element.kafka-node.HighLevelProducer.super_.super_">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.HighLevelProducer.super_.prototype" id="apidoc.module.kafka-node.HighLevelProducer.super_.prototype">module kafka-node.HighLevelProducer.super_.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.buildPayloads" id="apidoc.element.kafka-node.HighLevelProducer.super_.prototype.buildPayloads">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.super_.prototype.</span>buildPayloads
        <span class="apidocSignatureSpan">(payloads, topicMetadata)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildPayloads = function (payloads, topicMetadata) {
  const topicPartitionRequests = Object.create(null);
  payloads.forEach((p) =&#x3e; {
    p.partition = p.hasOwnProperty(&#x27;partition&#x27;) ? p.partition : this.partitioner.getPartition(_.map(topicMetadata[p.topic], &#x27;partition
&#x27;), p.key);
    p.attributes = p.hasOwnProperty(&#x27;attributes&#x27;) ? p.attributes : 0;
    let messages = _.isArray(p.messages) ? p.messages : [p.messages];

    messages = messages.map(function (message) {
      if (message instanceof KeyedMessage) {
        return message;
      }
      return new Message(0, 0, &#x27;&#x27;, message);
    });

    let key = p.topic + p.partition;
    let request = topicPartitionRequests[key];

    if (request == null) {
      topicPartitionRequests[key] = new ProduceRequest(p.topic, p.partition, messages, p.attributes);
    } else {
      assert(request.attributes === p.attributes);
      Array.prototype.push.apply(request.messages, messages);
    }
  });
  return _.values(topicPartitionRequests);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {BaseProducer~sendCallback} cb A function to call once the send has completed
 */
BaseProducer.prototype.send = function (payloads, cb) {
var client = this.client;
var requireAcks = this.requireAcks;
var ackTimeoutMs = this.ackTimeoutMs;

client.sendProduceRequest(this.<span class="apidocCodeKeywordSpan">buildPayloads</span>(payloads, client.topicMetadata), requireAcks
, ackTimeoutMs, cb);
};

BaseProducer.prototype.buildPayloads = function (payloads, topicMetadata) {
const topicPartitionRequests = Object.create(null);
payloads.forEach((p) =&#x3e; {
  p.partition = p.hasOwnProperty(&#x27;partition&#x27;) ? p.partition : this.partitioner.getPartition(_.map(topicMetadata[p.topic
], &#x27;partition&#x27;), p.key);
  p.attributes = p.hasOwnProperty(&#x27;attributes&#x27;) ? p.attributes : 0;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.close" id="apidoc.element.kafka-node.HighLevelProducer.super_.prototype.close">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.super_.prototype.</span>close
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (cb) {
  this.client.close(cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### close(force, cb)
* `force`: **Boolean**, if set to true, it forces the consumer to commit the current offset before closing, default `false`

Example

```js
consumer.<span class="apidocCodeKeywordSpan">close</span>(true, cb);
consumer.close(cb); //force is disabled
```

## HighLevelConsumer
 ***This consumer has been deprecated in the latest version of Kafka (0.10.1) and is likely to be removed in the future. Please
 use the ConsumerGroup instead.***

### HighLevelConsumer(client, payloads, options)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.connect" id="apidoc.element.kafka-node.HighLevelProducer.super_.prototype.connect">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.super_.prototype.</span>connect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connect = function () {
  // emiter...
  var self = this;
  this.ready = this.client.ready;
  if (this.ready) self.emit(&#x27;ready&#x27;);
  this.client.on(&#x27;ready&#x27;, function () {
    if (!self.ready) {
      self.ready = true;
      self.emit(&#x27;ready&#x27;);
    }
  });
  this.client.on(&#x27;brokersChanged&#x27;, function () {
    let topics = Object.keys(this.topicMetadata);
    this.refreshMetadata(topics, function (error) {
      if (error) {
        self.emit(&#x27;error&#x27;, error);
      }
    });
  });
  this.client.on(&#x27;error&#x27;, function (err) {
    self.emit(&#x27;error&#x27;, err);
  });
  this.client.on(&#x27;close&#x27;, function () {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

var partitionerType = PARTITIONER_MAP[options.partitionerType] || PARTITIONER_MAP[defaultPartitionerType];

// eslint-disable-next-line
this.partitioner = new partitionerType(customPartitioner);

this.<span class="apidocCodeKeywordSpan">connect</span>();
}

util.inherits(BaseProducer, events.EventEmitter);

BaseProducer.prototype.connect = function () {
// emiter...
var self = this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.createTopics" id="apidoc.element.kafka-node.HighLevelProducer.super_.prototype.createTopics">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.super_.prototype.</span>createTopics
        <span class="apidocSignatureSpan">(topics, async, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createTopics = function (topics, async, cb) {
  if (!this.ready) {
    return cb(new Error(&#x27;Producer not ready!&#x27;));
  }

  this.client.createTopics(topics, async, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

``` js
var kafka = require(&#x27;kafka-node&#x27;),
    Producer = kafka.Producer,
    client = new kafka.Client(),
    producer = new Producer(client);
// Create topics sync
producer.<span class="apidocCodeKeywordSpan">createTopics</span>([&#x27;t&#x27;,&#x27;t1&#x27;], false, function (err, data) {
    console.log(data);
});
// Create topics async
producer.createTopics([&#x27;t&#x27;], true, function (err, data) {});
producer.createTopics([&#x27;t&#x27;], function (err, data) {});// Simply omit 2nd arg
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.HighLevelProducer.super_.prototype.send" id="apidoc.element.kafka-node.HighLevelProducer.super_.prototype.send">
        function <span class="apidocSignatureSpan">kafka-node.HighLevelProducer.super_.prototype.</span>send
        <span class="apidocSignatureSpan">(payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">send = function (payloads, cb) {
  var client = this.client;
  var requireAcks = this.requireAcks;
  var ackTimeoutMs = this.ackTimeoutMs;

  client.sendProduceRequest(this.buildPayloads(payloads, client.topicMetadata), requireAcks, ackTimeoutMs, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    producer = new Producer(client),
    km = new KeyedMessage(&#x27;key&#x27;, &#x27;message&#x27;),
    payloads = [
        { topic: &#x27;topic1&#x27;, messages: &#x27;hi&#x27;, partition: 0 },
        { topic: &#x27;topic2&#x27;, messages: [&#x27;hello&#x27;, &#x27;world&#x27;, km] }
    ];
producer.on(&#x27;ready&#x27;, function () {
    producer.<span class="apidocCodeKeywordSpan">send</span>(payloads, function (err, data) {
        console.log(data);
    });
});

producer.on(&#x27;error&#x27;, function (err) {})
```
&#x3e; **WARNING**: Batch multiple messages of the same topic/partition together as an array on the `messages` attribute otherwise
 you may lose messages!
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.IllegalGenerationError" id="apidoc.module.kafka-node.IllegalGenerationError">module kafka-node.IllegalGenerationError</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.IllegalGenerationError.IllegalGenerationError" id="apidoc.element.kafka-node.IllegalGenerationError.IllegalGenerationError">
        function <span class="apidocSignatureSpan">kafka-node.</span>IllegalGenerationError
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IllegalGenerationError = function (message) {
  Error.captureStackTrace(this, this);
  this.message = message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.IllegalGenerationError.super_" id="apidoc.element.kafka-node.IllegalGenerationError.super_">
        function <span class="apidocSignatureSpan">kafka-node.IllegalGenerationError.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Error() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.InvalidConfigError" id="apidoc.module.kafka-node.InvalidConfigError">module kafka-node.InvalidConfigError</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.InvalidConfigError.InvalidConfigError" id="apidoc.element.kafka-node.InvalidConfigError.InvalidConfigError">
        function <span class="apidocSignatureSpan">kafka-node.</span>InvalidConfigError
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">InvalidConfigError = function (message) {
  Error.captureStackTrace(this, this);
  this.message = message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.InvalidConfigError.super_" id="apidoc.element.kafka-node.InvalidConfigError.super_">
        function <span class="apidocSignatureSpan">kafka-node.InvalidConfigError.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Error() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.InvalidConsumerOffsetError" id="apidoc.module.kafka-node.InvalidConsumerOffsetError">module kafka-node.InvalidConsumerOffsetError</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.InvalidConsumerOffsetError.InvalidConsumerOffsetError" id="apidoc.element.kafka-node.InvalidConsumerOffsetError.InvalidConsumerOffsetError">
        function <span class="apidocSignatureSpan">kafka-node.</span>InvalidConsumerOffsetError
        <span class="apidocSignatureSpan">(message, nested)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">InvalidConsumerOffsetError = function (message, nested) {
  NestedError.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.client.on(&#x27;reconnect&#x27;, function (lastError) {
self.fetch();
  });

  this.on(&#x27;offsetOutOfRange&#x27;, topic =&#x3e; {
this.pause();
if (this.options.outOfRangeOffset === &#x27;none&#x27;) {
  this.emit(&#x27;error&#x27;, new errors.<span class="apidocCodeKeywordSpan">InvalidConsumerOffsetError</span>(`Offset out of range
 for topic &#x22;${topic.topic}&#x22; partition ${topic.partition}`));
  return;
}

topic.time = ACCEPTED_FROM_OFFSET[this.options.outOfRangeOffset];

this.getOffset().fetch([topic], (error, result) =&#x3e; {
  if (error) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.InvalidConsumerOffsetError.super_" id="apidoc.element.kafka-node.InvalidConsumerOffsetError.super_">
        function <span class="apidocSignatureSpan">kafka-node.InvalidConsumerOffsetError.</span>super_
        <span class="apidocSignatureSpan">(message, nested)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function (message, nested) {
    this.nested = nested;

    if (typeof message !== &#x27;undefined&#x27;) {
        Object.defineProperty(this, &#x27;message&#x27;, {
            value: message,
            writable: true,
            enumerable: false,
            configurable: true
        });
    }

    Error.captureStackTrace(this, this.constructor);
    var oldStackDescriptor = Object.getOwnPropertyDescriptor(this, &#x27;stack&#x27;);
    var stackDescriptor = buildStackDescriptor(oldStackDescriptor, nested);
    Object.defineProperty(this, &#x27;stack&#x27;, stackDescriptor);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.KafkaBuffer" id="apidoc.module.kafka-node.KafkaBuffer">module kafka-node.KafkaBuffer</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.KafkaBuffer.KafkaBuffer" id="apidoc.element.kafka-node.KafkaBuffer.KafkaBuffer">
        function <span class="apidocSignatureSpan">kafka-node.</span>KafkaBuffer
        <span class="apidocSignatureSpan">(batchSize, batchAge)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">KafkaBuffer = function (batchSize, batchAge) {
  this._batch_size = batchSize;
  this._batch_age = batchAge;
  this._batch_age_timer = null;
  this._buffer = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.KafkaBuffer.prototype" id="apidoc.module.kafka-node.KafkaBuffer.prototype">module kafka-node.KafkaBuffer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.KafkaBuffer.prototype._setupTimer" id="apidoc.element.kafka-node.KafkaBuffer.prototype._setupTimer">
        function <span class="apidocSignatureSpan">kafka-node.KafkaBuffer.prototype.</span>_setupTimer
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_setupTimer = function (callback) {
  var self = this;

  if (this._batch_age_timer != null) {
    clearTimeout(this._batch_age_timer);
  }

  this._batch_age_timer = setTimeout(function () {
    if (self._buffer &#x26;&#x26; (self._buffer.length &#x3e; 0)) {
      callback();
    }
  }, this._batch_age);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

if (typeof callback !== &#x27;undefined&#x27; &#x26;&#x26; callback != null) {
  if (this._batch_size == null || this._batch_age == null ||
    (this._buffer &#x26;&#x26; (this._buffer.length &#x3e; this._batch_size))) {
    callback();
  } else {
    this.<span class="apidocCodeKeywordSpan">_setupTimer</span>(callback);
  }
}
};

KafkaBuffer.prototype._setupTimer = function (callback) {
var self = this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.KafkaBuffer.prototype.addChunk" id="apidoc.element.kafka-node.KafkaBuffer.prototype.addChunk">
        function <span class="apidocSignatureSpan">kafka-node.KafkaBuffer.prototype.</span>addChunk
        <span class="apidocSignatureSpan">(buffer, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addChunk = function (buffer, callback) {
  if (this._buffer == null) {
    this._buffer = new Buffer(buffer);
  } else {
    this._buffer = Buffer.concat([this._buffer, buffer]);
  }

  if (typeof callback !== &#x27;undefined&#x27; &#x26;&#x26; callback != null) {
    if (this._batch_size == null || this._batch_age == null ||
      (this._buffer &#x26;&#x26; (this._buffer.length &#x3e; this._batch_size))) {
      callback();
    } else {
      this._setupTimer(callback);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.noAckBatchAge = options ? options.noAckBatchAge : null;
  this._KafkaBuffer = new KafkaBuffer(this.noAckBatchSize, this.noAckBatchAge);
};

util.inherits(BrokerTransform, Transform);

BrokerTransform.prototype._transform = function (chunk, enc, done) {
  this._KafkaBuffer.<span class="apidocCodeKeywordSpan">addChunk</span>(chunk, this._transformNext.bind(this));
  done();
};

BrokerTransform.prototype._transformNext = function () {
  this.push(this._KafkaBuffer.getBatch());
  this._KafkaBuffer.truncateBatch();
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.KafkaBuffer.prototype.getBatch" id="apidoc.element.kafka-node.KafkaBuffer.prototype.getBatch">
        function <span class="apidocSignatureSpan">kafka-node.KafkaBuffer.prototype.</span>getBatch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getBatch = function () {
  return this._buffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

BrokerTransform.prototype._transform = function (chunk, enc, done) {
  this._KafkaBuffer.addChunk(chunk, this._transformNext.bind(this));
  done();
};

BrokerTransform.prototype._transformNext = function () {
  this.push(this._KafkaBuffer.<span class="apidocCodeKeywordSpan">getBatch</span>());
  this._KafkaBuffer.truncateBatch();
};

module.exports = BrokerTransform;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.KafkaBuffer.prototype.truncateBatch" id="apidoc.element.kafka-node.KafkaBuffer.prototype.truncateBatch">
        function <span class="apidocSignatureSpan">kafka-node.KafkaBuffer.prototype.</span>truncateBatch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">truncateBatch = function () {
  this._buffer = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
BrokerTransform.prototype._transform = function (chunk, enc, done) {
  this._KafkaBuffer.addChunk(chunk, this._transformNext.bind(this));
  done();
};

BrokerTransform.prototype._transformNext = function () {
  this.push(this._KafkaBuffer.getBatch());
  this._KafkaBuffer.<span class="apidocCodeKeywordSpan">truncateBatch</span>();
};

module.exports = BrokerTransform;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.KeyedPartitioner" id="apidoc.module.kafka-node.KeyedPartitioner">module kafka-node.KeyedPartitioner</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.KeyedPartitioner.KeyedPartitioner" id="apidoc.element.kafka-node.KeyedPartitioner.KeyedPartitioner">
        function <span class="apidocSignatureSpan">kafka-node.</span>KeyedPartitioner
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">KeyedPartitioner = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.KeyedPartitioner.super_" id="apidoc.element.kafka-node.KeyedPartitioner.super_">
        function <span class="apidocSignatureSpan">kafka-node.KeyedPartitioner.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.KeyedPartitioner.prototype" id="apidoc.module.kafka-node.KeyedPartitioner.prototype">module kafka-node.KeyedPartitioner.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.KeyedPartitioner.prototype.getPartition" id="apidoc.element.kafka-node.KeyedPartitioner.prototype.getPartition">
        function <span class="apidocSignatureSpan">kafka-node.KeyedPartitioner.prototype.</span>getPartition
        <span class="apidocSignatureSpan">(partitions, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPartition = function (partitions, key) {
  key = key || &#x27;&#x27;;

  var index = this.hashCode(key) % partitions.length;
  return partitions[index];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  client.sendProduceRequest(this.buildPayloads(payloads, client.topicMetadata), requireAcks, ackTimeoutMs, cb);
};

BaseProducer.prototype.buildPayloads = function (payloads, topicMetadata) {
  const topicPartitionRequests = Object.create(null);
  payloads.forEach((p) =&#x3e; {
p.partition = p.hasOwnProperty(&#x27;partition&#x27;) ? p.partition : this.partitioner.<span class="apidocCodeKeywordSpan">getPartition
</span>(_.map(topicMetadata[p.topic], &#x27;partition&#x27;), p.key);
p.attributes = p.hasOwnProperty(&#x27;attributes&#x27;) ? p.attributes : 0;
let messages = _.isArray(p.messages) ? p.messages : [p.messages];

messages = messages.map(function (message) {
  if (message instanceof KeyedMessage) {
    return message;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.KeyedPartitioner.prototype.hashCode" id="apidoc.element.kafka-node.KeyedPartitioner.prototype.hashCode">
        function <span class="apidocSignatureSpan">kafka-node.KeyedPartitioner.prototype.</span>hashCode
        <span class="apidocSignatureSpan">(string)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hashCode = function (string) {
  var hash = 0;
  var length = string.length;

  for (var i = 0; i &#x3c; length; i++) {
    hash = ((hash * 31) + string.charCodeAt(i)) &#x26; 0x7fffffff;
  }

  return (hash === 0) ? 1 : hash;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  return (hash === 0) ? 1 : hash;
};

KeyedPartitioner.prototype.getPartition = function (partitions, key) {
  key = key || &#x27;&#x27;;

  var index = this.<span class="apidocCodeKeywordSpan">hashCode</span>(key) % partitions.length;
  return partitions[index];
};

var CustomPartitioner = function (partitioner) {
  this.getPartition = partitioner;
};
util.inherits(CustomPartitioner, Partitioner);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.NotCoordinatorForGroupError" id="apidoc.module.kafka-node.NotCoordinatorForGroupError">module kafka-node.NotCoordinatorForGroupError</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.NotCoordinatorForGroupError.NotCoordinatorForGroupError" id="apidoc.element.kafka-node.NotCoordinatorForGroupError.NotCoordinatorForGroupError">
        function <span class="apidocSignatureSpan">kafka-node.</span>NotCoordinatorForGroupError
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">NotCoordinatorForGroupError = function (message) {
  Error.captureStackTrace(this, this);
  this.message = message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.NotCoordinatorForGroupError.super_" id="apidoc.element.kafka-node.NotCoordinatorForGroupError.super_">
        function <span class="apidocSignatureSpan">kafka-node.NotCoordinatorForGroupError.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Error() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Offset" id="apidoc.module.kafka-node.Offset">module kafka-node.Offset</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Offset.Offset" id="apidoc.element.kafka-node.Offset.Offset">
        function <span class="apidocSignatureSpan">kafka-node.</span>Offset
        <span class="apidocSignatureSpan">(client)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Offset = function (client) {
  var self = this;
  this.client = client;
  this.ready = this.client.ready;
  this.client.on(&#x27;ready&#x27;, function () {
    self.ready = true;
    self.emit(&#x27;ready&#x27;);
  });
  this.client.once(&#x27;connect&#x27;, function () {
    self.emit(&#x27;connect&#x27;);
  });
  this.client.on(&#x27;error&#x27;, function (err) {
    self.emit(&#x27;error&#x27;, err);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `cb`: *Function*, the callback

Example

```js
var kafka = require(&#x27;kafka-node&#x27;),
    client = new kafka.Client(),
    offset = new kafka.<span class="apidocCodeKeywordSpan">Offset</span>(client);
    offset.fetch([
        { topic: &#x27;t&#x27;, partition: 0, time: Date.now(), maxNum: 1 }
    ], function (err, data) {
        // data
        // { &#x27;t&#x27;: { &#x27;0&#x27;: [999] } }
    });
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Offset.super_" id="apidoc.element.kafka-node.Offset.super_">
        function <span class="apidocSignatureSpan">kafka-node.Offset.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Offset.prototype" id="apidoc.module.kafka-node.Offset.prototype">module kafka-node.Offset.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Offset.prototype.buildPayloads" id="apidoc.element.kafka-node.Offset.prototype.buildPayloads">
        function <span class="apidocSignatureSpan">kafka-node.Offset.prototype.</span>buildPayloads
        <span class="apidocSignatureSpan">(payloads)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildPayloads = function (payloads) {
  return payloads.map(function (p) {
    p.partition = p.partition || 0;
    p.time = p.time || Date.now();
    p.maxNum = p.maxNum || 1;
    p.metadata = &#x27;m&#x27;; // metadata can be arbitrary
    return p;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {BaseProducer~sendCallback} cb A function to call once the send has completed
 */
BaseProducer.prototype.send = function (payloads, cb) {
var client = this.client;
var requireAcks = this.requireAcks;
var ackTimeoutMs = this.ackTimeoutMs;

client.sendProduceRequest(this.<span class="apidocCodeKeywordSpan">buildPayloads</span>(payloads, client.topicMetadata), requireAcks
, ackTimeoutMs, cb);
};

BaseProducer.prototype.buildPayloads = function (payloads, topicMetadata) {
const topicPartitionRequests = Object.create(null);
payloads.forEach((p) =&#x3e; {
  p.partition = p.hasOwnProperty(&#x27;partition&#x27;) ? p.partition : this.partitioner.getPartition(_.map(topicMetadata[p.topic
], &#x27;partition&#x27;), p.key);
  p.attributes = p.hasOwnProperty(&#x27;attributes&#x27;) ? p.attributes : 0;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Offset.prototype.commit" id="apidoc.element.kafka-node.Offset.prototype.commit">
        function <span class="apidocSignatureSpan">kafka-node.Offset.prototype.</span>commit
        <span class="apidocSignatureSpan">(groupId, payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">commit = function (groupId, payloads, cb) {
  if (!this.ready) {
    this.once(&#x27;ready&#x27;, () =&#x3e; this.commit(groupId, payloads, cb));
    return;
  }
  this.client.sendOffsetCommitRequest(groupId, this.buildPayloads(payloads), cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Commit offset of the current topics manually, this method should be called when a consumer leaves

* `cb`: **Function**, the callback

Example:

``` js
consumer.<span class="apidocCodeKeywordSpan">commit</span>(function(err, data) {
});
```

### setOffset(topic, partition, offset)
Set offset of the given topic

* `topic`: **String**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Offset.prototype.fetch" id="apidoc.element.kafka-node.Offset.prototype.fetch">
        function <span class="apidocSignatureSpan">kafka-node.Offset.prototype.</span>fetch
        <span class="apidocSignatureSpan">(payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetch = function (payloads, cb) {
  if (!this.ready) {
    this.once(&#x27;ready&#x27;, () =&#x3e; this.fetch(payloads, cb));
    return;
  }
  this.client.sendOffsetRequest(this.buildPayloads(payloads), cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Example

```js
var kafka = require(&#x27;kafka-node&#x27;),
    client = new kafka.Client(),
    offset = new kafka.Offset(client);
    offset.<span class="apidocCodeKeywordSpan">fetch</span>([
        { topic: &#x27;t&#x27;, partition: 0, time: Date.now(), maxNum: 1 }
    ], function (err, data) {
        // data
        // { &#x27;t&#x27;: { &#x27;0&#x27;: [999] } }
    });
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Offset.prototype.fetchCommits" id="apidoc.element.kafka-node.Offset.prototype.fetchCommits">
        function <span class="apidocSignatureSpan">kafka-node.Offset.prototype.</span>fetchCommits
        <span class="apidocSignatureSpan">(groupId, payloads, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetchCommits = function (groupId, payloads, cb) {
  if (!this.ready) {
    this.once(&#x27;ready&#x27;, () =&#x3e; this.fetchCommits(groupId, payloads, cb));
    return;
  }
  this.client.sendOffsetFetchRequest(groupId, this.buildPayloads(payloads), cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Example

```js
var kafka = require(&#x27;kafka-node&#x27;),
    client = new kafka.Client(),
    offset = new kafka.Offset(client);
    offset.<span class="apidocCodeKeywordSpan">fetchCommits</span>(&#x27;groupId&#x27;, [
        { topic: &#x27;t&#x27;, partition: 0 }
    ], function (err, data) {
    });
```

### fetchLatestOffsets(topics, cb)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Offset.prototype.fetchEarliestOffsets" id="apidoc.element.kafka-node.Offset.prototype.fetchEarliestOffsets">
        function <span class="apidocSignatureSpan">kafka-node.Offset.prototype.</span>fetchEarliestOffsets
        <span class="apidocSignatureSpan">(topics, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetchEarliestOffsets = function (topics, cb) {
  fetchOffsets(this, topics, cb, -2);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### fetchEarliestOffsets(topics, cb)

Example

```js
	var partition = 0;
	var topic = &#x27;t&#x27;;
	offset.<span class="apidocCodeKeywordSpan">fetchEarliestOffsets</span>([topic], function (error, offsets) {
		if (error)
			return handleError(error);
		console.log(offsets[topic][partition]);
	});
```

# Troubleshooting / FAQ
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Offset.prototype.fetchLatestOffsets" id="apidoc.element.kafka-node.Offset.prototype.fetchLatestOffsets">
        function <span class="apidocSignatureSpan">kafka-node.Offset.prototype.</span>fetchLatestOffsets
        <span class="apidocSignatureSpan">(topics, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetchLatestOffsets = function (topics, cb) {
  fetchOffsets(this, topics, cb, -1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### fetchLatestOffsets(topics, cb)

Example

```js
	var partition = 0;
	var topic = &#x27;t&#x27;;
	offset.<span class="apidocCodeKeywordSpan">fetchLatestOffsets</span>([topic], function (error, offsets) {
		if (error)
			return handleError(error);
		console.log(offsets[topic][partition]);
	});
```

### fetchEarliestOffsets(topics, cb)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.Producer" id="apidoc.module.kafka-node.Producer">module kafka-node.Producer</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.Producer.Producer" id="apidoc.element.kafka-node.Producer.Producer">
        function <span class="apidocSignatureSpan">kafka-node.</span>Producer
        <span class="apidocSignatureSpan">(client, options, customPartitioner)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Producer(client, options, customPartitioner) {
  BaseProducer.call(this, client, options, BaseProducer.PARTITIONER_TYPES.default, customPartitioner);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.Producer.super_" id="apidoc.element.kafka-node.Producer.super_">
        function <span class="apidocSignatureSpan">kafka-node.Producer.</span>super_
        <span class="apidocSignatureSpan">(client, options, defaultPartitionerType, customPartitioner)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BaseProducer(client, options, defaultPartitionerType, customPartitioner) {
  options = options || {};

  this.ready = false;
  this.client = client;

  this.requireAcks = options.requireAcks === undefined
    ? DEFAULTS.requireAcks
    : options.requireAcks;
  this.ackTimeoutMs = options.ackTimeoutMs === undefined
    ? DEFAULTS.ackTimeoutMs
    : options.ackTimeoutMs;

  if (customPartitioner !== undefined &#x26;&#x26; options.partitionerType !== PARTITIONER_TYPES.custom) {
    throw new Error(&#x27;Partitioner Type must be custom if providing a customPartitioner.&#x27;);
  } else if (customPartitioner === undefined &#x26;&#x26; options.partitionerType === PARTITIONER_TYPES.custom) {
    throw new Error(&#x27;No customer partitioner defined&#x27;);
  }

  var partitionerType = PARTITIONER_MAP[options.partitionerType] || PARTITIONER_MAP[defaultPartitionerType];

  // eslint-disable-next-line
  this.partitioner = new partitionerType(customPartitioner);

  this.connect();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.RandomPartitioner" id="apidoc.module.kafka-node.RandomPartitioner">module kafka-node.RandomPartitioner</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.RandomPartitioner.RandomPartitioner" id="apidoc.element.kafka-node.RandomPartitioner.RandomPartitioner">
        function <span class="apidocSignatureSpan">kafka-node.</span>RandomPartitioner
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RandomPartitioner = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.RandomPartitioner.super_" id="apidoc.element.kafka-node.RandomPartitioner.super_">
        function <span class="apidocSignatureSpan">kafka-node.RandomPartitioner.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.RandomPartitioner.prototype" id="apidoc.module.kafka-node.RandomPartitioner.prototype">module kafka-node.RandomPartitioner.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.RandomPartitioner.prototype.getPartition" id="apidoc.element.kafka-node.RandomPartitioner.prototype.getPartition">
        function <span class="apidocSignatureSpan">kafka-node.RandomPartitioner.prototype.</span>getPartition
        <span class="apidocSignatureSpan">(partitions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPartition = function (partitions) {
  return partitions[Math.floor(Math.random() * partitions.length)];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  client.sendProduceRequest(this.buildPayloads(payloads, client.topicMetadata), requireAcks, ackTimeoutMs, cb);
};

BaseProducer.prototype.buildPayloads = function (payloads, topicMetadata) {
  const topicPartitionRequests = Object.create(null);
  payloads.forEach((p) =&#x3e; {
p.partition = p.hasOwnProperty(&#x27;partition&#x27;) ? p.partition : this.partitioner.<span class="apidocCodeKeywordSpan">getPartition
</span>(_.map(topicMetadata[p.topic], &#x27;partition&#x27;), p.key);
p.attributes = p.hasOwnProperty(&#x27;attributes&#x27;) ? p.attributes : 0;
let messages = _.isArray(p.messages) ? p.messages : [p.messages];

messages = messages.map(function (message) {
  if (message instanceof KeyedMessage) {
    return message;
  }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.RebalanceInProgressError" id="apidoc.module.kafka-node.RebalanceInProgressError">module kafka-node.RebalanceInProgressError</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.RebalanceInProgressError.RebalanceInProgressError" id="apidoc.element.kafka-node.RebalanceInProgressError.RebalanceInProgressError">
        function <span class="apidocSignatureSpan">kafka-node.</span>RebalanceInProgressError
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RebalanceInProgressError = function (message) {
  Error.captureStackTrace(this, this);
  this.message = message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.RebalanceInProgressError.super_" id="apidoc.element.kafka-node.RebalanceInProgressError.super_">
        function <span class="apidocSignatureSpan">kafka-node.RebalanceInProgressError.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Error() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.TopicsNotExistError" id="apidoc.module.kafka-node.TopicsNotExistError">module kafka-node.TopicsNotExistError</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.TopicsNotExistError.TopicsNotExistError" id="apidoc.element.kafka-node.TopicsNotExistError.TopicsNotExistError">
        function <span class="apidocSignatureSpan">kafka-node.</span>TopicsNotExistError
        <span class="apidocSignatureSpan">(topics)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TopicsNotExistError = function (topics) {
  Error.captureStackTrace(this, this);
  this.topics = topics;
  this.message = &#x27;The topic(s) &#x27; + topics.toString() + &#x27; do not exist&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
Client.prototype.topicExists = function (topics, cb) {
var notExistsTopics = [];
var self = this;

async.each(topics, checkZK, function (err) {
  if (err) return cb(err);
  if (notExistsTopics.length) return cb(new errors.<span class="apidocCodeKeywordSpan">TopicsNotExistError</span>(notExistsTopics
));
  cb();
});

function checkZK (topic, cb) {
  self.zk.topicExists(topic, function (err, existed, topic) {
    if (err) return cb(err);
    if (!existed) notExistsTopics.push(topic);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.TopicsNotExistError.super_" id="apidoc.element.kafka-node.TopicsNotExistError.super_">
        function <span class="apidocSignatureSpan">kafka-node.TopicsNotExistError.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Error() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.UnknownMemberIdError" id="apidoc.module.kafka-node.UnknownMemberIdError">module kafka-node.UnknownMemberIdError</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.UnknownMemberIdError.UnknownMemberIdError" id="apidoc.element.kafka-node.UnknownMemberIdError.UnknownMemberIdError">
        function <span class="apidocSignatureSpan">kafka-node.</span>UnknownMemberIdError
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">UnknownMemberIdError = function (message) {
  Error.captureStackTrace(this, this);
  this.message = message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.UnknownMemberIdError.super_" id="apidoc.element.kafka-node.UnknownMemberIdError.super_">
        function <span class="apidocSignatureSpan">kafka-node.UnknownMemberIdError.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Error() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.consumerGroupMigrator" id="apidoc.module.kafka-node.consumerGroupMigrator">module kafka-node.consumerGroupMigrator</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.consumerGroupMigrator.consumerGroupMigrator" id="apidoc.element.kafka-node.consumerGroupMigrator.consumerGroupMigrator">
        function <span class="apidocSignatureSpan">kafka-node.</span>consumerGroupMigrator
        <span class="apidocSignatureSpan">(consumerGroup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ConsumerGroupMigrator(consumerGroup) {
  EventEmitter.call(this);
  assert(consumerGroup);
  const self = this;
  this.consumerGroup = consumerGroup;
  this.client = consumerGroup.client;
  var verified = 0;

  if (consumerGroup.options.migrateRolling) {
    this.zk = zookeeper.createClient(consumerGroup.client.connectionString, {retries: 10});
    this.zk.on(&#x27;connected&#x27;, function () {
      self.filterByExistingZkTopics(function (error, topics) {
        if (error) {
          return self.emit(&#x27;error&#x27;, error);
        }

        if (topics.length) {
          self.checkForOwnersAndListenForChange(topics);
        } else {
          logger.debug(&#x27;No HLC topics exist in zookeeper.&#x27;);
          self.connectConsumerGroup();
        }
      });
    });

    this.on(&#x27;noOwnersForTopics&#x27;, function (topics) {
      logger.debug(&#x27;No owners for topics %s reported.&#x27;, topics);
      if (++verified &#x3c;= NUMER_OF_TIMES_TO_VERIFY) {
        logger.debug(&#x27;%s verify %d of %d HLC has given up ownership by checking again in %d&#x27;, self.client.clientId, verified,
          NUMER_OF_TIMES_TO_VERIFY, VERIFY_WAIT_TIME_MS);

        setTimeout(function () {
          self.checkForOwners(topics);
        }, VERIFY_WAIT_TIME_MS);
      } else {
        self.connectConsumerGroup();
      }
    });

    this.on(&#x27;topicOwnerChange&#x27;, _.debounce(function (topics) {
      verified = 0;
      self.checkForOwnersAndListenForChange(topics);
    }, 250));

    this.zk.connect();
  } else {
    this.connectConsumerGroup();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.consumerGroupMigrator.super_" id="apidoc.element.kafka-node.consumerGroupMigrator.super_">
        function <span class="apidocSignatureSpan">kafka-node.consumerGroupMigrator.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.consumerGroupMigrator.prototype" id="apidoc.module.kafka-node.consumerGroupMigrator.prototype">module kafka-node.consumerGroupMigrator.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.consumerGroupMigrator.prototype.checkForOwners" id="apidoc.element.kafka-node.consumerGroupMigrator.prototype.checkForOwners">
        function <span class="apidocSignatureSpan">kafka-node.consumerGroupMigrator.prototype.</span>checkForOwners
        <span class="apidocSignatureSpan">(topics, listenForChange)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkForOwners = function (topics, listenForChange) {
  const self = this;
  const path = &#x27;/consumers/&#x27; + this.consumerGroup.options.groupId + &#x27;/owners/&#x27;;
  var ownedPartitions = 0;

  function topicWatcher (event) {
    self.emit(&#x27;topicOwnerChange&#x27;, topics);
  }

  async.each(topics,
    function (topic, callback) {
      const args = [path + topic];

      if (listenForChange) {
        logger.debug(&#x27;%s listening for changes in topic %s&#x27;, self.client.clientId, topic);
        args.push(topicWatcher);
      }

      args.push(function (error, children, stats) {
        if (error) {
          return callback(error);
        }
        ownedPartitions += children.length;
        callback(null);
      });

      self.zk.getChildren.apply(self.zk, args);
    },
    function (error) {
      if (error) {
        return self.emit(&#x27;error&#x27;, error);
      }
      if (ownedPartitions === 0) {
        self.emit(&#x27;noOwnersForTopics&#x27;, topics);
      } else {
        logger.debug(&#x27;%s %d partitions are owned by old HLC... waiting...&#x27;, self.client.clientId, ownedPartitions);
      }
    }
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.on(&#x27;noOwnersForTopics&#x27;, function (topics) {
  logger.debug(&#x27;No owners for topics %s reported.&#x27;, topics);
  if (++verified &#x3c;= NUMER_OF_TIMES_TO_VERIFY) {
    logger.debug(&#x27;%s verify %d of %d HLC has given up ownership by checking again in %d&#x27;, self.client.clientId, verified
,
      NUMER_OF_TIMES_TO_VERIFY, VERIFY_WAIT_TIME_MS);

    setTimeout(function () {
      self.<span class="apidocCodeKeywordSpan">checkForOwners</span>(topics);
    }, VERIFY_WAIT_TIME_MS);
  } else {
    self.connectConsumerGroup();
  }
});

this.on(&#x27;topicOwnerChange&#x27;, _.debounce(function (topics) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.consumerGroupMigrator.prototype.checkForOwnersAndListenForChange" id="apidoc.element.kafka-node.consumerGroupMigrator.prototype.checkForOwnersAndListenForChange">
        function <span class="apidocSignatureSpan">kafka-node.consumerGroupMigrator.prototype.</span>checkForOwnersAndListenForChange
        <span class="apidocSignatureSpan">(topics)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkForOwnersAndListenForChange = function (topics) {
  this.checkForOwners(topics, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.zk.on(&#x27;connected&#x27;, function () {
  self.filterByExistingZkTopics(function (error, topics) {
    if (error) {
      return self.emit(&#x27;error&#x27;, error);
    }

    if (topics.length) {
      self.<span class="apidocCodeKeywordSpan">checkForOwnersAndListenForChange</span>(topics);
    } else {
      logger.debug(&#x27;No HLC topics exist in zookeeper.&#x27;);
      self.connectConsumerGroup();
    }
  });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.consumerGroupMigrator.prototype.connectConsumerGroup" id="apidoc.element.kafka-node.consumerGroupMigrator.prototype.connectConsumerGroup">
        function <span class="apidocSignatureSpan">kafka-node.consumerGroupMigrator.prototype.</span>connectConsumerGroup
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connectConsumerGroup = function () {
  logger.debug(&#x27;%s connecting consumer group&#x27;, this.client.clientId);
  const self = this;
  if (this.client.ready) {
    this.consumerGroup.connect();
  } else {
    this.client.once(&#x27;ready&#x27;, function () {
      self.consumerGroup.connect();
    });
  }
  this.zk &#x26;&#x26; this.zk.close();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return self.emit(&#x27;error&#x27;, error);
    }

    if (topics.length) {
      self.checkForOwnersAndListenForChange(topics);
    } else {
      logger.debug(&#x27;No HLC topics exist in zookeeper.&#x27;);
      self.<span class="apidocCodeKeywordSpan">connectConsumerGroup</span>();
    }
  });
});

this.on(&#x27;noOwnersForTopics&#x27;, function (topics) {
  logger.debug(&#x27;No owners for topics %s reported.&#x27;, topics);
  if (++verified &#x3c;= NUMER_OF_TIMES_TO_VERIFY) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.consumerGroupMigrator.prototype.filterByExistingZkTopics" id="apidoc.element.kafka-node.consumerGroupMigrator.prototype.filterByExistingZkTopics">
        function <span class="apidocSignatureSpan">kafka-node.consumerGroupMigrator.prototype.</span>filterByExistingZkTopics
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filterByExistingZkTopics = function (callback) {
  const self = this;
  const path = &#x27;/consumers/&#x27; + this.consumerGroup.options.groupId + &#x27;/owners/&#x27;;

  async.filter(this.consumerGroup.topics, function (topic, cb) {
    const topicPath = path + topic;
    logger.debug(&#x27;%s checking zk path %s&#x27;, self.client.clientId, topicPath);
    self.zk.exists(topicPath, function (error, stat) {
      if (error) {
        return callback(error);
      }
      cb(stat);
    });
  }, function (result) {
    callback(null, result);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.consumerGroup = consumerGroup;
  this.client = consumerGroup.client;
  var verified = 0;

  if (consumerGroup.options.migrateRolling) {
    this.zk = zookeeper.createClient(consumerGroup.client.connectionString, {retries: 10});
    this.zk.on(&#x27;connected&#x27;, function () {
      self.<span class="apidocCodeKeywordSpan">filterByExistingZkTopics</span>(function (error, topics) {
if (error) {
  return self.emit(&#x27;error&#x27;, error);
}

if (topics.length) {
  self.checkForOwnersAndListenForChange(topics);
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.consumerGroupMigrator.prototype.getOffset" id="apidoc.element.kafka-node.consumerGroupMigrator.prototype.getOffset">
        function <span class="apidocSignatureSpan">kafka-node.consumerGroupMigrator.prototype.</span>getOffset
        <span class="apidocSignatureSpan">(tp, defaultOffset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOffset = function (tp, defaultOffset) {
  const offset = _.get(this.offsets, [tp.topic, tp.partition], defaultOffset);
  if (offset === -1) {
    return defaultOffset;
  }
  return offset;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this.options.outOfRangeOffset === &#x27;none&#x27;) {
  this.emit(&#x27;error&#x27;, new errors.InvalidConsumerOffsetError(`Offset out of range for topic &#x22;${topic.topic}&#x22; partition
 ${topic.partition}`));
  return;
}

topic.time = ACCEPTED_FROM_OFFSET[this.options.outOfRangeOffset];

this.<span class="apidocCodeKeywordSpan">getOffset</span>().fetch([topic], (error, result) =&#x3e; {
  if (error) {
    this.emit(&#x27;error&#x27;, new errors.InvalidConsumerOffsetError(`Fetching ${this.options.outOfRangeOffset} offset failed`,
error));
    return;
  }
  const offset = _.head(result[topic.topic][topic.partition]);
  const oldOffset = _.find(this.topicPayloads, {topic: topic.topic, partition: topic.partition}).offset;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.consumerGroupMigrator.prototype.saveHighLevelConsumerOffsets" id="apidoc.element.kafka-node.consumerGroupMigrator.prototype.saveHighLevelConsumerOffsets">
        function <span class="apidocSignatureSpan">kafka-node.consumerGroupMigrator.prototype.</span>saveHighLevelConsumerOffsets
        <span class="apidocSignatureSpan">(topicPartitionList, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">saveHighLevelConsumerOffsets = function (topicPartitionList, callback) {
  const self = this;
  this.client.sendOffsetFetchRequest(this.consumerGroup.options.groupId, topicPartitionList, function (error, results) {
    logger.debug(&#x27;sendOffsetFetchRequest response:&#x27;, results, error);
    if (error) {
      return callback(error);
    }
    self.offsets = results;
    callback(null);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (self.options.fromOffset === &#x27;none&#x27;) {
  return callback(new Error(`${self.client.clientId} owns topics and partitions which contains no saved offsets for group &#x27;${
self.options.groupId}&#x27;`));
}

async.parallel([
  function (callback) {
    if (self.migrator) {
      return self.migrator.<span class="apidocCodeKeywordSpan">saveHighLevelConsumerOffsets</span>(topicPartitionList, callback);
    }
    callback(null);
  },
  function (callback) {
    if (useDefaultOffsets) {
      return self.saveDefaultOffsets(topicPartitionList, callback);
    }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.consumerGroupRecovery" id="apidoc.module.kafka-node.consumerGroupRecovery">module kafka-node.consumerGroupRecovery</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.consumerGroupRecovery.consumerGroupRecovery" id="apidoc.element.kafka-node.consumerGroupRecovery.consumerGroupRecovery">
        function <span class="apidocSignatureSpan">kafka-node.</span>consumerGroupRecovery
        <span class="apidocSignatureSpan">(consumerGroup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ConsumerGroupRecovery(consumerGroup) {
  this.consumerGroup = consumerGroup;
  this.options = consumerGroup.options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.consumerGroupRecovery.prototype" id="apidoc.module.kafka-node.consumerGroupRecovery.prototype">module kafka-node.consumerGroupRecovery.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.consumerGroupRecovery.prototype.clearError" id="apidoc.element.kafka-node.consumerGroupRecovery.prototype.clearError">
        function <span class="apidocSignatureSpan">kafka-node.consumerGroupRecovery.prototype.</span>clearError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearError = function () {
  this.lastError = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
self.connecting = false;
self.rebalancing = false;
if (error) {
  return self.recovery.tryToRecoverFrom(error, &#x27;connect&#x27;);
}

self.ready = true;
self.recovery.<span class="apidocCodeKeywordSpan">clearError</span>();

logger.debug(&#x27;generationId&#x27;, self.generationId);

if (startFetch) {
  self.fetch();
}
self.startHeartbeats();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.consumerGroupRecovery.prototype.getRetryTimeout" id="apidoc.element.kafka-node.consumerGroupRecovery.prototype.getRetryTimeout">
        function <span class="apidocSignatureSpan">kafka-node.consumerGroupRecovery.prototype.</span>getRetryTimeout
        <span class="apidocSignatureSpan">(error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getRetryTimeout = function (error) {
  assert(error);
  if (!this._timeouts) {
    this._timeouts = retry.timeouts({
      retries: this.options.retries,
      factor: this.options.retryFactor,
      minTimeout: this.options.retryMinTimeout
    });
  }

  if (this._retryIndex == null || this.lastError == null ||
      error.errorCode !== this.lastError.errorCode) {
    this._retryIndex = 0;
  }

  var index = this._retryIndex++;
  if (index &#x3e;= this._timeouts.length) {
    return false;
  }
  return this._timeouts[index];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    recoverableItem.handler &#x26;&#x26; recoverableItem.handler.call(this.consumerGroup, error);
    return true;
  }
  return false;
}, this);

if (retry) {
  retryTimeout = this.<span class="apidocCodeKeywordSpan">getRetryTimeout</span>(error);
}

if (retry &#x26;&#x26; retryTimeout) {
  logger.debug(&#x27;RECOVERY from %s: %s retrying in %s ms&#x27;, source, this.consumerGroup.client.clientId, retryTimeout, error
);
  this.consumerGroup.scheduleReconnect(retryTimeout);
} else {
  this.consumerGroup.emit(&#x27;error&#x27;, error);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.consumerGroupRecovery.prototype.tryToRecoverFrom" id="apidoc.element.kafka-node.consumerGroupRecovery.prototype.tryToRecoverFrom">
        function <span class="apidocSignatureSpan">kafka-node.consumerGroupRecovery.prototype.</span>tryToRecoverFrom
        <span class="apidocSignatureSpan">(error, source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tryToRecoverFrom = function (error, source) {
  this.consumerGroup.ready = false;
  this.consumerGroup.stopHeartbeats();

  var retryTimeout = false;
  var retry = recoverableErrors.some(function (recoverableItem) {
    if (isErrorInstanceOf(error, recoverableItem.errors)) {
      recoverableItem.handler &#x26;&#x26; recoverableItem.handler.call(this.consumerGroup, error);
      return true;
    }
    return false;
  }, this);

  if (retry) {
    retryTimeout = this.getRetryTimeout(error);
  }

  if (retry &#x26;&#x26; retryTimeout) {
    logger.debug(&#x27;RECOVERY from %s: %s retrying in %s ms&#x27;, source, this.consumerGroup.client.clientId, retryTimeout, error);
    this.consumerGroup.scheduleReconnect(retryTimeout);
  } else {
    this.consumerGroup.emit(&#x27;error&#x27;, error);
  }
  this.lastError = error;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function (syncGroupResponse, callback) {
  self.handleSyncGroup(syncGroupResponse, callback);
}
  ], function (error, startFetch) {
self.connecting = false;
self.rebalancing = false;
if (error) {
  return self.recovery.<span class="apidocCodeKeywordSpan">tryToRecoverFrom</span>(error, &#x27;connect&#x27;);
}

self.ready = true;
self.recovery.clearError();

logger.debug(&#x27;generationId&#x27;, self.generationId);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.logging" id="apidoc.module.kafka-node.logging">module kafka-node.logging</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.logging.setLoggerProvider" id="apidoc.element.kafka-node.logging.setLoggerProvider">
        function <span class="apidocSignatureSpan">kafka-node.logging.</span>setLoggerProvider
        <span class="apidocSignatureSpan">(provider)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setLoggerProvider(provider) {
  loggerProvider = provider;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### How do I set a logger provider?

For performance reasons, initialization of the `kafka-node` module creates all necessary loggers. This means that custom logger
providers need to be set *before requiring the `kafka-node` module*. The following example shows how this can be done:

```javascript
// first configure the logger provider
const kafkaLogging = require(&#x27;kafka-node/logging&#x27;);
kafkaLogging.<span class="apidocCodeKeywordSpan">setLoggerProvider</span>(consoleLoggerProvider);

// then require kafka-node and continue as normal
const kafka = require(&#x27;kafka-node&#x27;);
```

# Running Tests
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.partitioner" id="apidoc.module.kafka-node.partitioner">module kafka-node.partitioner</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.partitioner.CustomPartitioner" id="apidoc.element.kafka-node.partitioner.CustomPartitioner">
        function <span class="apidocSignatureSpan">kafka-node.partitioner.</span>CustomPartitioner
        <span class="apidocSignatureSpan">(partitioner)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CustomPartitioner = function (partitioner) {
  this.getPartition = partitioner;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.partitioner.CyclicPartitioner" id="apidoc.element.kafka-node.partitioner.CyclicPartitioner">
        function <span class="apidocSignatureSpan">kafka-node.partitioner.</span>CyclicPartitioner
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CyclicPartitioner = function () {
  this.c = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.partitioner.DefaultPartitioner" id="apidoc.element.kafka-node.partitioner.DefaultPartitioner">
        function <span class="apidocSignatureSpan">kafka-node.partitioner.</span>DefaultPartitioner
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">DefaultPartitioner = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.partitioner.KeyedPartitioner" id="apidoc.element.kafka-node.partitioner.KeyedPartitioner">
        function <span class="apidocSignatureSpan">kafka-node.partitioner.</span>KeyedPartitioner
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">KeyedPartitioner = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.partitioner.RandomPartitioner" id="apidoc.element.kafka-node.partitioner.RandomPartitioner">
        function <span class="apidocSignatureSpan">kafka-node.partitioner.</span>RandomPartitioner
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RandomPartitioner = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.protocol" id="apidoc.module.kafka-node.protocol">module kafka-node.protocol</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.protocol.decodeFetchResponse" id="apidoc.element.kafka-node.protocol.decodeFetchResponse">
        function <span class="apidocSignatureSpan">kafka-node.protocol.</span>decodeFetchResponse
        <span class="apidocSignatureSpan">(cb, maxTickMessages)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decodeFetchResponse(cb, maxTickMessages) {
  return function (resp) {
    return _decodeFetchResponse(resp, cb, maxTickMessages);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  broker.socket.end();
});
};

Client.prototype.sendFetchRequest = function (consumer, payloads, fetchMaxWaitMs, fetchMinBytes, maxTickMessages) {
var self = this;
var encoder = protocol.encodeFetchRequest(fetchMaxWaitMs, fetchMinBytes);
var decoder = protocol.<span class="apidocCodeKeywordSpan">decodeFetchResponse</span>(function (err, type, message) {
  if (err) {
    if (err.message === &#x27;OffsetOutOfRange&#x27;) {
      return consumer.emit(&#x27;offsetOutOfRange&#x27;, err);
    } else if (err.message === &#x27;NotLeaderForPartition&#x27; || err.message === &#x27;UnknownTopicOrPartition&#x27;) {
      return self.emit(&#x27;brokersChanged&#x27;);
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.protocol.decodeGroupCoordinatorResponse" id="apidoc.element.kafka-node.protocol.decodeGroupCoordinatorResponse">
        function <span class="apidocSignatureSpan">kafka-node.protocol.</span>decodeGroupCoordinatorResponse
        <span class="apidocSignatureSpan">(resp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decodeGroupCoordinatorResponse(resp) {
  var result;
  Binary.parse(resp)
    .word32bs(&#x27;size&#x27;)
    .word32bs(&#x27;correlationId&#x27;)
    .word16bs(&#x27;errorCode&#x27;)
    .word32bs(&#x27;coordinatorId&#x27;)
    .word16bs(&#x27;coordinatorHost&#x27;)
    .tap(function (vars) {
      this.buffer(&#x27;coordinatorHost&#x27;, vars.coordinatorHost);
      vars.coordinatorHost = vars.coordinatorHost.toString();
    })
    .word32bs(&#x27;coordinatorPort&#x27;)
    .tap(function (vars) {
      if (vars.errorCode !== 0) {
        result = createGroupError(vars.errorCode);
        return;
      }

      result = {
        coordinatorHost: vars.coordinatorHost,
        coordinatorPort: vars.coordinatorPort,
        coordinatorId: vars.coordinatorId
      };
    });
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.protocol.decodeGroupHeartbeat" id="apidoc.element.kafka-node.protocol.decodeGroupHeartbeat">
        function <span class="apidocSignatureSpan">kafka-node.protocol.</span>decodeGroupHeartbeat
        <span class="apidocSignatureSpan">(resp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decodeGroupHeartbeat(resp) {
  var result = null;
  Binary.parse(resp)
    .word32bs(&#x27;size&#x27;)
    .word32bs(&#x27;correlationId&#x27;)
    .word16bs(&#x27;errorCode&#x27;)
    .tap(function (vars) {
      result = createGroupError(vars.errorCode);
    });
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.protocol.decodeJoinGroupResponse" id="apidoc.element.kafka-node.protocol.decodeJoinGroupResponse">
        function <span class="apidocSignatureSpan">kafka-node.protocol.</span>decodeJoinGroupResponse
        <span class="apidocSignatureSpan">(resp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decodeJoinGroupResponse(resp) {
  var result = {
    members: []
  };

  var error;

  Binary.parse(resp)
    .word32bs(&#x27;size&#x27;)
    .word32bs(&#x27;correlationId&#x27;)
    .word16bs(&#x27;errorCode&#x27;)
    .tap(function (vars) {
      error = createGroupError(vars.errorCode);
    })
    .word32bs(&#x27;generationId&#x27;)
    .tap(function (vars) {
      result.generationId = vars.generationId;
    })
    .word16bs(&#x27;groupProtocol&#x27;)
    .tap(function (vars) {
      this.buffer(&#x27;groupProtocol&#x27;, vars.groupProtocol);
      result.groupProtocol = vars.groupProtocol = vars.groupProtocol.toString();
    })
    .word16bs(&#x27;leaderId&#x27;)
    .tap(function (vars) {
      this.buffer(&#x27;leaderId&#x27;, vars.leaderId);
      result.leaderId = vars.leaderId = vars.leaderId.toString();
    })
    .word16bs(&#x27;memberId&#x27;)
    .tap(function (vars) {
      this.buffer(&#x27;memberId&#x27;, vars.memberId);
      result.memberId = vars.memberId = vars.memberId.toString();
    })
    .word32bs(&#x27;memberNum&#x27;)
    .loop(function (end, vars) {
      if (error) {
        return end();
      }

      if (vars.memberNum-- === 0) return end();
      var memberMetadata;
      this
        .word16bs(&#x27;groupMemberId&#x27;).tap(function (vars) {
          this.buffer(&#x27;groupMemberId&#x27;, vars.groupMemberId);
          vars.memberId = vars.groupMemberId.toString();
        })
        .word32bs(&#x27;memberMetadata&#x27;).tap(function (vars) {
          if (vars.memberMetadata &#x3e; -1) {
            this.buffer(&#x27;memberMetadata&#x27;, vars.memberMetadata);
            memberMetadata = decodeGroupData(this.vars.memberMetadata);
            memberMetadata.id = vars.memberId;
            result.members.push(memberMetadata);
          }
        });
    });

  return error || result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.protocol.decodeLeaveGroupResponse" id="apidoc.element.kafka-node.protocol.decodeLeaveGroupResponse">
        function <span class="apidocSignatureSpan">kafka-node.protocol.</span>decodeLeaveGroupResponse
        <span class="apidocSignatureSpan">(resp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decodeLeaveGroupResponse(resp) {
  var error = null;
  Binary.parse(resp)
    .word32bs(&#x27;size&#x27;)
    .word32bs(&#x27;correlationId&#x27;)
    .word16bs(&#x27;errorCode&#x27;)
    .tap(function (vars) {
      error = createGroupError(vars.errorCode);
    });
  return error;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.protocol.decodeMetadataResponse" id="apidoc.element.kafka-node.protocol.decodeMetadataResponse">
        function <span class="apidocSignatureSpan">kafka-node.protocol.</span>decodeMetadataResponse
        <span class="apidocSignatureSpan">(resp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decodeMetadataResponse(resp) {
  var brokers = {};
  var out = {};
  var topics = {};
  var errors = [];
  Binary.parse(resp)
    .word32bs(&#x27;size&#x27;)
    .word32bs(&#x27;correlationId&#x27;)
    .word32bs(&#x27;brokerNum&#x27;)
    .loop(decodeBrokers)
    .word32bs(&#x27;topicNum&#x27;)
    .loop(_decodeTopics);

  function decodeBrokers (end, vars) {
    if (vars.brokerNum-- === 0) return end();
    this.word32bs(&#x27;nodeId&#x27;)
      .word16bs(&#x27;host&#x27;)
      .tap(function (vars) {
        this.buffer(&#x27;host&#x27;, vars.host);
        vars.host = vars.host.toString();
      })
      .word32bs(&#x27;port&#x27;)
      .tap(function (vars) {
        brokers[vars.nodeId] = { nodeId: vars.nodeId, host: vars.host, port: vars.port };
      });
  }

  function _decodeTopics (end, vars) {
    if (vars.topicNum-- === 0) return end();
    this.word16bs(&#x27;topicError&#x27;)
      .word16bs(&#x27;topic&#x27;)
      .tap(function (vars) {
        this.buffer(&#x27;topic&#x27;, vars.topic);
        vars.topic = vars.topic.toString();
      })
      .word32bs(&#x27;partitionNum&#x27;)
      .tap(function (vars) {
        if (vars.topicError !== 0) {
          return errors.push(ERROR_CODE[vars.topicError]);
        }
        this.loop(decodePartitions);
      });
  }

  function decodePartitions (end, vars) {
    if (vars.partitionNum-- === 0) return end();
    topics[vars.topic] = topics[vars.topic] || {};
    this.word16bs(&#x27;errorCode&#x27;)
      .word32bs(&#x27;partition&#x27;)
      .word32bs(&#x27;leader&#x27;)
      .word32bs(&#x27;replicasNum&#x27;)
      .tap(function (vars) {
        var buffer = this.buffer(&#x27;replicas&#x27;, vars.replicasNum * 4).vars.replicas;
        this.vars.replicas = bufferToArray(vars.replicasNum, buffer);
      })
      .word32bs(&#x27;isrNum&#x27;)
      .tap(function (vars) {
        var buffer = this.buffer(&#x27;isr&#x27;, vars.isrNum * 4).vars.isr;
        this.vars.isr = bufferToArray(vars.isrNum, buffer);
        if (vars.errorCode === 0 || vars.errorCode === 9) {
          topics[vars.topic][vars.partition] =
            new PartitionMetadata(vars.topic, vars.partition, vars.leader, vars.replicas, vars.isr);
        } else {
          errors.push(ERROR_CODE[vars.errorCode]);
        }
      });
  }

  if (!_.isEmpty(errors)) out.error = errors;
  out.metadata = topics;
  return [brokers, out];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.protocol.decodeOffsetCommitResponse" id="apidoc.element.kafka-node.protocol.decodeOffsetCommitResponse">
        function <span class="apidocSignatureSpan">kafka-node.protocol.</span>decodeOffsetCommitResponse
        <span class="apidocSignatureSpan">(resp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decodeOffsetCommitResponse(resp) {
  var topics = {};
  Binary.parse(resp)
    .word32bs(&#x27;size&#x27;)
    .word32bs(&#x27;correlationId&#x27;)
    .word32bs(&#x27;topicNum&#x27;)
    .loop(decodeTopics(decodePartitions));

  function decodePartitions (end, vars) {
    if (--vars.partitionNum === 0) end();
    topics[vars.topic] = topics[vars.topic] || {};
    this.word32bs(&#x27;partition&#x27;)
      .word16bs(&#x27;errorcode&#x27;)
      .tap(function (vars) {
        topics[vars.topic][&#x27;partition&#x27;] = vars.partition;
        topics[vars.topic][&#x27;errorCode&#x27;] = vars.errorcode;
      });
  }
  return topics;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.protocol.decodeOffsetFetchResponse" id="apidoc.element.kafka-node.protocol.decodeOffsetFetchResponse">
        function <span class="apidocSignatureSpan">kafka-node.protocol.</span>decodeOffsetFetchResponse
        <span class="apidocSignatureSpan">(resp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decodeOffsetFetchResponse(resp) {
  var topics = {};
  Binary.parse(resp)
    .word32bs(&#x27;size&#x27;)
    .word32bs(&#x27;correlationId&#x27;)
    .word32bs(&#x27;topicNum&#x27;)
    .loop(decodeTopics(decodePartitions));

  function decodePartitions (end, vars) {
    if (--vars.partitionNum === 0) end();
    topics[vars.topic] = topics[vars.topic] || {};
    this.word32bs(&#x27;partition&#x27;)
      .word64bs(&#x27;offset&#x27;)
      .word16bs(&#x27;metadata&#x27;)
      .tap(function (vars) {
        if (vars.metadata === -1) {
          return;
        }

        this.buffer(&#x27;metadata&#x27;, vars.metadata);
      })
      .word16bs(&#x27;errorCode&#x27;)
      .tap(function (vars) {
        topics[vars.topic][vars.partition] = vars.errorCode === 0 ? vars.offset : -1;
      });
  }
  return topics;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.protocol.decodeOffsetFetchV1Response" id="apidoc.element.kafka-node.protocol.decodeOffsetFetchV1Response">
        function <span class="apidocSignatureSpan">kafka-node.protocol.</span>decodeOffsetFetchV1Response
        <span class="apidocSignatureSpan">(resp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decodeOffsetFetchV1Response(resp) {
  var topics = {};
  Binary.parse(resp)
    .word32bs(&#x27;size&#x27;)
    .word32bs(&#x27;correlationId&#x27;)
    .word32bs(&#x27;topicNum&#x27;)
    .loop(decodeTopics(decodePartitions));

  function decodePartitions (end, vars) {
    if (--vars.partitionNum === 0) end();
    topics[vars.topic] = topics[vars.topic] || {};
    this.word32bs(&#x27;partition&#x27;)
      .word64bs(&#x27;offset&#x27;)
      .word16bs(&#x27;metadata&#x27;)
      .tap(function (vars) {
        if (vars.metadata === -1) {
          return;
        }

        this.buffer(&#x27;metadata&#x27;, vars.metadata);
      })
      .word16bs(&#x27;errorCode&#x27;)
      .tap(function (vars) {
        if (vars.metadata.length === 0 &#x26;&#x26; vars.offset === 0) {
          topics[vars.topic][vars.partition] = -1;
        } else {
          topics[vars.topic][vars.partition] = vars.errorCode === 0 ? vars.offset : -1;
        }
      });
  }
  return topics;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.protocol.decodeOffsetResponse" id="apidoc.element.kafka-node.protocol.decodeOffsetResponse">
        function <span class="apidocSignatureSpan">kafka-node.protocol.</span>decodeOffsetResponse
        <span class="apidocSignatureSpan">(resp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decodeOffsetResponse(resp) {
  var topics = {};
  Binary.parse(resp)
    .word32bs(&#x27;size&#x27;)
    .word32bs(&#x27;correlationId&#x27;)
    .word32bs(&#x27;topicNum&#x27;)
    .loop(decodeTopics(decodePartitions));

  function decodePartitions (end, vars) {
    if (--vars.partitionNum === 0) end();
    topics[vars.topic] = topics[vars.topic] || {};
    this.word32bs(&#x27;partition&#x27;)
      .word16bs(&#x27;errorCode&#x27;)
      .word32bs(&#x27;offsetNum&#x27;)
      .loop(decodeOffsets);
  }

  function decodeOffsets (end, vars) {
    if (--vars.offsetNum &#x3c;= 0) end();
    topics[vars.topic][vars.partition] = topics[vars.topic][vars.partition] || [];
    this.word64bs(&#x27;offset&#x27;)
      .tap(function (vars) {
        if (vars.offset != null) topics[vars.topic][vars.partition].push(vars.offset);
      });
  }
  return topics;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.protocol.decodeProduceResponse" id="apidoc.element.kafka-node.protocol.decodeProduceResponse">
        function <span class="apidocSignatureSpan">kafka-node.protocol.</span>decodeProduceResponse
        <span class="apidocSignatureSpan">(resp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decodeProduceResponse(resp) {
  var topics = {};
  var error;
  Binary.parse(resp)
    .word32bs(&#x27;size&#x27;)
    .word32bs(&#x27;correlationId&#x27;)
    .word32bs(&#x27;topicNum&#x27;)
    .loop(decodeTopics(decodePartitions));

  function decodePartitions (end, vars) {
    if (--vars.partitionNum === 0) end();
    topics[vars.topic] = topics[vars.topic] || {};
    this.word32bs(&#x27;partition&#x27;)
      .word16bs(&#x27;errorCode&#x27;)
      .word64bs(&#x27;offset&#x27;)
      .tap(function (vars) {
        if (vars.errorCode) {
          error = new Error(ERROR_CODE[vars.errorCode]);
        } else {
          topics[vars.topic][vars.partition] = vars.offset;
        }
      });
  }
  return error || topics;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.protocol.decodeSyncGroupResponse" id="apidoc.element.kafka-node.protocol.decodeSyncGroupResponse">
        function <span class="apidocSignatureSpan">kafka-node.protocol.</span>decodeSyncGroupResponse
        <span class="apidocSignatureSpan">(resp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decodeSyncGroupResponse(resp) {
  var result;
  Binary.parse(resp)
    .word32bs(&#x27;size&#x27;)
    .word32bs(&#x27;correlationId&#x27;)
    .word16bs(&#x27;errorCode&#x27;)
    .tap(function (vars) {
      result = createGroupError(vars.errorCode);
    })
    .word32bs(&#x27;memberAssignment&#x27;)
    .tap(function (vars) {
      if (result) {
        return;
      }
      this.buffer(&#x27;memberAssignment&#x27;, vars.memberAssignment);
      result = decodeMemberAssignment(vars.memberAssignment);
    });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.protocol.encodeFetchRequest" id="apidoc.element.kafka-node.protocol.encodeFetchRequest">
        function <span class="apidocSignatureSpan">kafka-node.protocol.</span>encodeFetchRequest
        <span class="apidocSignatureSpan">(maxWaitMs, minBytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function encodeFetchRequest(maxWaitMs, minBytes) {
  return function encodeFetchRequest (clientId, correlationId, payloads) {
    return _encodeFetchRequest(clientId, correlationId, payloads, maxWaitMs, minBytes);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  broker.socket.closing = true;
  broker.socket.end();
});
};

Client.prototype.sendFetchRequest = function (consumer, payloads, fetchMaxWaitMs, fetchMinBytes, maxTickMessages) {
var self = this;
var encoder = protocol.<span class="apidocCodeKeywordSpan">encodeFetchRequest</span>(fetchMaxWaitMs, fetchMinBytes);
var decoder = protocol.decodeFetchResponse(function (err, type, message) {
  if (err) {
    if (err.message === &#x27;OffsetOutOfRange&#x27;) {
      return consumer.emit(&#x27;offsetOutOfRange&#x27;, err);
    } else if (err.message === &#x27;NotLeaderForPartition&#x27; || err.message === &#x27;UnknownTopicOrPartition&#x27;) {
      return self.emit(&#x27;brokersChanged&#x27;);
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.protocol.encodeGroupCoordinatorRequest" id="apidoc.element.kafka-node.protocol.encodeGroupCoordinatorRequest">
        function <span class="apidocSignatureSpan">kafka-node.protocol.</span>encodeGroupCoordinatorRequest
        <span class="apidocSignatureSpan">(clientId, correlationId, groupId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function encodeGroupCoordinatorRequest(clientId, correlationId, groupId) {
  var request = encodeRequestHeader(clientId, correlationId, REQUEST_TYPE.groupCoordinator);
  request.Int16BE(groupId.length).string(groupId);
  return encodeRequestWithLength(request.make());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.protocol.encodeGroupHeartbeat" id="apidoc.element.kafka-node.protocol.encodeGroupHeartbeat">
        function <span class="apidocSignatureSpan">kafka-node.protocol.</span>encodeGroupHeartbeat
        <span class="apidocSignatureSpan">(clientId, correlationId, groupId, generationId, memberId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function encodeGroupHeartbeat(clientId, correlationId, groupId, generationId, memberId) {
  var request = encodeRequestHeader(clientId, correlationId, REQUEST_TYPE.heartbeat);
  request
    .Int16BE(groupId.length).string(groupId)
    .Int32BE(generationId)
    .Int16BE(memberId.length).string(memberId);
  return encodeRequestWithLength(request.make());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.protocol.encodeJoinGroupRequest" id="apidoc.element.kafka-node.protocol.encodeJoinGroupRequest">
        function <span class="apidocSignatureSpan">kafka-node.protocol.</span>encodeJoinGroupRequest
        <span class="apidocSignatureSpan">(clientId, correlationId, groupId, memberId, sessionTimeout, groupProtocols)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function encodeJoinGroupRequest(clientId, correlationId, groupId, memberId, sessionTimeout, groupProtocols) {
  var request = encodeRequestHeader(clientId, correlationId, REQUEST_TYPE.joinGroup);
  request
    .Int16BE(groupId.length).string(groupId)
    .Int32BE(sessionTimeout)
    .Int16BE(memberId.length).string(memberId)
    .Int16BE(GROUPS_PROTOCOL_TYPE.length).string(GROUPS_PROTOCOL_TYPE)
    .Int32BE(groupProtocols.length);

  groupProtocols.forEach(encodeGroupProtocol.bind(request));

  return encodeRequestWithLength(request.make());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.protocol.encodeLeaveGroupRequest" id="apidoc.element.kafka-node.protocol.encodeLeaveGroupRequest">
        function <span class="apidocSignatureSpan">kafka-node.protocol.</span>encodeLeaveGroupRequest
        <span class="apidocSignatureSpan">(clientId, correlationId, groupId, memberId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function encodeLeaveGroupRequest(clientId, correlationId, groupId, memberId) {
  var request = encodeRequestHeader(clientId, correlationId, REQUEST_TYPE.leaveGroup);
  request
    .Int16BE(groupId.length).string(groupId)
    .Int16BE(memberId.length).string(memberId);

  return encodeRequestWithLength(request.make());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.protocol.encodeMessageSet" id="apidoc.element.kafka-node.protocol.encodeMessageSet">
        function <span class="apidocSignatureSpan">kafka-node.protocol.</span>encodeMessageSet
        <span class="apidocSignatureSpan">(messageSet)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function encodeMessageSet(messageSet) {
  var buffer = new Buffermaker();
  messageSet.forEach(function (message) {
    var msg = encodeMessage(message);
    buffer.Int64BE(0)
      .Int32BE(msg.length)
      .string(msg);
  });
  return buffer.make();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.protocol.encodeMetadataRequest" id="apidoc.element.kafka-node.protocol.encodeMetadataRequest">
        function <span class="apidocSignatureSpan">kafka-node.protocol.</span>encodeMetadataRequest
        <span class="apidocSignatureSpan">(clientId, correlationId, topics)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function encodeMetadataRequest(clientId, correlationId, topics) {
  var request = encodeRequestHeader(clientId, correlationId, REQUEST_TYPE.metadata);
  request.Int32BE(topics.length);
  topics.forEach(function (topic) {
    request.Int16BE(topic.length)
      .string(topic);
  });
  return encodeRequestWithLength(request.make());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * containing the topic name, partition, leader number, replica count, and in sync replicas per partition.
 *
 * @param {Array} topics An array of topics to load the metadata for
 * @param {Client~loadMetadataForTopicsCallback} cb Function to call once all metadata is loaded
 */
Client.prototype.loadMetadataForTopics = function (topics, cb) {
var correlationId = this.nextId();
var request = protocol.<span class="apidocCodeKeywordSpan">encodeMetadataRequest</span>(this.clientId, correlationId, topics);
var broker = this.brokerForLeader();

if (!broker || !broker.socket || broker.socket.error || broker.socket.destroyed) {
  return cb(new errors.BrokerNotAvailableError(&#x27;Broker not available&#x27;));
}

this.queueCallback(broker.socket, correlationId, [protocol.decodeMetadataResponse, cb]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.protocol.encodeOffsetCommitRequest" id="apidoc.element.kafka-node.protocol.encodeOffsetCommitRequest">
        function <span class="apidocSignatureSpan">kafka-node.protocol.</span>encodeOffsetCommitRequest
        <span class="apidocSignatureSpan">(group)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function encodeOffsetCommitRequest(group) {
  return function (clientId, correlationId, payloads) {
    return _encodeOffsetCommitRequest(clientId, correlationId, group, payloads);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    payload.messages = [ new Message(0, attributes, &#x27;&#x27;, message) ];
    cb();
  });
}
};

Client.prototype.sendOffsetCommitRequest = function (group, payloads, cb) {
var encoder = protocol.<span class="apidocCodeKeywordSpan">encodeOffsetCommitRequest</span>(group);
var decoder = protocol.decodeOffsetCommitResponse;
this.send(payloads, encoder, decoder, cb);
};

Client.prototype.sendOffsetCommitV2Request = function (group, generationId, memberId, payloads, cb) {
var encoder = protocol.encodeOffsetCommitV2Request;
var decoder = protocol.decodeOffsetCommitResponse;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.protocol.encodeOffsetCommitV2Request" id="apidoc.element.kafka-node.protocol.encodeOffsetCommitV2Request">
        function <span class="apidocSignatureSpan">kafka-node.protocol.</span>encodeOffsetCommitV2Request
        <span class="apidocSignatureSpan">(clientId, correlationId, group, generationId, memberId, payloads)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function encodeOffsetCommitV2Request(clientId, correlationId, group, generationId, memberId, payloads) {
  payloads = groupByTopic(payloads);
  var request = encodeRequestHeader(clientId, correlationId, REQUEST_TYPE.offsetCommit, 2);
  var topics = Object.keys(payloads);

  request.Int16BE(group.length).string(group)
    .Int32BE(generationId)
    .Int16BE(memberId.length).string(memberId)
    .Int64BE(-1)
    .Int32BE(topics.length);

  topics.forEach(function (topic) {
    request.Int16BE(topic.length)
      .string(topic);

    var partitions = _.toPairs(payloads[topic]).map(function (pairs) { return pairs[1]; });
    request.Int32BE(partitions.length);
    partitions.forEach(function (p) {
      request.Int32BE(p.partition)
        .Int64BE(p.offset)
        .Int16BE(p.metadata.length)
        .string(p.metadata);
    });
  });

  return encodeRequestWithLength(request.make());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.protocol.encodeOffsetFetchRequest" id="apidoc.element.kafka-node.protocol.encodeOffsetFetchRequest">
        function <span class="apidocSignatureSpan">kafka-node.protocol.</span>encodeOffsetFetchRequest
        <span class="apidocSignatureSpan">(group)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function encodeOffsetFetchRequest(group) {
  return function (clientId, correlationId, payloads) {
    return _encodeOffsetFetchRequest(clientId, correlationId, group, payloads);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Client.prototype.sendOffsetFetchV1Request = function (group, payloads, cb) {
var encoder = protocol.encodeOffsetFetchV1Request;
var decoder = protocol.decodeOffsetFetchV1Response;
this.sendGroupRequest(encoder, decoder, arguments);
};

Client.prototype.sendOffsetFetchRequest = function (group, payloads, cb) {
var encoder = protocol.<span class="apidocCodeKeywordSpan">encodeOffsetFetchRequest</span>(group);
var decoder = protocol.decodeOffsetFetchResponse;
this.send(payloads, encoder, decoder, cb);
};

Client.prototype.sendOffsetRequest = function (payloads, cb) {
var encoder = protocol.encodeOffsetRequest;
var decoder = protocol.decodeOffsetResponse;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.protocol.encodeOffsetFetchV1Request" id="apidoc.element.kafka-node.protocol.encodeOffsetFetchV1Request">
        function <span class="apidocSignatureSpan">kafka-node.protocol.</span>encodeOffsetFetchV1Request
        <span class="apidocSignatureSpan">(clientId, correlationId, group, payloads)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function encodeOffsetFetchV1Request(clientId, correlationId, group, payloads) {
  var request = encodeRequestHeader(clientId, correlationId, REQUEST_TYPE.offsetFetch, 1);
  var topics = Object.keys(payloads);

  request.Int16BE(group.length)
    .string(group)
    .Int32BE(topics.length);

  topics.forEach(function (topic) {
    request.Int16BE(topic.length).string(topic)
      .Int32BE(payloads[topic].length);

    payloads[topic].forEach(function (p) {
      request.Int32BE(p);
    });
  });

  return encodeRequestWithLength(request.make());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.protocol.encodeOffsetRequest" id="apidoc.element.kafka-node.protocol.encodeOffsetRequest">
        function <span class="apidocSignatureSpan">kafka-node.protocol.</span>encodeOffsetRequest
        <span class="apidocSignatureSpan">(clientId, correlationId, payloads)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function encodeOffsetRequest(clientId, correlationId, payloads) {
  payloads = groupByTopic(payloads);
  var request = encodeRequestHeader(clientId, correlationId, REQUEST_TYPE.offset);
  var topics = Object.keys(payloads);

  request.Int32BE(REPLICA_ID)
    .Int32BE(topics.length);

  topics.forEach(function (topic) {
    request.Int16BE(topic.length)
      .string(topic);

    var partitions = _.toPairs(payloads[topic]).map(function (pairs) { return pairs[1]; });
    request.Int32BE(partitions.length);
    partitions.forEach(function (p) {
      request.Int32BE(p.partition)
        .Int64BE(p.time)
        .Int32BE(p.maxNum);
    });
  });

  return encodeRequestWithLength(request.make());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.protocol.encodeProduceRequest" id="apidoc.element.kafka-node.protocol.encodeProduceRequest">
        function <span class="apidocSignatureSpan">kafka-node.protocol.</span>encodeProduceRequest
        <span class="apidocSignatureSpan">(requireAcks, ackTimeoutMs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function encodeProduceRequest(requireAcks, ackTimeoutMs) {
  return function (clientId, correlationId, payloads) {
    return _encodeProduceRequest(clientId, correlationId, payloads, requireAcks, ackTimeoutMs);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    Array.prototype.unshift.call(arguments, &#x27;error&#x27;);
    consumer.emit.apply(consumer, arguments);
  }
});
};

Client.prototype.sendProduceRequest = function (payloads, requireAcks, ackTimeoutMs, cb) {
var encoder = protocol.<span class="apidocCodeKeywordSpan">encodeProduceRequest</span>(requireAcks, ackTimeoutMs);
var decoder = protocol.decodeProduceResponse;
var self = this;

decoder.requireAcks = requireAcks;

async.each(payloads, buildRequest, function (err) {
  if (err) return cb(err);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.protocol.encodeSyncGroupRequest" id="apidoc.element.kafka-node.protocol.encodeSyncGroupRequest">
        function <span class="apidocSignatureSpan">kafka-node.protocol.</span>encodeSyncGroupRequest
        <span class="apidocSignatureSpan">(clientId, correlationId, groupId, generationId, memberId, groupAssignment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function encodeSyncGroupRequest(clientId, correlationId, groupId, generationId, memberId, groupAssignment) {
  var request = encodeRequestHeader(clientId, correlationId, REQUEST_TYPE.syncGroup);
  request
    .Int16BE(groupId.length).string(groupId)
    .Int32BE(generationId)
    .Int16BE(memberId.length).string(memberId);

  if (groupAssignment &#x26;&#x26; groupAssignment.length) {
    request.Int32BE(groupAssignment.length);
    groupAssignment.forEach(function (assignment) {
      request.Int16BE(assignment.memberId.length).string(assignment.memberId)
        .string(_encodeMemberAssignment(assignment));
    });
  } else {
    request.Int32BE(0);
  }

  return encodeRequestWithLength(request.make());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.protocol_struct" id="apidoc.module.kafka-node.protocol_struct">module kafka-node.protocol_struct</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.protocol_struct.FetchRequest" id="apidoc.element.kafka-node.protocol_struct.FetchRequest">
        function <span class="apidocSignatureSpan">kafka-node.protocol_struct.</span>FetchRequest
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">FetchRequest = function () {
  for (var i = 0; i &#x3c; args.length; i++) {
    this[args[i]] = arguments[i];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.protocol_struct.FetchResponse" id="apidoc.element.kafka-node.protocol_struct.FetchResponse">
        function <span class="apidocSignatureSpan">kafka-node.protocol_struct.</span>FetchResponse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">FetchResponse = function () {
  for (var i = 0; i &#x3c; args.length; i++) {
    this[args[i]] = arguments[i];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.protocol_struct.KeyedMessage" id="apidoc.element.kafka-node.protocol_struct.KeyedMessage">
        function <span class="apidocSignatureSpan">kafka-node.protocol_struct.</span>KeyedMessage
        <span class="apidocSignatureSpan">(key, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function KeyedMessage(key, value) {
  exports.Message.call(this, 0, 0, key, value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.protocol_struct.Message" id="apidoc.element.kafka-node.protocol_struct.Message">
        function <span class="apidocSignatureSpan">kafka-node.protocol_struct.</span>Message
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Message = function () {
  for (var i = 0; i &#x3c; args.length; i++) {
    this[args[i]] = arguments[i];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.protocol_struct.OffsetCommitRequest" id="apidoc.element.kafka-node.protocol_struct.OffsetCommitRequest">
        function <span class="apidocSignatureSpan">kafka-node.protocol_struct.</span>OffsetCommitRequest
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">OffsetCommitRequest = function () {
  for (var i = 0; i &#x3c; args.length; i++) {
    this[args[i]] = arguments[i];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.protocol_struct.OffsetCommitResponse" id="apidoc.element.kafka-node.protocol_struct.OffsetCommitResponse">
        function <span class="apidocSignatureSpan">kafka-node.protocol_struct.</span>OffsetCommitResponse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">OffsetCommitResponse = function () {
  for (var i = 0; i &#x3c; args.length; i++) {
    this[args[i]] = arguments[i];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.protocol_struct.PartitionMetadata" id="apidoc.element.kafka-node.protocol_struct.PartitionMetadata">
        function <span class="apidocSignatureSpan">kafka-node.protocol_struct.</span>PartitionMetadata
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">PartitionMetadata = function () {
  for (var i = 0; i &#x3c; args.length; i++) {
    this[args[i]] = arguments[i];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.protocol_struct.ProduceRequest" id="apidoc.element.kafka-node.protocol_struct.ProduceRequest">
        function <span class="apidocSignatureSpan">kafka-node.protocol_struct.</span>ProduceRequest
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ProduceRequest = function () {
  for (var i = 0; i &#x3c; args.length; i++) {
    this[args[i]] = arguments[i];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.protocol_struct.Request" id="apidoc.element.kafka-node.protocol_struct.Request">
        function <span class="apidocSignatureSpan">kafka-node.protocol_struct.</span>Request
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Request = function () {
  for (var i = 0; i &#x3c; args.length; i++) {
    this[args[i]] = arguments[i];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.protocol_struct.TopicAndPartition" id="apidoc.element.kafka-node.protocol_struct.TopicAndPartition">
        function <span class="apidocSignatureSpan">kafka-node.protocol_struct.</span>TopicAndPartition
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TopicAndPartition = function () {
  for (var i = 0; i &#x3c; args.length; i++) {
    this[args[i]] = arguments[i];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.range" id="apidoc.module.kafka-node.range">module kafka-node.range</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.range.assign" id="apidoc.element.kafka-node.range.assign">
        function <span class="apidocSignatureSpan">kafka-node.range.</span>assign
        <span class="apidocSignatureSpan">(topicPartition, groupMembers, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function assignRange(topicPartition, groupMembers, callback) {
  logger.debug(&#x27;topicPartition: %j&#x27;, topicPartition);
  var assignment = _(groupMembers).map(&#x27;id&#x27;).reduce(function (obj, id) {
    obj[id] = [];
    return obj;
  }, {});

  const topicMemberMap = topicToMemberMap(groupMembers);
  for (var topic in topicMemberMap) {
    if (!topicMemberMap.hasOwnProperty(topic)) {
      continue;
    }
    logger.debug(&#x27;For topic %s&#x27;, topic);
    topicMemberMap[topic].sort();
    logger.debug(&#x27;   members: &#x27;, topicMemberMap[topic]);

    var numberOfPartitionsForTopic = topicPartition[topic].length;
    logger.debug(&#x27;   numberOfPartitionsForTopic&#x27;, numberOfPartitionsForTopic);

    var numberOfMembersForTopic = topicMemberMap[topic].length;
    logger.debug(&#x27;   numberOfMembersForTopic&#x27;, numberOfMembersForTopic);

    var numberPartitionsPerMember = Math.floor(numberOfPartitionsForTopic / numberOfMembersForTopic);
    logger.debug(&#x27;   numberPartitionsPerMember&#x27;, numberPartitionsPerMember);

    var membersWithExtraPartition = numberOfPartitionsForTopic % numberOfMembersForTopic;
    var topicPartitionList = createTopicPartitionArray(topic, numberOfPartitionsForTopic);

    for (var i = 0, n = numberOfMembersForTopic; i &#x3c; n; i++) {
      var start = numberPartitionsPerMember * i + Math.min(i, membersWithExtraPartition);
      var length = numberPartitionsPerMember + (i + 1 &#x3e; membersWithExtraPartition ? 0 : 1);
      var assignedTopicPartitions = assignment[topicMemberMap[topic][i]];
      assignedTopicPartitions.push.apply(assignedTopicPartitions, topicPartitionList.slice(start, start + length));
    }
  }

  logger.debug(assignment);

  callback(null, convertToAssignmentList(assignment, VERSION));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

this.protocols = protocols.map(function (protocol) {
  if (typeof protocol === &#x27;string&#x27;) {
    if (!(protocol in builtInProtocols)) {
      throw new Error(&#x27;Unknown built in assignment protocol &#x27; + protocol);
    }
    protocol = _.<span class="apidocCodeKeywordSpan">assign</span>({}, builtInProtocols[protocol]);
  } else {
    checkProtocol(protocol);
  }

  protocol.subscription = this.topics;
  return protocol;
}, this);
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.roundrobin" id="apidoc.module.kafka-node.roundrobin">module kafka-node.roundrobin</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.roundrobin.assign" id="apidoc.element.kafka-node.roundrobin.assign">
        function <span class="apidocSignatureSpan">kafka-node.roundrobin.</span>assign
        <span class="apidocSignatureSpan">(topicPartition, groupMembers, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function assignRoundRobin(topicPartition, groupMembers, callback) {
  logger.debug(&#x27;topicPartition: %j&#x27;, topicPartition);
  logger.debug(&#x27;groupMembers: %j&#x27;, groupMembers);
  var _members = _(groupMembers).map(&#x27;id&#x27;);
  var members = _members.value().sort();
  logger.debug(&#x27;members&#x27;, members);
  var assignment = _members.reduce(function (obj, id) {
    obj[id] = [];
    return obj;
  }, {});

  var subscriberMap = groupMembers.reduce(function (subscribers, member) {
    subscribers[member.id] = member.subscription;
    return subscribers;
  }, {});

  logger.debug(&#x27;subscribers&#x27;, subscriberMap);

  // layout topic/partitions pairs into a list
  var topicPartitionList = _(topicPartition).map(function (partitions, topic) {
    return partitions.map(function (partition) {
      return {
        topic: topic,
        partition: partition
      };
    });
  }).flatten().value();
  logger.debug(&#x27;round robin on topic partition pairs: &#x27;, topicPartitionList);

  var assigner = cycle(members);

  topicPartitionList.forEach(function (tp) {
    var topic = tp.topic;
    while (!_.includes(subscriberMap[assigner.peek()], topic)) {
      assigner.next();
    }
    assignment[assigner.next()].push(tp);
  });

  var ret = _.map(assignment, function (value, key) {
    var ret = {};
    ret.memberId = key;
    ret.topicPartitions = groupPartitionsByTopic(value);
    ret.version = VERSION;
    return ret;
  });

  callback(null, ret);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

this.protocols = protocols.map(function (protocol) {
  if (typeof protocol === &#x27;string&#x27;) {
    if (!(protocol in builtInProtocols)) {
      throw new Error(&#x27;Unknown built in assignment protocol &#x27; + protocol);
    }
    protocol = _.<span class="apidocCodeKeywordSpan">assign</span>({}, builtInProtocols[protocol]);
  } else {
    checkProtocol(protocol);
  }

  protocol.subscription = this.topics;
  return protocol;
}, this);
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.snappy" id="apidoc.module.kafka-node.snappy">module kafka-node.snappy</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.snappy.decode" id="apidoc.element.kafka-node.snappy.decode">
        function <span class="apidocSignatureSpan">kafka-node.snappy.</span>decode
        <span class="apidocSignatureSpan">(buffer, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decodeSnappy(buffer, cb) {
  if (isChunked(buffer)) {
    var pos = 16;
    var max = buffer.length;
    var encoded = [];
    var size;

    while (pos &#x3c; max) {
      size = buffer.readUInt32BE(pos);
      pos += 4;
      encoded.push(buffer.slice(pos, pos + size));
      pos += size;
    }
    return async.mapSeries(encoded, snappy.uncompress,
      function (err, decodedChunks) {
        if (err) return cb(err);
        return cb(null, Buffer.concat(decodedChunks));
      }
    );
  }
  return snappy.uncompress(buffer, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          value: vars.value,
          offset: vars.offset,
          partition: partition,
          highWaterOffset: highWaterOffset,
          key: vars.key
        });
      }
      codec.<span class="apidocCodeKeywordSpan">decode</span>(vars.value, function (error, inlineMessageSet) {
        if (error) return; // Not sure where to report this
        decodeMessageSet(topic, partition, inlineMessageSet, cb, maxTickMessages);
      });
    }
  });
// Defensive code around potential denial of service
if (maxTickMessages &#x26;&#x26; messageCount &#x3e; maxTickMessages) break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.snappy.encode" id="apidoc.element.kafka-node.snappy.encode">
        function <span class="apidocSignatureSpan">kafka-node.snappy.</span>encode
        <span class="apidocSignatureSpan">(input, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encode = function (input, callback) {
  if (!(typeof (input) === &#x27;string&#x27; || Buffer.isBuffer(input))) {
    return callback(new Error(&#x27;input must be a String or a Buffer&#x27;));
  }

  binding.compress(input, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  function buildRequest (payload, cb) {
    var attributes = payload.attributes;
    var codec = getCodec(attributes);

    if (!codec) return cb();

    var innerSet = encodeMessageSet(payload.messages);
    codec.<span class="apidocCodeKeywordSpan">encode</span>(innerSet, function (err, message) {
      if (err) return cb(err);
      payload.messages = [ new Message(0, attributes, &#x27;&#x27;, message) ];
      cb();
    });
  }
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.utils" id="apidoc.module.kafka-node.utils">module kafka-node.utils</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.utils.createTopicPartitionList" id="apidoc.element.kafka-node.utils.createTopicPartitionList">
        function <span class="apidocSignatureSpan">kafka-node.utils.</span>createTopicPartitionList
        <span class="apidocSignatureSpan">(topicPartitions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createTopicPartitionList(topicPartitions) {
  var tpList = [];
  for (var topic in topicPartitions) {
    if (!topicPartitions.hasOwnProperty(topic)) {
      continue;
    }
    topicPartitions[topic].forEach(function (partition) {
      tpList.push({
        topic: topic,
        partition: partition
      });
    });
  }
  return tpList;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.utils.groupPartitionsByTopic" id="apidoc.element.kafka-node.utils.groupPartitionsByTopic">
        function <span class="apidocSignatureSpan">kafka-node.utils.</span>groupPartitionsByTopic
        <span class="apidocSignatureSpan">(topicPartitions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function groupPartitionsByTopic(topicPartitions) {
  assert(Array.isArray(topicPartitions));
  return topicPartitions.reduce(function (result, tp) {
    if (!(tp.topic in result)) {
      result[tp.topic] = [tp.partition];
    } else {
      result[tp.topic].push(tp.partition);
    }
    return result;
  }, {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.utils.validateConfig" id="apidoc.element.kafka-node.utils.validateConfig">
        function <span class="apidocSignatureSpan">kafka-node.utils.</span>validateConfig
        <span class="apidocSignatureSpan">(property, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function validateConfig(property, value) {
  if (!legalChars.test(value)) {
    throw new InvalidConfigError([property, value, &#x22;is illegal, contains a character other than ASCII alphanumerics, &#x27;.&#x27;, &#x27;_&#x27; and
 &#x27;-&#x27;&#x22;].join(&#x27; &#x27;));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.paused = this.options.paused;
this.id = nextId();
this.payloads = this.buildPayloads(topics);
this.connect();
this.encoding = this.options.encoding;

if (this.options.groupId) {
  utils.<span class="apidocCodeKeywordSpan">validateConfig</span>(&#x27;options.groupId&#x27;, this.options.groupId);
}
};
util.inherits(Consumer, events.EventEmitter);

Consumer.prototype.buildPayloads = function (payloads) {
var self = this;
return payloads.map(function (p) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.utils.validateTopicNames" id="apidoc.element.kafka-node.utils.validateTopicNames">
        function <span class="apidocSignatureSpan">kafka-node.utils.</span>validateTopicNames
        <span class="apidocSignatureSpan">(topics)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function validateTopicNames(topics) {
  // Rewriting same validations done by Apache Kafka team for topics
  // iterating over topics
  topics.some(function (topic) {
    if (topic.length &#x3c;= 0) {
      throw new InvalidConfigError(&#x27;topic name is illegal, cannot be empty&#x27;);
    }
    if (topic === &#x27;.&#x27; || topic === &#x27;..&#x27;) {
      throw new InvalidConfigError(&#x27;topic name cannot be . or ..&#x27;);
    }
    if (topic.length &#x3e; allowedTopicLength) {
      throw new InvalidConfigError(`topic name is illegal, cannot be longer than ${allowedTopicLength} characters`);
    }
    if (!legalChars.test(topic)) {
      throw new InvalidConfigError(`topic name ${topic} is illegal, contains a character other than ASCII alphanumerics .,_ and -`);
    }
  });
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.utils.validateTopics" id="apidoc.element.kafka-node.utils.validateTopics">
        function <span class="apidocSignatureSpan">kafka-node.utils.</span>validateTopics
        <span class="apidocSignatureSpan">(topics)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function validateTopics(topics) {
  if (topics.some(function (topic) {
    if (&#x27;partition&#x27; in topic) {
      return typeof topic.partition !== &#x27;number&#x27;;
    }
    return false;
  })) {
    throw new InvalidConfigError(&#x27;Offset must be a number and can not contain characters&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
})();

var Consumer = function (client, topics, options) {
if (!topics) {
  throw new Error(&#x27;Must have payloads&#x27;);
}

utils.<span class="apidocCodeKeywordSpan">validateTopics</span>(topics);

this.fetchCount = 0;
this.client = client;
this.options = _.defaults((options || {}), DEFAULTS);
this.ready = false;
this.paused = this.options.paused;
this.id = nextId();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.kafka-node.zookeeper" id="apidoc.module.kafka-node.zookeeper">module kafka-node.zookeeper</a></h1>


    <h2>
        <a href="#apidoc.element.kafka-node.zookeeper.Zookeeper" id="apidoc.element.kafka-node.zookeeper.Zookeeper">
        function <span class="apidocSignatureSpan">kafka-node.zookeeper.</span>Zookeeper
        <span class="apidocSignatureSpan">(connectionString, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Zookeeper = function (connectionString, options) {
  this.client = zookeeper.createClient(connectionString, options);

  var that = this;
  this.client.on(&#x27;connected&#x27;, function () {
    that.listBrokers();
  });
  this.client.on(&#x27;disconnected&#x27;, function () {
    that.emit(&#x27;disconnected&#x27;);
  });
  this.client.connect();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.kafka-node.zookeeper.ZookeeperConsumerMappings" id="apidoc.element.kafka-node.zookeeper.ZookeeperConsumerMappings">
        function <span class="apidocSignatureSpan">kafka-node.zookeeper.</span>ZookeeperConsumerMappings
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ZookeeperConsumerMappings = function () {
  this.consumerTopicMap = {};
  this.topicConsumerMap = {};
  this.topicPartitionMap = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
